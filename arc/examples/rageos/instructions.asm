; ============================================================================
; rose2arc.py
; input = examples/rageos/bytecodes.bin.
; ============================================================================

.equ ST_PROC, 0
.equ ST_X, 1
.equ ST_Y, 2
.equ ST_SIZE, 3
.equ ST_TINT, 4
.equ ST_RAND, 5
.equ ST_DIR, 6
.equ ST_TIME, 7
.equ ST_WIRE0, 8
.equ ST_WIRE1, 9
.equ ST_WIRE2, 10
.equ ST_WIRE3, 11
.equ ST_WIRE4, 12
.equ ST_WIRE5, 13
.equ ST_WIRE6, 14
.equ ST_WIRE7, 15

; ============================================================================
; r3 = p_StateStack.	(preserve)
; r4 = r_Constants.	(preserve)
; r5 = p_State.		(preserve)
; r6 = r_Statelists	(preserve).
; r7 = r_Sinus.		(preserve)
; ============================================================================

proc_0_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_0
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_0:
	; BC_PROC [07]
	adr r0, proc_12_start		; r0=r_Procedures[12]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_1
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_1:
	; BC_PROC [07]
	adr r0, proc_1_start		; r0=r_Procedures[1]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_2
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_2:
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_3
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_3:
	; BC_PROC [07]
	adr r0, proc_13_start		; r0=r_Procedures[13]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_4
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_4:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_45_start		; r0=r_Procedures[45]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_5
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_5:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_6
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_6:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_7
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_7:
	; BC_PROC [07]
	adr r0, proc_55_start		; r0=r_Procedures[55]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_8
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_8:
	; BC_PROC [07]
	adr r0, proc_68_start		; r0=r_Procedures[68]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [84]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x002b0000			; r0=rConstants[4] (43.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_9
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_9:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_69_start		; r0=r_Procedures[69]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[6] (48.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_10
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_10:
	; BC_PROC [07]
	adr r0, proc_70_start		; r0=r_Procedures[70]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x002a0000			; r0=rConstants[7] (42.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_11
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_11:
	; BC_PROC [07]
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_12
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_12:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [89]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00380000			; r0=rConstants[9] (56.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_13
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_13:
	; BC_PROC [07]
	adr r0, proc_72_start		; r0=r_Procedures[72]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_14
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_14:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_69_start		; r0=r_Procedures[69]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[6] (48.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_15
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_15:
	; BC_PROC [07]
	adr r0, proc_73_start		; r0=r_Procedures[73]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_16
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_16:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_17
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_17:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_18
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_18:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_19
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_19:
	; BC_PROC [07]
	adr r0, proc_116_start		; r0=r_Procedures[116]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_0_continue_20
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_20:
	; BC_PROC [07]
	adr r0, proc_84_start		; r0=r_Procedures[84]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_0_end:

proc_1_start:
	; BC_CONST [8d]
	mov r0, #0x00b30000			; r0=rConstants[13] (179.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [8e]
	mov r0, #0x003e0000			; r0=rConstants[14] (62.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8f]
	ldr r0, [r4, #15*4]			; r0=rConstants[15]=0x00002666 (0.1500)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [90]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #16*4]			; r0=rConstants[16]=0x00004ccd (0.3000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [92]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_4_start		; r0=r_Procedures[4]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [93]
	mov r0, #0x00c40000			; r0=rConstants[19] (196.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [8e]
	mov r0, #0x003e0000			; r0=rConstants[14] (62.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [94]
	ldr r0, [r4, #20*4]			; r0=rConstants[20]=0x0000599a (0.3500)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [94]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #20*4]			; r0=rConstants[20]=0x0000599a (0.3500)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [92]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_4_start		; r0=r_Procedures[4]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_21
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_21:
	; BC_CONST [95]
	mov r0, #0x00bb0000			; r0=rConstants[21] (187.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [96]
	mov r0, #0x00520000			; r0=rConstants[22] (82.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [98]
	mov r0, #0x00b00000			; r0=rConstants[24] (176.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [99]
	mov r0, #0x00530000			; r0=rConstants[25] (83.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9a]
	mov r0, #0x00f00000			; r0=rConstants[26] (240.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9b]
	mov r0, #0x00160000			; r0=rConstants[27] (22.0000)
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_22
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_22:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9e]
	mov r0, #0x00b80000			; r0=rConstants[30] (184.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [8e]
	mov r0, #0x003e0000			; r0=rConstants[14] (62.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9f]
	mov r0, #0x00ea0000			; r0=rConstants[31] (234.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a0]
	mov r0, #0x00b60000			; r0=rConstants[32] (182.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [8e]
	mov r0, #0x003e0000			; r0=rConstants[14] (62.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a1]
	mov r0, #0x00960000			; r0=rConstants[33] (150.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_23
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_23:
	; BC_CONST [a3]
	mov r0, #0x009a0000			; r0=rConstants[35] (154.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a4]
	mov r0, #0x00660000			; r0=rConstants[36] (102.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_24
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_24:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_25
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_25:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_26
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_26:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00320000			; r0=rConstants[37] (50.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_27
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_27:
	; BC_CONST [a6]
	mov r0, #0x00e00000			; r0=rConstants[38] (224.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a7]
	mov r0, #0x00120000			; r0=rConstants[39] (18.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x00600000			; r0=rConstants[40] (96.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a9]
	mov r0, #0x00018000			; r0=rConstants[41] (1.5000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [aa]
	mov r0, #0x00230000			; r0=rConstants[42] (35.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [ab]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #43*4]			; r0=rConstants[43]=0x00006666 (0.4000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ac]
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_WAIT [0a]
	adr r1, proc_1_continue_28
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_1_continue_28:
	; BC_CONST [ad]
	mov r0, #0x00780000			; r0=rConstants[45] (120.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_1_end:

proc_2_start:
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_2_continue_29
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_29:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_118_start		; r0=r_Procedures[118]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_2_continue_30
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_30:
	; BC_PROC [07]
	adr r0, proc_119_start		; r0=r_Procedures[119]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_2_continue_31
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_31:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PROC [07]
	adr r0, proc_117_start		; r0=r_Procedures[117]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [af]
	mov r0, #0x01f40000			; r0=rConstants[47] (500.0000)
	; BC_WAIT [0a]
	adr r1, proc_2_continue_32
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_32:
	; BC_PROC [07]
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_2_continue_33
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_33:
	; BC_PROC [07]
	adr r0, proc_121_start		; r0=r_Procedures[121]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_2_continue_34
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_34:
	; BC_PROC [07]
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_2_continue_35
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_35:
	; BC_PROC [07]
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_2_end:

proc_3_start:
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_3_continue_36
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_3_continue_36:
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_3_continue_37
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_3_continue_37:
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_3_continue_38
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_3_continue_38:
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_3_continue_39
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_3_continue_39:
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_3_continue_40
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_3_continue_40:
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_3_continue_41
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_3_continue_41:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_3_end:

proc_4_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_4_target_42
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WAIT [0a]
	adr r1, proc_4_continue_43
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_4_continue_43:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WLOCAL [43]
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_4_start		; r0=r_Procedures[4]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_4_target_44
proc_4_target_42:
	; BC_CONST [ac]
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_5_start		; r0=r_Procedures[5]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_4_target_44:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_4_end:

proc_5_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_5_target_45
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_5_continue_46
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_5_continue_46:
	; BC_PROC [07]
	adr r0, proc_5_start		; r0=r_Procedures[5]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_5_target_47
proc_5_target_45:
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_5_continue_48
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_5_continue_48:
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_6_start		; r0=r_Procedures[6]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [92]
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_WAIT [0a]
	adr r1, proc_5_continue_49
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_5_continue_49:
	; BC_PROC [07]
	adr r0, proc_7_start		; r0=r_Procedures[7]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_5_target_47:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_5_end:

proc_6_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_6_target_50
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [76]
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WAIT [0a]
	adr r1, proc_6_continue_51
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_6_continue_51:
	; BC_PROC [07]
	adr r0, proc_6_start		; r0=r_Procedures[6]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_6_target_50:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_6_end:

proc_7_start:
	; BC_CONST [a6]
	mov r0, #0x00e00000			; r0=rConstants[38] (224.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_7_continue_52
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_7_continue_52:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_7_continue_53
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_7_continue_53:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_7_continue_54
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_7_continue_54:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_7_end:

proc_8_start:
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_9_start		; r0=r_Procedures[9]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_9_start		; r0=r_Procedures[9]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_9_start		; r0=r_Procedures[9]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [b3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00c00000			; r0=rConstants[51] (192.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_9_start		; r0=r_Procedures[9]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b3]
	mov r0, #0x00c00000			; r0=rConstants[51] (192.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_9_start		; r0=r_Procedures[9]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b3]
	mov r0, #0x00c00000			; r0=rConstants[51] (192.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_9_start		; r0=r_Procedures[9]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_8_end:

proc_9_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_9_continue_55
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_9_continue_55:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_9_continue_56
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_9_continue_56:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_9_continue_57
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_9_continue_57:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_9_end:

proc_10_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_10_end:

proc_11_start:
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [76]
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00500000			; r0=rConstants[53] (80.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_11_end:

proc_12_start:
	; BC_CONST [ac]
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_CONST [b7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00410000			; r0=rConstants[55] (65.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_12_continue_58
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_12_continue_58:
	; BC_PROC [07]
	adr r0, proc_15_start		; r0=r_Procedures[15]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b8]
	mov r0, #0x00180000			; r0=rConstants[56] (24.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_12_continue_59
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_12_continue_59:
	; BC_PROC [07]
	adr r0, proc_16_start		; r0=r_Procedures[16]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_12_continue_60
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_12_continue_60:
	; BC_PROC [07]
	adr r0, proc_17_start		; r0=r_Procedures[17]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b9]
	mov r0, #0x00240000			; r0=rConstants[57] (36.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_12_continue_61
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_12_continue_61:
	; BC_PROC [07]
	adr r0, proc_18_start		; r0=r_Procedures[18]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_12_continue_62
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_12_continue_62:
	; BC_CONST [a5]
	mov r0, #0x00320000			; r0=rConstants[37] (50.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_19_start		; r0=r_Procedures[19]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_12_continue_63
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_12_continue_63:
	; BC_CONST [ba]
	mov r0, #0x005f0000			; r0=rConstants[58] (95.0000)
	; BC_CONST [bb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00390000			; r0=rConstants[59] (57.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [93]
	mov r0, #0x00c40000			; r0=rConstants[19] (196.0000)
	; BC_CONST [a5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00320000			; r0=rConstants[37] (50.0000)
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_20_start		; r0=r_Procedures[20]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [92]
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_CONST [bc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00750000			; r0=rConstants[60] (117.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [c1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [c1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00500000			; r0=rConstants[53] (80.0000)
	; BC_WAIT [0a]
	adr r1, proc_12_continue_64
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_12_continue_64:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_24_start		; r0=r_Procedures[24]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_12_end:

proc_13_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c4]
	mov r0, #0x00690000			; r0=rConstants[68] (105.0000)
	; BC_CONST [bb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00390000			; r0=rConstants[59] (57.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_65
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_65:
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_66
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_66:
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_67
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_67:
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_68
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_68:
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_13_end:

proc_14_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_14_end:

proc_15_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x00600000			; r0=rConstants[40] (96.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c9]
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_15_end:

proc_16_start:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_16_end:

proc_17_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_17_end:

proc_18_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_29_start		; r0=r_Procedures[29]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_29_start		; r0=r_Procedures[29]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_29_start		; r0=r_Procedures[29]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00120000			; r0=rConstants[39] (18.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00120000			; r0=rConstants[39] (18.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_18_end:

proc_19_start:
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_31_start		; r0=r_Procedures[31]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[56] (24.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_31_start		; r0=r_Procedures[31]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_19_end:

proc_20_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_20_continue_69
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_20_continue_69:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_20_continue_70
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_20_continue_70:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_20_continue_71
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_20_continue_71:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_20_continue_72
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_20_continue_72:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_20_end:

proc_21_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_27_start		; r0=r_Procedures[27]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [76]
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_27_start		; r0=r_Procedures[27]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [76]
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_27_start		; r0=r_Procedures[27]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [76]
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_27_start		; r0=r_Procedures[27]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_21_end:

proc_22_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_22_end:

proc_23_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_73
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_73:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_74
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_74:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_75
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_75:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_76
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_76:
	; BC_RLOCAL [64]
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_77
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_77:
	; BC_RLOCAL [65]
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_78
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_78:
	; BC_RLOCAL [66]
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_79
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_79:
	; BC_RLOCAL [67]
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_80
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_80:
	; BC_RLOCAL [68]
	ldr r0, [r5, #-9*4]			; r0=StateStack[-9]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_81
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_81:
	; BC_RLOCAL [69]
	ldr r0, [r5, #-10*4]			; r0=StateStack[-10]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7c]
	ldr r0, [r5, #ST_WIRE4*4]		; r0=State[ST_WIRE4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_82
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_82:
	; BC_PROC [07]
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_RLOCAL [6a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-11*4]			; r0=StateStack[-11]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WLOCAL [43]
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_WLOCAL [42]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_23_end:

proc_24_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_24_target_83
	; BC_CONST [cc]
	mov r0, #0x008c0000			; r0=rConstants[76] (140.0000)
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_24_continue_84
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_24_continue_84:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_24_continue_85
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_24_continue_85:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_24_continue_86
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_24_continue_86:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_24_continue_87
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_24_continue_87:
	; BC_PROC [07]
	adr r0, proc_24_start		; r0=r_Procedures[24]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_24_target_88
proc_24_target_83:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_CONST [cd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_24_target_88:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_24_end:

proc_25_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_25_target_89
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [ce]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_38_start		; r0=r_Procedures[38]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WAIT [0a]
	adr r1, proc_25_continue_90
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_25_continue_90:
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_25_target_89:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_25_end:

proc_26_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_26_target_91
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_26_continue_92
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_26_continue_92:
	; BC_PROC [07]
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_26_target_91:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_26_end:

proc_27_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_27_target_93
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_27_continue_94
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_27_continue_94:
	; BC_PROC [07]
	adr r0, proc_27_start		; r0=r_Procedures[27]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_27_target_93:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_27_end:

proc_28_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_28_target_95
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_28_continue_96
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_28_continue_96:
	; BC_RSTATE [76]
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_28_target_95:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_28_end:

proc_29_start:
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_29_end:

proc_30_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_30_target_97
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_30_continue_98
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_30_continue_98:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_30_target_97:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_30_end:

proc_31_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_99
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_99:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_100
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_100:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00120000			; r0=rConstants[39] (18.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [cf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00004000			; r0=rConstants[79] (0.2500)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_CONST [d0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_101
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_101:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_40_start		; r0=r_Procedures[40]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_102
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_102:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_103
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_103:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_40_start		; r0=r_Procedures[40]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_104
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_104:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_31_end:

proc_32_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_32_end:

proc_33_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_33_continue_105
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_33_continue_105:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_33_continue_106
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_33_continue_106:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_33_continue_107
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_33_continue_107:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_33_continue_108
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_33_continue_108:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_33_end:

proc_34_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_34_continue_109
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_34_continue_109:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_34_end:

proc_35_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_35_target_110
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_35_continue_111
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_35_continue_111:
	; BC_PROC [07]
	adr r0, proc_35_start		; r0=r_Procedures[35]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_35_target_110:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_35_end:

proc_36_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_41_start		; r0=r_Procedures[41]
	; BC_FORK [25]
	mov r1, #5
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_36_end:

proc_37_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_37_target_112
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_37_continue_113
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_37_continue_113:
	; BC_PROC [07]
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_37_target_112:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_37_end:

proc_38_start:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_38_target_114
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_42_start		; r0=r_Procedures[42]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_42_start		; r0=r_Procedures[42]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_42_start		; r0=r_Procedures[42]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_42_start		; r0=r_Procedures[42]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_42_start		; r0=r_Procedures[42]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_42_start		; r0=r_Procedures[42]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_38_continue_115
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_38_continue_115:
	; BC_PROC [07]
	adr r0, proc_38_start		; r0=r_Procedures[38]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_38_target_114:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_38_end:

proc_39_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_39_end:

proc_40_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_40_target_116
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_40_continue_117
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_117:
	; BC_PROC [07]
	adr r0, proc_40_start		; r0=r_Procedures[40]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_40_target_116:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_40_end:

proc_41_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_41_target_118
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_43_start		; r0=r_Procedures[43]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7d]
	ldr r0, [r5, #ST_WIRE5*4]		; r0=State[ST_WIRE5]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WAIT [0a]
	adr r1, proc_41_continue_119
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_41_continue_119:
	; BC_PROC [07]
	adr r0, proc_41_start		; r0=r_Procedures[41]
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_41_target_118:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_41_end:

proc_42_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1d]
	blt proc_42_target_120
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_42_target_121
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1d]
	blt proc_42_target_122
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_42_target_122:
	; BC_DONE [00]
proc_42_target_121:
	; BC_DONE [00]
proc_42_target_120:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_42_end:

proc_43_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_43_end:

proc_44_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_44_target_123
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_44_target_124
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_44_target_124:
	; BC_RSTATE [7d]
	ldr r0, [r5, #ST_WIRE5*4]		; r0=State[ST_WIRE5]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WAIT [0a]
	adr r1, proc_44_continue_125
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_44_continue_125:
	; BC_PROC [07]
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_44_target_123:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_44_end:

proc_45_start:
	; BC_CONST [b5]
	mov r0, #0x00500000			; r0=rConstants[53] (80.0000)
	; BC_CONST [d1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d2]
	mov r0, #0x00650000			; r0=rConstants[82] (101.0000)
	; BC_CONST [c9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_CONST [a2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_20_start		; r0=r_Procedures[20]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_126
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_126:
	; BC_CONST [a7]
	mov r0, #0x00120000			; r0=rConstants[39] (18.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [d5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_45_continue_127
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_127:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [c0]
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_128
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_128:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_129
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_129:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_130
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_130:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_131
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_131:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d7]
	ldr r0, [r4, #87*4]			; r0=rConstants[87]=0x823f3f20 (33343.2466)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_132
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_132:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_133
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_133:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_134
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_134:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_135
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_135:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_136
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_136:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_137
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_137:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_45_continue_138
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_138:
	; BC_CONST [92]
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_CONST [d1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_139
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_139:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_45_continue_140
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_140:
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [db]
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [dc]
	ldr r0, [r4, #92*4]			; r0=rConstants[92]=0xf0000002 (61440.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_45_continue_141
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_141:
	; BC_PROC [07]
	adr r0, proc_47_start		; r0=r_Procedures[47]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_45_continue_142
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_142:
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_WSTATE [51]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_45_continue_143
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_45_continue_143:
	; BC_PROC [07]
	adr r0, proc_46_start		; r0=r_Procedures[46]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_45_end:

proc_46_start:
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [92]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_CONST [d1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_144
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_144:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_145
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_145:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_146
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_146:
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [db]
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [dc]
	ldr r0, [r4, #92*4]			; r0=rConstants[92]=0xf0000002 (61440.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_46_continue_147
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_147:
	; BC_PROC [07]
	adr r0, proc_47_start		; r0=r_Procedures[47]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_46_continue_148
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_148:
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_WSTATE [51]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_46_continue_149
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_149:
	; BC_CONST [92]
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_CONST [d1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [dd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00088000			; r0=rConstants[93] (8.5000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c0]
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_150
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_150:
	; BC_CONST [de]
	ldr r0, [r4, #94*4]			; r0=rConstants[94]=0x82071fa2 (33287.1236)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_151
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_151:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [db]
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_152
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_152:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_153
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_153:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d7]
	ldr r0, [r4, #87*4]			; r0=rConstants[87]=0x823f3f20 (33343.2466)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [df]
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [e0]
	ldr r0, [r4, #96*4]			; r0=rConstants[96]=0x90400e26 (36928.0553)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_46_continue_154
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_154:
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [b1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_47_start		; r0=r_Procedures[47]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [72]
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_47_start		; r0=r_Procedures[47]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_46_continue_155
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_155:
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_WSTATE [51]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_156
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_156:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_157
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_157:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_158
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_158:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_159
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_159:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_160
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_160:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_161
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_161:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_162
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_162:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_163
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_163:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_164
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_164:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_165
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_165:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_166
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_166:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_46_continue_167
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_167:
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_168
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_168:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_169
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_169:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_170
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_170:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_171
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_171:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_172
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_172:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_46_continue_173
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_173:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_3_start		; r0=r_Procedures[3]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_174
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_174:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_3_start		; r0=r_Procedures[3]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_46_continue_175
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_46_continue_175:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_46_end:

proc_47_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_176
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_176:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_177
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_177:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_178
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_178:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_179
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_179:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_180
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_180:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_181
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_181:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_182
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_182:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_183
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_183:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_184
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_184:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_185
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_185:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_186
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_186:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_187
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_187:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_188
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_188:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_189
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_189:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_190
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_190:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_191
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_191:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_192
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_192:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_193
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_193:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_194
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_194:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_195
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_195:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_196
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_196:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_197
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_197:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_198
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_198:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_199
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_199:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_200
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_200:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_47_end:

proc_48_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_48_target_201
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ae]
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_48_continue_202
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_48_continue_202:
	; BC_PROC [07]
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_48_target_201:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_48_end:

proc_49_start:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_49_continue_203
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_49_continue_203:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_49_end:

proc_50_start:
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_50_continue_204
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_204:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_50_end:

proc_51_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_51_target_205
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_206
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_206:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_51_start		; r0=r_Procedures[51]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_51_target_205:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_51_end:

proc_52_start:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_52_end:

proc_53_start:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_53_end:

proc_54_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RSTATE [7b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE3*4]		; r0=State[ST_WIRE3]
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_54_end:

proc_55_start:
	; BC_CONST [e1]
	mov r0, #0x009d0000			; r0=rConstants[97] (157.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_56_start		; r0=r_Procedures[56]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_57_start		; r0=r_Procedures[57]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_55_continue_207
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_55_continue_207:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_58_start		; r0=r_Procedures[58]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [e2]
	mov r0, #0x01400000			; r0=rConstants[98] (320.0000)
	; BC_CONST [e3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #99*4]			; r0=rConstants[99]=0x00001999 (0.1000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c9]
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [ca]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a5]
	mov r0, #0x00320000			; r0=rConstants[37] (50.0000)
	; BC_WAIT [0a]
	adr r1, proc_55_continue_208
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_55_continue_208:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9b]
	mov r0, #0x00160000			; r0=rConstants[27] (22.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_59_start		; r0=r_Procedures[59]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_55_continue_209
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_55_continue_209:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_58_start		; r0=r_Procedures[58]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_55_end:

proc_56_start:
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [e4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a50000			; r0=rConstants[100] (165.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_CONST [e5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01180000			; r0=rConstants[101] (280.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [e6]
	mov r0, #0x00250000			; r0=rConstants[102] (37.0000)
	; BC_CONST [ca]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_WAIT [0a]
	adr r1, proc_56_continue_210
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_56_continue_210:
	; BC_CONST [e7]
	mov r0, #0x00a60000			; r0=rConstants[103] (166.0000)
	; BC_CONST [e5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01180000			; r0=rConstants[101] (280.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [e8]
	ldr r0, [r4, #104*4]			; r0=rConstants[104]=0xf8800083 (63616.0020)
	; BC_CONST [e9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #105*4]			; r0=rConstants[105]=0x98611bb6 (39009.1082)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [e9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #105*4]			; r0=rConstants[105]=0x98611bb6 (39009.1082)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #106*4]			; r0=rConstants[106]=0x18410725 (6209.0279)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x002a0000			; r0=rConstants[7] (42.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_60_start		; r0=r_Procedures[60]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_56_end:

proc_57_start:
	; BC_CONST [c9]
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [ca]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_57_end:

proc_58_start:
	; BC_PROC [07]
	adr r0, proc_61_start		; r0=r_Procedures[61]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_58_end:

proc_59_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_59_target_211
	; BC_PROC [07]
	adr r0, proc_62_start		; r0=r_Procedures[62]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [eb]
	mov r0, #0x00190000			; r0=rConstants[107] (25.0000)
	; BC_WAIT [0a]
	adr r1, proc_59_continue_212
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_212:
	; BC_CONST [9b]
	mov r0, #0x00160000			; r0=rConstants[27] (22.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_59_start		; r0=r_Procedures[59]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_59_target_211:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_59_end:

proc_60_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_60_target_213
	; BC_PROC [07]
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00320000			; r0=rConstants[37] (50.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_214
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_214:
	; BC_PROC [07]
	adr r0, proc_60_start		; r0=r_Procedures[60]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_60_target_215
proc_60_target_213:
	; BC_PROC [07]
	adr r0, proc_65_start		; r0=r_Procedures[65]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_60_target_216
	; BC_CONST [e8]
	ldr r0, [r4, #104*4]			; r0=rConstants[104]=0xf8800083 (63616.0020)
	; BC_CONST [e9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #105*4]			; r0=rConstants[105]=0x98611bb6 (39009.1082)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [e9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #105*4]			; r0=rConstants[105]=0x98611bb6 (39009.1082)
	; BC_CONST [ec]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #108*4]			; r0=rConstants[108]=0x9a5616a6 (39510.0885)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_60_target_216:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_60_target_217
	; BC_CONST [e8]
	ldr r0, [r4, #104*4]			; r0=rConstants[104]=0xf8800083 (63616.0020)
	; BC_CONST [e9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #105*4]			; r0=rConstants[105]=0x98611bb6 (39009.1082)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [e9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #105*4]			; r0=rConstants[105]=0x98611bb6 (39009.1082)
	; BC_CONST [ed]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #109*4]			; r0=rConstants[109]=0x92461ea6 (37446.1197)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_60_target_217:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_60_target_218
	; BC_CONST [e8]
	ldr r0, [r4, #104*4]			; r0=rConstants[104]=0xf8800083 (63616.0020)
	; BC_CONST [e9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #105*4]			; r0=rConstants[105]=0x98611bb6 (39009.1082)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [ee]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #110*4]			; r0=rConstants[110]=0x820f08f0 (33295.0349)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_60_target_218:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_60_target_219
	; BC_PROC [07]
	adr r0, proc_60_start		; r0=r_Procedures[60]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [ef]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[111] (60.0000)
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_60_target_219:
	; BC_DONE [00]
proc_60_target_215:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_60_end:

proc_61_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [ef]
	mov r0, #0x003c0000			; r0=rConstants[111] (60.0000)
	; BC_CONST [cc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x008c0000			; r0=rConstants[76] (140.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [db]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [c9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [c9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [da]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [c1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_61_end:

proc_62_start:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_62_end:

proc_63_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_220
	; BC_CONST [f0]
	ldr r0, [r4, #112*4]			; r0=rConstants[112]=0x3c7ec001 (15486.7500)
	; BC_CONST [f1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #113*4]			; r0=rConstants[113]=0x00080004 (8.0001)
	; BC_CONST [f2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #114*4]			; r0=rConstants[114]=0x20034092 (8195.2522)
	; BC_CONST [f3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #115*4]			; r0=rConstants[115]=0xc0824882 (49282.2832)
	; BC_CONST [f4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #116*4]			; r0=rConstants[116]=0x41442138 (16708.1298)
	; BC_CONST [f5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #117*4]			; r0=rConstants[117]=0x1e081008 (7688.0626)
	; BC_CONST [f6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #118*4]			; r0=rConstants[118]=0x10041004 (4100.0626)
	; BC_CONST [f7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #119*4]			; r0=rConstants[119]=0x20042084 (8196.1270)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_220:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_221
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [f8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #120*4]			; r0=rConstants[120]=0x00007ffe (0.5000)
	; BC_CONST [f9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #121*4]			; r0=rConstants[121]=0x3ffc5ffa (16380.3749)
	; BC_CONST [fa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #122*4]			; r0=rConstants[122]=0x6ff677ee (28662.4685)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #123*4]			; r0=rConstants[123]=0x68165ffa (26646.3749)
	; BC_CONST [fc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #124*4]			; r0=rConstants[124]=0x3ffc7ffe (16380.5000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_221:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_222
	; BC_CONST [fd]
	ldr r0, [r4, #125*4]			; r0=rConstants[125]=0x78384648 (30776.2745)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x21903000 (8592.1875)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x43b04448 (17328.2667)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #128*4]			; r0=rConstants[128]=0x86680440 (34408.0166)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #129*4]			; r0=rConstants[129]=0x03be201d (958.1254)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x20091001 (8201.0625)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x08090612 (2057.0237)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #132*4]			; r0=rConstants[132]=0x05ec0800 (1516.0312)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_222:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_223
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x62236223 (25123.3833)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x62236223 (25123.3833)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x62236223 (25123.3833)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x77777777 (30583.4667)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x77777777 (30583.4667)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #135*4]			; r0=rConstants[135]=0x00007777 (0.4667)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_223:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_224
	; BC_CONST [fe]
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x08180c28 (2072.0475)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #137*4]			; r0=rConstants[137]=0x0bc8040c (3016.0158)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #138*4]			; r0=rConstants[138]=0x06c20922 (1730.0357)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #139*4]			; r0=rConstants[139]=0x0da116c0 (3489.0889)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #140*4]			; r0=rConstants[140]=0x20044004 (8196.2501)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #141*4]			; r0=rConstants[141]=0x4008a830 (16392.6570)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #142*4]			; r0=rConstants[142]=0x80c08120 (32960.5044)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #143*4]			; r0=rConstants[143]=0x42103c10 (16912.2346)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_224:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_225
	; BC_CONST [fe]
	ldr r0, [r4, #144*4]			; r0=rConstants[144]=0x44004404 (17408.2657)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #145*4]			; r0=rConstants[145]=0x888480c2 (34948.5030)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #146*4]			; r0=rConstants[146]=0x41e223e4 (16866.1402)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #147*4]			; r0=rConstants[147]=0x00200f80 (32.0605)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #148*4]			; r0=rConstants[148]=0x1fec1dfc (8172.1171)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #149*4]			; r0=rConstants[149]=0x0ff86000 (4088.3750)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #150*4]			; r0=rConstants[150]=0xff74ffde (65396.9995)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #151*4]			; r0=rConstants[151]=0x7ffe1ffc (32766.1249)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_225:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_226
	; BC_CONST [fe]
	mov r0, #0x00000ff8			; r0=rConstants[152] (0.0624)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x0ff80000			; r0=rConstants[153] (4088.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x01c001c0 (448.0068)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x01c001c0 (448.0068)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #155*4]			; r0=rConstants[155]=0x01c00ff8 (448.0624)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #156*4]			; r0=rConstants[156]=0x07f003e0 (2032.0151)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #157*4]			; r0=rConstants[157]=0x01c00080 (448.0020)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_226:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_63_target_227
	; BC_CONST [fe]
	ldr r0, [r4, #158*4]			; r0=rConstants[158]=0x04100a28 (1040.0397)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x11442082 (4420.1270)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #160*4]			; r0=rConstants[160]=0x1004280a (4100.1564)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x14140808 (5140.0314)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #162*4]			; r0=rConstants[162]=0x10042082 (4100.1270)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #163*4]			; r0=rConstants[163]=0x11442aaa (4420.1667)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #164*4]			; r0=rConstants[164]=0x15540a28 (5460.0397)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x04100000			; r0=rConstants[165] (1040.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_63_target_227:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_63_end:

proc_64_start:
	; BC_RSTATE [71]
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [eb]
	mov r0, #0x00190000			; r0=rConstants[107] (25.0000)
	; BC_WAIT [0a]
	adr r1, proc_64_continue_228
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_64_continue_228:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_64_end:

proc_65_start:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_65_end:

proc_66_start:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_66_continue_229
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_66_continue_229:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_66_continue_230
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_66_continue_230:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_66_continue_231
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_66_continue_231:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_66_continue_232
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_66_continue_232:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [64]
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_66_continue_233
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_66_continue_233:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [65]
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_66_continue_234
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_66_continue_234:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [66]
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_66_continue_235
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_66_continue_235:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_RLOCAL [67]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_66_end:

proc_67_start:
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_67_target_236
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DONE [00]
proc_67_target_236:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_67_target_237
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_67_target_238
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_67_target_238:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [cf]
	mov r0, #0x00004000			; r0=rConstants[79] (0.2500)
	; BC_WAIT [0a]
	adr r1, proc_67_continue_239
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_67_continue_239:
	; BC_PROC [07]
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_67_target_237:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_67_end:

proc_68_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_68_continue_240
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_68_continue_240:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_68_continue_241
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_68_continue_241:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_68_continue_242
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_68_continue_242:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [cb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_68_continue_243
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_68_continue_243:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_68_end:

proc_69_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_76_start		; r0=r_Procedures[76]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [e6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00250000			; r0=rConstants[102] (37.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_69_continue_244
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_69_continue_244:
	; BC_PROC [07]
	adr r0, proc_77_start		; r0=r_Procedures[77]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_69_end:

proc_70_start:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5e]
	str r0, [r5, #ST_WIRE6*4]		; State[ST_WIRE6]=r0
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [ca]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_70_continue_245
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_70_continue_245:
	; BC_PROC [07]
	adr r0, proc_79_start		; r0=r_Procedures[79]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_70_continue_246
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_70_continue_246:
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_CONST [b1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_80_start		; r0=r_Procedures[80]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_70_end:

proc_71_start:
	; BC_PROC [07]
	adr r0, proc_81_start		; r0=r_Procedures[81]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [84]
	mov r0, #0x002b0000			; r0=rConstants[4] (43.0000)
	; BC_CONST [a2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00480000			; r0=rConstants[166] (72.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_82_start		; r0=r_Procedures[82]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00160000			; r0=rConstants[27] (22.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_71_continue_247
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_71_continue_247:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_71_continue_248
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_71_continue_248:
	; BC_PROC [07]
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_71_continue_249
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_71_continue_249:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [89]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00380000			; r0=rConstants[9] (56.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_71_continue_250
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_71_continue_250:
	; BC_PROC [07]
	adr r0, proc_84_start		; r0=r_Procedures[84]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_71_end:

proc_72_start:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_72_continue_251
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_72_continue_251:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_72_continue_252
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_72_continue_252:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b7]
	mov r0, #0x00410000			; r0=rConstants[55] (65.0000)
	; BC_WAIT [0a]
	adr r1, proc_72_continue_253
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_72_continue_253:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_72_end:

proc_73_start:
	; BC_CONST [a9]
	mov r0, #0x00018000			; r0=rConstants[41] (1.5000)
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_PROC [07]
	adr r0, proc_85_start		; r0=r_Procedures[85]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [fe]
	mov r0, #0x00290000			; r0=rConstants[167] (41.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_86_start		; r0=r_Procedures[86]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[6] (48.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_73_continue_254
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_73_continue_254:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_87_start		; r0=r_Procedures[87]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_73_continue_255
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_73_continue_255:
	; BC_CONST [fe]
	mov r0, #0x005d0000			; r0=rConstants[168] (93.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00870000			; r0=rConstants[169] (135.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [98]
	mov r0, #0x00b00000			; r0=rConstants[24] (176.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x002d0000			; r0=rConstants[170] (45.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x002a0000			; r0=rConstants[7] (42.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_88_start		; r0=r_Procedures[88]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_73_continue_256
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_73_continue_256:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_89_start		; r0=r_Procedures[89]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_73_continue_257
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_73_continue_257:
	; BC_CONST [fe]
	mov r0, #0x005d0000			; r0=rConstants[168] (93.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00870000			; r0=rConstants[169] (135.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	mov r0, #0x00150000			; r0=rConstants[172] (21.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_90_start		; r0=r_Procedures[90]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_91_start		; r0=r_Procedures[91]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_73_continue_258
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_73_continue_258:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_73_continue_259
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_73_continue_259:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_73_continue_260
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_73_continue_260:
	; BC_PROC [07]
	adr r0, proc_84_start		; r0=r_Procedures[84]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_73_end:

proc_74_start:
	; BC_CONST [fe]
	mov r0, #0x00a80000			; r0=rConstants[173] (168.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00210000			; r0=rConstants[174] (33.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9b]
	mov r0, #0x00160000			; r0=rConstants[27] (22.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [c8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_92_start		; r0=r_Procedures[92]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_74_end:

proc_75_start:
	; BC_CONST [fe]
	mov r0, #0x00a80000			; r0=rConstants[173] (168.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00210000			; r0=rConstants[174] (33.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9b]
	mov r0, #0x00160000			; r0=rConstants[27] (22.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [c8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_92_start		; r0=r_Procedures[92]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_94_start		; r0=r_Procedures[94]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_75_end:

proc_76_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ef]
	mov r0, #0x003c0000			; r0=rConstants[111] (60.0000)
	; BC_CONST [d1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [db]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_95_start		; r0=r_Procedures[95]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00500000			; r0=rConstants[53] (80.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_76_continue_261
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_76_continue_261:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_76_target_262
	; BC_CONST [fe]
	mov r0, #0x01220000			; r0=rConstants[175] (290.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_76_target_263
proc_76_target_262:
	; BC_CONST [fe]
	mov r0, #0x01900000			; r0=rConstants[176] (400.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_76_target_263:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_76_target_264
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001a0000			; r0=rConstants[177] (26.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_76_continue_265
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_76_continue_265:
	; BC_ELSE [01]
	b proc_76_target_266
proc_76_target_264:
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WAIT [0a]
	adr r1, proc_76_continue_267
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_76_continue_267:
	; BC_DONE [00]
proc_76_target_266:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ef]
	mov r0, #0x003c0000			; r0=rConstants[111] (60.0000)
	; BC_CONST [d1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [db]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_95_start		; r0=r_Procedures[95]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_76_end:

proc_77_start:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [d0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_268
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_77_target_268:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_269
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_77_target_269:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_270
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_77_target_270:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_271
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_77_target_271:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_272
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_77_target_272:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_273
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_77_target_273:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_274
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_77_target_274:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_77_target_275
	; BC_PROC [07]
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_77_target_275:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_77_end:

proc_78_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [cb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_276
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_276:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_277
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_277:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_278
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_278:
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_279
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_279:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_280
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_280:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_281
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_281:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_282
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_282:
	; BC_CONST [c0]
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_283
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_283:
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_284
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_284:
	; BC_CONST [de]
	ldr r0, [r4, #94*4]			; r0=rConstants[94]=0x82071fa2 (33287.1236)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_285
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_285:
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_286
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_286:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_287
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_287:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_288
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_288:
	; BC_CONST [fe]
	mov r0, #0x00000002			; r0=rConstants[178] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_289
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_289:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_290
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_290:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_291
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_291:
	; BC_CONST [db]
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_292
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_292:
	; BC_CONST [fe]
	mov r0, #0x001d0000			; r0=rConstants[179] (29.0000)
	; BC_CONST [cb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_293
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_293:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_294
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_294:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_295
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_295:
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_296
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_296:
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_297
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_297:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_298
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_298:
	; BC_CONST [e8]
	ldr r0, [r4, #104*4]			; r0=rConstants[104]=0xf8800083 (63616.0020)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_299
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_299:
	; BC_CONST [ec]
	ldr r0, [r4, #108*4]			; r0=rConstants[108]=0x9a5616a6 (39510.0885)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_78_continue_300
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_78_continue_300:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_78_end:

proc_79_start:
	; BC_CONST [fe]
	mov r0, #0x001a0000			; r0=rConstants[177] (26.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01070000			; r0=rConstants[181] (263.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_79_continue_301
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_79_continue_301:
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_100_start		; r0=r_Procedures[100]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_79_continue_302
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_79_continue_302:
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001a0000			; r0=rConstants[177] (26.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_79_continue_303
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_79_continue_303:
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_79_end:

proc_80_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #182*4]			; r0=rConstants[182]=0x823f2350 (33343.1379)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #182*4]			; r0=rConstants[182]=0x823f2350 (33343.1379)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #183*4]			; r0=rConstants[183]=0x00810281 (129.0098)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_80_continue_304
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_80_continue_304:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d7]
	ldr r0, [r4, #87*4]			; r0=rConstants[87]=0x823f3f20 (33343.2466)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #184*4]			; r0=rConstants[184]=0xc4444444 (50244.2667)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_80_continue_305
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_80_continue_305:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #185*4]			; r0=rConstants[185]=0x10109010 (4112.5627)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_80_continue_306
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_80_continue_306:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d7]
	ldr r0, [r4, #87*4]			; r0=rConstants[87]=0x823f3f20 (33343.2466)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000001			; r0=rConstants[186] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_80_continue_307
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_80_continue_307:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [df]
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #187*4]			; r0=rConstants[187]=0x040f0f42 (1039.0596)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #188*4]			; r0=rConstants[188]=0xffffffff (65536.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_80_end:

proc_81_start:
	; BC_CONST [84]
	mov r0, #0x002b0000			; r0=rConstants[4] (43.0000)
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00480000			; r0=rConstants[166] (72.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #183*4]			; r0=rConstants[183]=0x00810281 (129.0098)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_102_start		; r0=r_Procedures[102]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00480000			; r0=rConstants[166] (72.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #184*4]			; r0=rConstants[184]=0xc4444444 (50244.2667)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_102_start		; r0=r_Procedures[102]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00480000			; r0=rConstants[166] (72.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #185*4]			; r0=rConstants[185]=0x10109010 (4112.5627)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_102_start		; r0=r_Procedures[102]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_81_end:

proc_82_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_82_target_308
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_82_target_309
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_82_continue_310
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_82_continue_310:
	; BC_ELSE [01]
	b proc_82_target_311
proc_82_target_309:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_82_continue_312
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_82_continue_312:
	; BC_DONE [00]
proc_82_target_311:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [fe]
	mov r0, #0x001f0000			; r0=rConstants[189] (31.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_82_target_313
	; BC_PROC [07]
	adr r0, proc_82_start		; r0=r_Procedures[82]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_82_target_314
proc_82_target_313:
	; BC_PROC [07]
	adr r0, proc_82_start		; r0=r_Procedures[82]
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_82_target_314:
	; BC_ELSE [01]
	b proc_82_target_315
proc_82_target_308:
	; BC_PROC [07]
	adr r0, proc_104_start		; r0=r_Procedures[104]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_82_target_315:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_82_end:

proc_83_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [fe]
	mov r0, #0x00870000			; r0=rConstants[169] (135.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00fa0000			; r0=rConstants[190] (250.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_105_start		; r0=r_Procedures[105]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	mov r0, #0x00420000			; r0=rConstants[191] (66.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_20_start		; r0=r_Procedures[20]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_83_continue_316
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_83_continue_316:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [fe]
	mov r0, #0x00420000			; r0=rConstants[191] (66.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [fe]
	mov r0, #0x00870000			; r0=rConstants[169] (135.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00fa0000			; r0=rConstants[190] (250.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_105_start		; r0=r_Procedures[105]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_83_end:

proc_84_start:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_84_end:

proc_85_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [eb]
	mov r0, #0x00190000			; r0=rConstants[107] (25.0000)
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5e]
	str r0, [r5, #ST_WIRE6*4]		; State[ST_WIRE6]=r0
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_317
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_317:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_318
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_318:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_319
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_319:
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_320
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_320:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_321
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_321:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_322
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_322:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_323
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_323:
	; BC_CONST [db]
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_324
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_324:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_325
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_325:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_326
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_326:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_327
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_327:
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_328
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_328:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_329
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_329:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_330
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_330:
	; BC_CONST [fe]
	ldr r0, [r4, #192*4]			; r0=rConstants[192]=0x18710f46 (6257.0597)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_331
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_331:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_332
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_332:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_333
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_333:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_334
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_334:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_335
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_335:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_336
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_336:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_337
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_337:
	; BC_CONST [df]
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_338
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_338:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_339
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_339:
	; BC_CONST [c0]
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_340
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_340:
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [5e]
	str r0, [r5, #ST_WIRE6*4]		; State[ST_WIRE6]=r0
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_341
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_341:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_342
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_342:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_343
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_343:
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_344
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_344:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_345
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_345:
	; BC_CONST [d7]
	ldr r0, [r4, #87*4]			; r0=rConstants[87]=0x823f3f20 (33343.2466)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_346
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_346:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_347
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_347:
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_348
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_348:
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_349
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_349:
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_350
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_350:
	; BC_CONST [c0]
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_351
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_351:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_352
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_352:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_353
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_353:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_354
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_354:
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_355
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_355:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_356
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_356:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_357
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_357:
	; BC_CONST [fe]
	ldr r0, [r4, #192*4]			; r0=rConstants[192]=0x18710f46 (6257.0597)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_358
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_358:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_359
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_359:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_360
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_360:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_361
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_361:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_362
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_362:
	; BC_CONST [fe]
	ldr r0, [r4, #193*4]			; r0=rConstants[193]=0x881f1f81 (34847.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_363
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_363:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_364
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_364:
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_365
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_365:
	; BC_CONST [e0]
	ldr r0, [r4, #96*4]			; r0=rConstants[96]=0x90400e26 (36928.0553)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_366
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_366:
	; BC_CONST [dc]
	ldr r0, [r4, #92*4]			; r0=rConstants[92]=0xf0000002 (61440.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_367
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_367:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_368
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_368:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_369
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_369:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_370
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_370:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_371
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_371:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_372
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_372:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_373
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_373:
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_374
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_374:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_375
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_375:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_376
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_376:
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_377
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_377:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_378
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_378:
	; BC_CONST [fe]
	ldr r0, [r4, #193*4]			; r0=rConstants[193]=0x881f1f81 (34847.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_379
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_379:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_380
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_380:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_381
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_381:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_382
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_382:
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_383
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_383:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_384
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_384:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_385
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_385:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_386
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_386:
	; BC_CONST [fe]
	ldr r0, [r4, #192*4]			; r0=rConstants[192]=0x18710f46 (6257.0597)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_387
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_387:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_388
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_388:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_389
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_389:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_390
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_390:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_391
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_391:
	; BC_CONST [ee]
	ldr r0, [r4, #110*4]			; r0=rConstants[110]=0x820f08f0 (33295.0349)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_392
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_392:
	; BC_CONST [fe]
	ldr r0, [r4, #194*4]			; r0=rConstants[194]=0x9a7226a6 (39538.1510)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_393
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_393:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_394
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_394:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_395
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_395:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_396
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_396:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_397
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_397:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_398
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_398:
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_399
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_399:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_400
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_400:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_401
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_401:
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_402
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_402:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_403
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_403:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_404
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_404:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_405
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_405:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_406
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_406:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_407
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_407:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_408
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_408:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_409
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_409:
	; BC_CONST [fe]
	ldr r0, [r4, #193*4]			; r0=rConstants[193]=0x881f1f81 (34847.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_410
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_410:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_411
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_411:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_412
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_412:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_413
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_413:
	; BC_CONST [fe]
	ldr r0, [r4, #192*4]			; r0=rConstants[192]=0x18710f46 (6257.0597)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_414
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_414:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_415
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_415:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_416
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_416:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_417
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_417:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_418
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_418:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_419
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_419:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_420
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_420:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_421
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_421:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_422
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_422:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_423
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_423:
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_424
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_424:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_425
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_425:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_426
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_426:
	; BC_CONST [db]
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_427
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_427:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_428
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_428:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_429
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_429:
	; BC_CONST [fe]
	ldr r0, [r4, #195*4]			; r0=rConstants[195]=0x00202002 (32.1250)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_430
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_430:
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_431
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_431:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_432
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_432:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_433
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_433:
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_434
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_434:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_435
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_435:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_436
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_436:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_437
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_437:
	; BC_CONST [fe]
	ldr r0, [r4, #187*4]			; r0=rConstants[187]=0x040f0f42 (1039.0596)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_438
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_438:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_439
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_439:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_440
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_440:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_441
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_441:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_442
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_442:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_443
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_443:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_444
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_444:
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_445
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_445:
	; BC_CONST [fe]
	ldr r0, [r4, #192*4]			; r0=rConstants[192]=0x18710f46 (6257.0597)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_446
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_446:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_447
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_447:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_448
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_448:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_449
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_449:
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_450
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_450:
	; BC_CONST [de]
	ldr r0, [r4, #94*4]			; r0=rConstants[94]=0x82071fa2 (33287.1236)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_451
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_451:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_452
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_452:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_453
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_453:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_454
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_454:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_455
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_455:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_456
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_456:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_457
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_457:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_458
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_458:
	; BC_CONST [fe]
	ldr r0, [r4, #182*4]			; r0=rConstants[182]=0x823f2350 (33343.1379)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_459
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_459:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_460
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_460:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_461
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_461:
	; BC_CONST [fe]
	ldr r0, [r4, #195*4]			; r0=rConstants[195]=0x00202002 (32.1250)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_WAIT [0a]
	adr r1, proc_85_continue_462
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_462:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_85_end:

proc_86_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_86_target_463
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_CONST [cb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_86_continue_464
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_86_continue_464:
	; BC_CONST [fe]
	mov r0, #0x001a0000			; r0=rConstants[177] (26.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_86_start		; r0=r_Procedures[86]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_86_target_463:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_86_end:

proc_87_start:
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_87_end:

proc_88_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_88_target_465
	; BC_CONST [b3]
	mov r0, #0x00c00000			; r0=rConstants[51] (192.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [fe]
	mov r0, #0x00150000			; r0=rConstants[172] (21.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_88_continue_466
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_88_continue_466:
	; BC_PROC [07]
	adr r0, proc_88_start		; r0=r_Procedures[88]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_88_target_465:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_88_end:

proc_89_start:
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x008f0000			; r0=rConstants[196] (143.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_89_target_467
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_89_continue_468
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_89_continue_468:
	; BC_DONE [00]
proc_89_target_467:
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_100_start		; r0=r_Procedures[100]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_89_target_469
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_89_continue_470
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_89_continue_470:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_89_continue_471
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_89_continue_471:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_89_continue_472
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_89_continue_472:
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_89_continue_473
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_89_continue_473:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_89_continue_474
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_89_continue_474:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_89_continue_475
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_89_continue_475:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_89_target_469:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_89_end:

proc_90_start:
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000025			; r0=rConstants[197] (0.0006)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #198*4]			; r0=rConstants[198]=0x55656235 (21861.3836)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #199*4]			; r0=rConstants[199]=0x65446665 (25924.4000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #200*4]			; r0=rConstants[200]=0x64334444 (25651.2667)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #201*4]			; r0=rConstants[201]=0x33466634 (13126.3992)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #202*4]			; r0=rConstants[202]=0x66424385 (26178.2637)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #203*4]			; r0=rConstants[203]=0x54466548 (21574.3956)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #204*4]			; r0=rConstants[204]=0x9668aa63 (38504.6656)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #205*4]			; r0=rConstants[205]=0x36898987 (13961.5372)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #206*4]			; r0=rConstants[206]=0x879dfbaa (34717.9831)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #207*4]			; r0=rConstants[207]=0x878bceeb (34699.8083)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #208*4]			; r0=rConstants[208]=0x7889c9bf (30857.7881)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [2e]
	mov r1, #14
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [fe]
	ldr r0, [r4, #209*4]			; r0=rConstants[209]=0x00021999 (2.1000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_90_continue_476
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_90_continue_476:
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #210*4]			; r0=rConstants[210]=0xeac88dca (60104.5539)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #211*4]			; r0=rConstants[211]=0xced8bbba (52952.7333)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #212*4]			; r0=rConstants[212]=0x99daaffd (39386.6875)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #213*4]			; r0=rConstants[213]=0x866568df (34405.4097)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #188*4]			; r0=rConstants[188]=0xffffffff (65536.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #214*4]			; r0=rConstants[214]=0xffffeefe (65535.9336)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #215*4]			; r0=rConstants[215]=0xeeebffdb (61163.9994)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #216*4]			; r0=rConstants[216]=0xceffddee (52991.8669)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #217*4]			; r0=rConstants[217]=0xcdddddbc (52701.8661)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #218*4]			; r0=rConstants[218]=0xc9ddcddd (51677.8042)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #219*4]			; r0=rConstants[219]=0xdcbdbedc (56509.7455)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #220*4]			; r0=rConstants[220]=0xa8338cc1 (43059.5498)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [2e]
	mov r1, #14
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [fe]
	ldr r0, [r4, #209*4]			; r0=rConstants[209]=0x00021999 (2.1000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_90_continue_477
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_90_continue_477:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_89_start		; r0=r_Procedures[89]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_90_end:

proc_91_start:
	; BC_CONST [fe]
	mov r0, #0x00610000			; r0=rConstants[221] (97.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	mov r0, #0x008a0000			; r0=rConstants[222] (138.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_478
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_478:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_479
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_479:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_480
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_480:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_481
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_481:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_482
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_482:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_483
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_483:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_484
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_484:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_485
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_485:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_486
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_486:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_487
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_487:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_488
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_488:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_489
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_489:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_490
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_490:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_491
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_491:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_492
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_492:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_493
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_493:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_494
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_494:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_495
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_495:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_496
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_496:
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_497
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_497:
	; BC_CONST [dc]
	ldr r0, [r4, #92*4]			; r0=rConstants[92]=0xf0000002 (61440.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_91_end:

proc_92_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1e]
	bgt proc_92_target_498
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_92_continue_499
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_92_continue_499:
	; BC_PROC [07]
	adr r0, proc_92_start		; r0=r_Procedures[92]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_92_target_498:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_92_end:

proc_93_start:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_95_start		; r0=r_Procedures[95]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_93_continue_500
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_93_continue_500:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_95_start		; r0=r_Procedures[95]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_93_end:

proc_94_start:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_110_start		; r0=r_Procedures[110]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_95_start		; r0=r_Procedures[95]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_94_end:

proc_95_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_501
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_501:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_502
	; BC_CONST [d5]
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_502:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_503
	; BC_CONST [da]
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_CONST [d3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [de]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #94*4]			; r0=rConstants[94]=0x82071fa2 (33287.1236)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [d8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_503:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_504
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #182*4]			; r0=rConstants[182]=0x823f2350 (33343.1379)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_504:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_505
	; BC_CONST [d7]
	ldr r0, [r4, #87*4]			; r0=rConstants[87]=0x823f3f20 (33343.2466)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [d8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_505:
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_506
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #182*4]			; r0=rConstants[182]=0x823f2350 (33343.1379)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_506:
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_507
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #187*4]			; r0=rConstants[187]=0x040f0f42 (1039.0596)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_507:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_508
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_508:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_509
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_509:
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_95_target_510
	; BC_CONST [db]
	ldr r0, [r4, #91*4]			; r0=rConstants[91]=0x187f3c8a (6271.2365)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_95_target_510:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_95_end:

proc_96_start:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_96_continue_511
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_96_continue_511:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_WAIT [0a]
	adr r1, proc_96_continue_512
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_96_continue_512:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_96_end:

proc_97_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [ca]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [c6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001c0000			; r0=rConstants[223] (28.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_33_start		; r0=r_Procedures[33]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_97_end:

proc_98_start:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_98_continue_513
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_98_continue_513:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WAIT [0a]
	adr r1, proc_98_continue_514
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_98_continue_514:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [85]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RSTATE [7e]
	ldr r0, [r5, #ST_WIRE6*4]		; r0=State[ST_WIRE6]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PROC [07]
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_98_end:

proc_99_start:
	; BC_RSTATE [7e]
	ldr r0, [r5, #ST_WIRE6*4]		; r0=State[ST_WIRE6]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_99_end:

proc_100_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [b1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_100_end:

proc_101_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RLOCAL [66]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_101_continue_515
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_101_continue_515:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00370000			; r0=rConstants[224] (55.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_111_start		; r0=r_Procedures[111]
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_RLOCAL [67]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_101_end:

proc_102_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_102_target_516
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_102_target_517
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_102_target_518
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_112_start		; r0=r_Procedures[112]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_102_target_519
proc_102_target_518:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_112_start		; r0=r_Procedures[112]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_102_target_519:
	; BC_DONE [00]
proc_102_target_517:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_102_target_520
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_102_continue_521
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_102_continue_521:
	; BC_ELSE [01]
	b proc_102_target_522
proc_102_target_520:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_102_continue_523
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_102_continue_523:
	; BC_DONE [00]
proc_102_target_522:
	; BC_CONST [fe]
	mov r0, #0x001f0000			; r0=rConstants[189] (31.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_102_target_524
	; BC_PROC [07]
	adr r0, proc_102_start		; r0=r_Procedures[102]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_102_target_525
proc_102_target_524:
	; BC_PROC [07]
	adr r0, proc_102_start		; r0=r_Procedures[102]
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_102_target_525:
	; BC_DONE [00]
proc_102_target_516:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_102_end:

proc_103_start:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003b0000			; r0=rConstants[225] (59.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_103_end:

proc_104_start:
	; BC_CONST [fe]
	mov r0, #0x001a0000			; r0=rConstants[177] (26.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01070000			; r0=rConstants[181] (263.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_104_end:

proc_105_start:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #193*4]			; r0=rConstants[193]=0x881f1f81 (34847.1231)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #187*4]			; r0=rConstants[187]=0x040f0f42 (1039.0596)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [d5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #85*4]			; r0=rConstants[85]=0x40bf3f08 (16575.2462)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_CONST [c0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_105_end:

proc_106_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_106_target_526
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_106_target_526:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_106_end:

proc_107_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_107_target_527
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WAIT [0a]
	adr r1, proc_107_continue_528
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_107_continue_528:
	; BC_PROC [07]
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_107_target_527:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_107_end:

proc_108_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_108_target_529
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_108_target_529:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_108_end:

proc_109_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_109_target_530
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x00018000			; r0=rConstants[41] (1.5000)
	; BC_CONST [c6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [6e]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-15*4]			; r0=StateStack[-15]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_113_start		; r0=r_Procedures[113]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [fe]
	ldr r0, [r4, #209*4]			; r0=rConstants[209]=0x00021999 (2.1000)
	; BC_WAIT [0a]
	adr r1, proc_109_continue_531
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_109_continue_531:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_109_target_532
	; BC_PROC [07]
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [b1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WLOCAL [4d]
	str r0, [r5, #-14*4]			; StateStack[-14]=r0
	; BC_WLOCAL [42]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_109_target_533
proc_109_target_532:
	; BC_PROC [07]
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RLOCAL [66]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_RLOCAL [67]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_RLOCAL [68]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-9*4]			; r0=StateStack[-9]
	; BC_RLOCAL [69]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-10*4]			; r0=StateStack[-10]
	; BC_RLOCAL [6a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-11*4]			; r0=StateStack[-11]
	; BC_RLOCAL [6b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-12*4]			; r0=StateStack[-12]
	; BC_RLOCAL [6c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-13*4]			; r0=StateStack[-13]
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WLOCAL [4d]
	str r0, [r5, #-14*4]			; StateStack[-14]=r0
	; BC_WLOCAL [4c]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-13*4]			; StateStack[-13]=r0
	; BC_WLOCAL [4b]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-12*4]			; StateStack[-12]=r0
	; BC_WLOCAL [4a]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-11*4]			; StateStack[-11]=r0
	; BC_WLOCAL [49]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-10*4]			; StateStack[-10]=r0
	; BC_WLOCAL [48]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-9*4]			; StateStack[-9]=r0
	; BC_WLOCAL [47]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-8*4]			; StateStack[-8]=r0
	; BC_WLOCAL [46]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-7*4]			; StateStack[-7]=r0
	; BC_WLOCAL [45]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-6*4]			; StateStack[-6]=r0
	; BC_WLOCAL [44]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-5*4]			; StateStack[-5]=r0
	; BC_WLOCAL [43]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_WLOCAL [42]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_109_target_533:
	; BC_DONE [00]
proc_109_target_530:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_109_end:

proc_110_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_110_end:

proc_111_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_111_target_534
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_111_target_535
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_111_target_535:
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_111_continue_536
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_111_continue_536:
	; BC_PROC [07]
	adr r0, proc_111_start		; r0=r_Procedures[111]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_111_target_534:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_111_end:

proc_112_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_112_continue_537
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_112_continue_537:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_114_start		; r0=r_Procedures[114]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_112_end:

proc_113_start:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_115_start		; r0=r_Procedures[115]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_113_continue_538
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_113_continue_538:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_115_start		; r0=r_Procedures[115]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_115_start		; r0=r_Procedures[115]
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[46] (0.5000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_113_end:

proc_114_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_114_target_539
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_114_continue_540
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_114_continue_540:
	; BC_PROC [07]
	adr r0, proc_114_start		; r0=r_Procedures[114]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_114_target_539:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_114_end:

proc_115_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_115_end:

proc_116_start:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_116_continue_541
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_116_continue_541:
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_116_continue_542
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_116_continue_542:
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a2]
	mov r0, #0x001e0000			; r0=rConstants[34] (30.0000)
	; BC_WAIT [0a]
	adr r1, proc_116_continue_543
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_116_continue_543:
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [fe]
	mov r0, #0x00550000			; r0=rConstants[226] (85.0000)
	; BC_WAIT [0a]
	adr r1, proc_116_continue_544
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_116_continue_544:
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_116_end:

proc_117_start:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_545
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_545:
	; BC_CONST [fe]
	mov r0, #0x004b0000			; r0=rConstants[227] (75.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [86]
	mov r0, #0x00300000			; r0=rConstants[6] (48.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_546
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_546:
	; BC_CONST [d2]
	mov r0, #0x00650000			; r0=rConstants[82] (101.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_547
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_547:
	; BC_CONST [fe]
	mov r0, #0x00470000			; r0=rConstants[228] (71.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00330000			; r0=rConstants[229] (51.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_548
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_548:
	; BC_CONST [fe]
	mov r0, #0x004d0000			; r0=rConstants[230] (77.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_549
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_549:
	; BC_CONST [fe]
	mov r0, #0x003a0000			; r0=rConstants[231] (58.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_550
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_550:
	; BC_CONST [a8]
	mov r0, #0x00600000			; r0=rConstants[40] (96.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_551
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_551:
	; BC_CONST [fe]
	mov r0, #0x00350000			; r0=rConstants[232] (53.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x005d0000			; r0=rConstants[168] (93.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_552
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_552:
	; BC_CONST [fe]
	mov r0, #0x007a0000			; r0=rConstants[233] (122.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_553
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_553:
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x005e0000			; r0=rConstants[234] (94.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_554
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_554:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_555
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_555:
	; BC_CONST [fe]
	mov r0, #0x00340000			; r0=rConstants[235] (52.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00450000			; r0=rConstants[236] (69.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_556
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_556:
	; BC_CONST [a1]
	mov r0, #0x00960000			; r0=rConstants[33] (150.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_557
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_557:
	; BC_CONST [fe]
	mov r0, #0x002f0000			; r0=rConstants[237] (47.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00420000			; r0=rConstants[191] (66.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_558
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_558:
	; BC_CONST [fe]
	mov r0, #0x00c50000			; r0=rConstants[238] (197.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_559
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_559:
	; BC_CONST [86]
	mov r0, #0x00300000			; r0=rConstants[6] (48.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003b0000			; r0=rConstants[225] (59.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_560
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_560:
	; BC_CONST [a6]
	mov r0, #0x00e00000			; r0=rConstants[38] (224.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_561
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_561:
	; BC_CONST [fe]
	mov r0, #0x003a0000			; r0=rConstants[231] (58.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00310000			; r0=rConstants[239] (49.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_562
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_562:
	; BC_CONST [fe]
	mov r0, #0x00f70000			; r0=rConstants[240] (247.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [fe]
	mov r0, #0x001a0000			; r0=rConstants[177] (26.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_563
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_563:
	; BC_CONST [99]
	mov r0, #0x00530000			; r0=rConstants[25] (83.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x002c0000			; r0=rConstants[241] (44.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_564
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_564:
	; BC_CONST [fe]
	mov r0, #0x00150000			; r0=rConstants[172] (21.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_565
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_565:
	; BC_CONST [ba]
	mov r0, #0x005f0000			; r0=rConstants[58] (95.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00330000			; r0=rConstants[229] (51.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_566
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_566:
	; BC_CONST [fe]
	mov r0, #0x00490000			; r0=rConstants[242] (73.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ce]
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_567
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_567:
	; BC_CONST [fe]
	mov r0, #0x005c0000			; r0=rConstants[243] (92.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003f0000			; r0=rConstants[244] (63.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_568
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_568:
	; BC_CONST [fe]
	mov r0, #0x00680000			; r0=rConstants[245] (104.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_569
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_569:
	; BC_CONST [fe]
	mov r0, #0x00510000			; r0=rConstants[246] (81.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ac]
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_570
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_570:
	; BC_CONST [fe]
	mov r0, #0x00710000			; r0=rConstants[247] (113.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_571
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_571:
	; BC_CONST [fe]
	mov r0, #0x00440000			; r0=rConstants[248] (68.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004b0000			; r0=rConstants[227] (75.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_572
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_572:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_573
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_573:
	; BC_CONST [fe]
	mov r0, #0x006a0000			; r0=rConstants[249] (106.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003b0000			; r0=rConstants[225] (59.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_574
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_574:
	; BC_CONST [d1]
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_575
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_575:
	; BC_CONST [fe]
	mov r0, #0x00610000			; r0=rConstants[221] (97.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003f0000			; r0=rConstants[244] (63.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_576
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_576:
	; BC_CONST [b5]
	mov r0, #0x00500000			; r0=rConstants[53] (80.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ce]
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_577
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_577:
	; BC_CONST [fe]
	mov r0, #0x005c0000			; r0=rConstants[243] (92.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004b0000			; r0=rConstants[227] (75.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_578
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_578:
	; BC_CONST [bb]
	mov r0, #0x00390000			; r0=rConstants[59] (57.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_579
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_579:
	; BC_CONST [fe]
	mov r0, #0x005d0000			; r0=rConstants[168] (93.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00510000			; r0=rConstants[246] (81.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_580
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_580:
	; BC_CONST [fe]
	mov r0, #0x00e80000			; r0=rConstants[250] (232.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_581
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_581:
	; BC_CONST [fe]
	mov r0, #0x00630000			; r0=rConstants[251] (99.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004d0000			; r0=rConstants[230] (77.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_582
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_582:
	; BC_CONST [fe]
	mov r0, #0x00d90000			; r0=rConstants[252] (217.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_583
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_583:
	; BC_CONST [fe]
	mov r0, #0x006b0000			; r0=rConstants[253] (107.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00420000			; r0=rConstants[191] (66.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_584
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_584:
	; BC_CONST [fe]
	mov r0, #0x00ba0000			; r0=rConstants[254] (186.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_585
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_585:
	; BC_CONST [fe]
	mov r0, #0x006a0000			; r0=rConstants[249] (106.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003b0000			; r0=rConstants[225] (59.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_586
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_586:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_587
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_587:
	; BC_CONST [d1]
	mov r0, #0x006e0000			; r0=rConstants[81] (110.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00430000			; r0=rConstants[255] (67.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_588
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_588:
	; BC_CONST [fe]
	mov r0, #0x00f50000			; r0=rConstants[256] (245.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_589
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_589:
	; BC_CONST [fe]
	mov r0, #0x00790000			; r0=rConstants[257] (121.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_590
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_590:
	; BC_CONST [fe]
	mov r0, #0x00cf0000			; r0=rConstants[258] (207.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_591
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_591:
	; BC_CONST [fe]
	mov r0, #0x007b0000			; r0=rConstants[259] (123.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003b0000			; r0=rConstants[225] (59.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_592
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_592:
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_593
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_593:
	; BC_CONST [ad]
	mov r0, #0x00780000			; r0=rConstants[45] (120.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [89]
	mov r0, #0x00380000			; r0=rConstants[9] (56.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_594
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_594:
	; BC_CONST [fe]
	mov r0, #0x00680000			; r0=rConstants[245] (104.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_595
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_595:
	; BC_CONST [fe]
	mov r0, #0x00720000			; r0=rConstants[260] (114.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ef]
	mov r0, #0x003c0000			; r0=rConstants[111] (60.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_596
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_596:
	; BC_CONST [b5]
	mov r0, #0x00500000			; r0=rConstants[53] (80.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b0]
	mov r0, #0x00100000			; r0=rConstants[48] (16.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_597
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_597:
	; BC_CONST [fe]
	mov r0, #0x006c0000			; r0=rConstants[261] (108.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004a0000			; r0=rConstants[262] (74.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_598
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_598:
	; BC_CONST [fe]
	mov r0, #0x001a0000			; r0=rConstants[177] (26.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_599
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_599:
	; BC_CONST [fe]
	mov r0, #0x00700000			; r0=rConstants[263] (112.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004d0000			; r0=rConstants[230] (77.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_600
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_600:
	; BC_CONST [fe]
	mov r0, #0x00f10000			; r0=rConstants[264] (241.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_601
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_601:
	; BC_CONST [ad]
	mov r0, #0x00780000			; r0=rConstants[45] (120.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004a0000			; r0=rConstants[262] (74.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_602
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_602:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_603
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_603:
	; BC_CONST [fe]
	mov r0, #0x00820000			; r0=rConstants[265] (130.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00370000			; r0=rConstants[224] (55.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_604
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_604:
	; BC_CONST [fe]
	mov r0, #0x004b0000			; r0=rConstants[227] (75.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [fe]
	mov r0, #0x00150000			; r0=rConstants[172] (21.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_605
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_605:
	; BC_CONST [fe]
	mov r0, #0x007c0000			; r0=rConstants[266] (124.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004b0000			; r0=rConstants[227] (75.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_606
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_606:
	; BC_CONST [fe]
	mov r0, #0x00d10000			; r0=rConstants[267] (209.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_607
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_607:
	; BC_CONST [fe]
	mov r0, #0x00830000			; r0=rConstants[268] (131.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ef]
	mov r0, #0x003c0000			; r0=rConstants[111] (60.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_608
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_608:
	; BC_CONST [fe]
	mov r0, #0x00e50000			; r0=rConstants[269] (229.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_609
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_609:
	; BC_CONST [fe]
	mov r0, #0x008b0000			; r0=rConstants[270] (139.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00360000			; r0=rConstants[271] (54.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_610
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_610:
	; BC_CONST [fe]
	mov r0, #0x004d0000			; r0=rConstants[230] (77.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [cb]
	mov r0, #0x00130000			; r0=rConstants[75] (19.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_611
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_611:
	; BC_CONST [fe]
	mov r0, #0x00850000			; r0=rConstants[272] (133.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00480000			; r0=rConstants[166] (72.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_612
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_612:
	; BC_CONST [fe]
	mov r0, #0x00d20000			; r0=rConstants[273] (210.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_613
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_613:
	; BC_CONST [fe]
	mov r0, #0x008a0000			; r0=rConstants[222] (138.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [8e]
	mov r0, #0x003e0000			; r0=rConstants[14] (62.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_614
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_614:
	; BC_CONST [fe]
	mov r0, #0x00e20000			; r0=rConstants[274] (226.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c5]
	mov r0, #0x000e0000			; r0=rConstants[69] (14.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_615
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_615:
	; BC_CONST [fe]
	mov r0, #0x00940000			; r0=rConstants[275] (148.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00350000			; r0=rConstants[232] (53.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_616
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_616:
	; BC_CONST [fe]
	mov r0, #0x00480000			; r0=rConstants[166] (72.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c9]
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_617
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_617:
	; BC_CONST [fe]
	mov r0, #0x00920000			; r0=rConstants[276] (146.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003f0000			; r0=rConstants[244] (63.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_618
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_618:
	; BC_CONST [fe]
	mov r0, #0x004e0000			; r0=rConstants[277] (78.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_619
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_619:
	; BC_CONST [fe]
	mov r0, #0x008f0000			; r0=rConstants[196] (143.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00470000			; r0=rConstants[228] (71.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_620
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_620:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_621
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_621:
	; BC_CONST [fe]
	mov r0, #0x00940000			; r0=rConstants[275] (148.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00470000			; r0=rConstants[228] (71.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_622
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_622:
	; BC_CONST [fe]
	mov r0, #0x00d20000			; r0=rConstants[273] (210.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_623
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_623:
	; BC_CONST [fe]
	mov r0, #0x00970000			; r0=rConstants[278] (151.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b7]
	mov r0, #0x00410000			; r0=rConstants[55] (65.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_624
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_624:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_625
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_625:
	; BC_CONST [98]
	mov r0, #0x00b00000			; r0=rConstants[24] (176.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00260000			; r0=rConstants[279] (38.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_626
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_626:
	; BC_CONST [fe]
	mov r0, #0x00510000			; r0=rConstants[246] (81.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [fe]
	mov r0, #0x001d0000			; r0=rConstants[179] (29.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_627
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_627:
	; BC_CONST [fe]
	mov r0, #0x00a40000			; r0=rConstants[280] (164.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_628
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_628:
	; BC_CONST [fe]
	mov r0, #0x00360000			; r0=rConstants[271] (54.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_629
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_629:
	; BC_CONST [e4]
	mov r0, #0x00a50000			; r0=rConstants[100] (165.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00440000			; r0=rConstants[248] (68.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_630
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_630:
	; BC_CONST [fe]
	mov r0, #0x00e80000			; r0=rConstants[250] (232.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_631
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_631:
	; BC_CONST [fe]
	mov r0, #0x00ab0000			; r0=rConstants[281] (171.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_632
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_632:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_633
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_633:
	; BC_CONST [e7]
	mov r0, #0x00a60000			; r0=rConstants[103] (166.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a5]
	mov r0, #0x00320000			; r0=rConstants[37] (50.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_634
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_634:
	; BC_CONST [fe]
	mov r0, #0x00f80000			; r0=rConstants[282] (248.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_635
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_635:
	; BC_CONST [fe]
	mov r0, #0x00b10000			; r0=rConstants[283] (177.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [86]
	mov r0, #0x00300000			; r0=rConstants[6] (48.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_636
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_636:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_637
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_637:
	; BC_CONST [fe]
	mov r0, #0x00bc0000			; r0=rConstants[284] (188.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_638
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_638:
	; BC_CONST [fe]
	mov r0, #0x00710000			; r0=rConstants[247] (113.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_639
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_639:
	; BC_CONST [fe]
	mov r0, #0x00b40000			; r0=rConstants[285] (180.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00310000			; r0=rConstants[239] (49.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_640
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_640:
	; BC_CONST [fe]
	mov r0, #0x00590000			; r0=rConstants[286] (89.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_641
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_641:
	; BC_CONST [fe]
	mov r0, #0x00af0000			; r0=rConstants[287] (175.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [89]
	mov r0, #0x00380000			; r0=rConstants[9] (56.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_642
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_642:
	; BC_CONST [80]
	mov r0, #0x00400000			; r0=rConstants[0] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c9]
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_643
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_643:
	; BC_CONST [fe]
	mov r0, #0x00af0000			; r0=rConstants[287] (175.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00430000			; r0=rConstants[255] (67.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_644
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_644:
	; BC_CONST [fe]
	mov r0, #0x00f90000			; r0=rConstants[288] (249.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_645
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_645:
	; BC_CONST [fe]
	mov r0, #0x00b50000			; r0=rConstants[289] (181.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00420000			; r0=rConstants[191] (66.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_646
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_646:
	; BC_CONST [fe]
	mov r0, #0x00d70000			; r0=rConstants[290] (215.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c9]
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_647
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_647:
	; BC_CONST [95]
	mov r0, #0x00bb0000			; r0=rConstants[21] (187.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [bb]
	mov r0, #0x00390000			; r0=rConstants[59] (57.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_648
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_648:
	; BC_CONST [fe]
	mov r0, #0x00c30000			; r0=rConstants[291] (195.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_649
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_649:
	; BC_CONST [fe]
	mov r0, #0x00bc0000			; r0=rConstants[284] (188.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_650
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_650:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_651
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_651:
	; BC_CONST [fe]
	mov r0, #0x00d80000			; r0=rConstants[292] (216.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [84]
	mov r0, #0x002b0000			; r0=rConstants[4] (43.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_652
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_652:
	; BC_CONST [fe]
	mov r0, #0x00890000			; r0=rConstants[293] (137.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_653
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_653:
	; BC_CONST [fe]
	mov r0, #0x00d40000			; r0=rConstants[294] (212.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [87]
	mov r0, #0x002a0000			; r0=rConstants[7] (42.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_654
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_654:
	; BC_CONST [fe]
	mov r0, #0x00680000			; r0=rConstants[245] (104.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_655
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_655:
	; BC_CONST [fe]
	mov r0, #0x00ce0000			; r0=rConstants[295] (206.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [cd]
	mov r0, #0x002e0000			; r0=rConstants[77] (46.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_656
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_656:
	; BC_CONST [96]
	mov r0, #0x00520000			; r0=rConstants[22] (82.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_657
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_657:
	; BC_CONST [fe]
	mov r0, #0x00c90000			; r0=rConstants[296] (201.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [89]
	mov r0, #0x00380000			; r0=rConstants[9] (56.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_658
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_658:
	; BC_CONST [bb]
	mov r0, #0x00390000			; r0=rConstants[59] (57.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_659
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_659:
	; BC_CONST [fe]
	mov r0, #0x00ca0000			; r0=rConstants[297] (202.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [8e]
	mov r0, #0x003e0000			; r0=rConstants[14] (62.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_660
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_660:
	; BC_CONST [fe]
	mov r0, #0x00ed0000			; r0=rConstants[298] (237.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_661
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_661:
	; BC_CONST [fe]
	mov r0, #0x00ce0000			; r0=rConstants[295] (206.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ef]
	mov r0, #0x003c0000			; r0=rConstants[111] (60.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_662
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_662:
	; BC_CONST [fe]
	mov r0, #0x00d70000			; r0=rConstants[290] (215.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b8]
	mov r0, #0x00180000			; r0=rConstants[56] (24.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_663
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_663:
	; BC_CONST [fe]
	mov r0, #0x00db0000			; r0=rConstants[299] (219.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_664
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_664:
	; BC_CONST [fe]
	mov r0, #0x004f0000			; r0=rConstants[300] (79.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [d0]
	mov r0, #0x00110000			; r0=rConstants[80] (17.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_665
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_665:
	; BC_CONST [fe]
	mov r0, #0x00d50000			; r0=rConstants[301] (213.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00370000			; r0=rConstants[224] (55.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_666
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_666:
	; BC_CONST [ac]
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_667
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_667:
	; BC_CONST [fe]
	mov r0, #0x00d40000			; r0=rConstants[294] (212.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003d0000			; r0=rConstants[302] (61.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_668
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_668:
	; BC_CONST [fe]
	mov r0, #0x00f20000			; r0=rConstants[303] (242.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_669
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_669:
	; BC_CONST [fe]
	mov r0, #0x00da0000			; r0=rConstants[304] (218.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x003b0000			; r0=rConstants[225] (59.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_670
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_670:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_671
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_671:
	; BC_CONST [fe]
	mov r0, #0x00ae0000			; r0=rConstants[305] (174.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x005e0000			; r0=rConstants[234] (94.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_672
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_672:
	; BC_CONST [fe]
	mov r0, #0x00790000			; r0=rConstants[257] (121.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_673
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_673:
	; BC_CONST [fe]
	mov r0, #0x00a80000			; r0=rConstants[173] (168.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ba]
	mov r0, #0x005f0000			; r0=rConstants[58] (95.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_674
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_674:
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_675
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_675:
	; BC_CONST [fe]
	mov r0, #0x00a30000			; r0=rConstants[306] (163.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_676
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_676:
	; BC_CONST [fe]
	mov r0, #0x00d00000			; r0=rConstants[307] (208.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ce]
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_677
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_677:
	; BC_CONST [fe]
	mov r0, #0x00a80000			; r0=rConstants[173] (168.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004e0000			; r0=rConstants[277] (78.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_678
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_678:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [fe]
	mov r0, #0x00210000			; r0=rConstants[174] (33.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_679
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_679:
	; BC_CONST [fe]
	mov r0, #0x00c90000			; r0=rConstants[296] (201.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004e0000			; r0=rConstants[277] (78.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_680
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_680:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_681
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_681:
	; BC_CONST [fe]
	mov r0, #0x00c60000			; r0=rConstants[308] (198.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x004a0000			; r0=rConstants[262] (74.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_682
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_682:
	; BC_CONST [fe]
	mov r0, #0x00510000			; r0=rConstants[246] (81.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [fe]
	mov r0, #0x002c0000			; r0=rConstants[241] (44.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_683
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_683:
	; BC_CONST [fe]
	mov r0, #0x00b40000			; r0=rConstants[285] (180.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00720000			; r0=rConstants[260] (114.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_684
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_684:
	; BC_CONST [fe]
	mov r0, #0x00630000			; r0=rConstants[251] (99.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_685
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_685:
	; BC_CONST [fe]
	mov r0, #0x00ae0000			; r0=rConstants[305] (174.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00770000			; r0=rConstants[309] (119.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_686
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_686:
	; BC_CONST [fe]
	mov r0, #0x00680000			; r0=rConstants[245] (104.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_687
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_687:
	; BC_CONST [fe]
	mov r0, #0x00a80000			; r0=rConstants[173] (168.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x007b0000			; r0=rConstants[259] (123.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_688
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_688:
	; BC_CONST [fe]
	mov r0, #0x008b0000			; r0=rConstants[270] (139.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_689
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_689:
	; BC_CONST [fe]
	mov r0, #0x00a10000			; r0=rConstants[310] (161.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00790000			; r0=rConstants[257] (121.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_690
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_690:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_691
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_691:
	; BC_CONST [fe]
	mov r0, #0x00b40000			; r0=rConstants[285] (180.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [d2]
	mov r0, #0x00650000			; r0=rConstants[82] (101.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_692
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_692:
	; BC_CONST [fe]
	mov r0, #0x00f90000			; r0=rConstants[288] (249.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b9]
	mov r0, #0x00240000			; r0=rConstants[57] (36.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_693
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_693:
	; BC_CONST [fe]
	mov r0, #0x00d70000			; r0=rConstants[290] (215.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ba]
	mov r0, #0x005f0000			; r0=rConstants[58] (95.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_694
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_694:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_695
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_695:
	; BC_CONST [fe]
	mov r0, #0x00e10000			; r0=rConstants[311] (225.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00440000			; r0=rConstants[248] (68.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_696
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_696:
	; BC_CONST [fe]
	mov r0, #0x00740000			; r0=rConstants[312] (116.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_697
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_697:
	; BC_CONST [fe]
	mov r0, #0x00da0000			; r0=rConstants[304] (218.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ac]
	mov r0, #0x00460000			; r0=rConstants[44] (70.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_698
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_698:
	; BC_CONST [fe]
	mov r0, #0x00540000			; r0=rConstants[313] (84.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ce]
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_699
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_699:
	; BC_CONST [fe]
	mov r0, #0x00d40000			; r0=rConstants[294] (212.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00510000			; r0=rConstants[246] (81.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_700
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_700:
	; BC_CONST [fe]
	mov r0, #0x004b0000			; r0=rConstants[227] (75.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [82]
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_701
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_701:
	; BC_CONST [fe]
	mov r0, #0x00cb0000			; r0=rConstants[314] (203.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x006f0000			; r0=rConstants[315] (111.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_702
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_702:
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_703
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_703:
	; BC_CONST [fe]
	mov r0, #0x00cd0000			; r0=rConstants[316] (205.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00720000			; r0=rConstants[260] (114.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_704
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_704:
	; BC_CONST [fe]
	mov r0, #0x00dc0000			; r0=rConstants[317] (220.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_705
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_705:
	; BC_CONST [fe]
	mov r0, #0x00d20000			; r0=rConstants[273] (210.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x006c0000			; r0=rConstants[261] (108.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_706
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_706:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_707
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_707:
	; BC_CONST [fe]
	mov r0, #0x00e40000			; r0=rConstants[318] (228.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_708
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_708:
	; BC_CONST [fe]
	mov r0, #0x007a0000			; r0=rConstants[233] (122.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_709
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_709:
	; BC_CONST [fe]
	mov r0, #0x00dd0000			; r0=rConstants[319] (221.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x005b0000			; r0=rConstants[320] (91.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_710
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_710:
	; BC_CONST [96]
	mov r0, #0x00520000			; r0=rConstants[22] (82.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x00090000			; r0=rConstants[72] (9.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_711
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_711:
	; BC_CONST [fe]
	mov r0, #0x00d90000			; r0=rConstants[252] (217.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00630000			; r0=rConstants[251] (99.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_712
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_712:
	; BC_CONST [fe]
	mov r0, #0x00440000			; r0=rConstants[248] (68.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c9]
	mov r0, #0x000b0000			; r0=rConstants[73] (11.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_713
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_713:
	; BC_CONST [fe]
	mov r0, #0x00d80000			; r0=rConstants[292] (216.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x006d0000			; r0=rConstants[321] (109.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_714
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_714:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_715
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_715:
	; BC_CONST [fe]
	mov r0, #0x00dc0000			; r0=rConstants[317] (220.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x006d0000			; r0=rConstants[321] (109.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_716
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_716:
	; BC_CONST [a6]
	mov r0, #0x00e00000			; r0=rConstants[38] (224.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_717
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_717:
	; BC_CONST [fe]
	mov r0, #0x00e30000			; r0=rConstants[322] (227.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a4]
	mov r0, #0x00660000			; r0=rConstants[36] (102.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_718
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_718:
	; BC_CONST [fe]
	mov r0, #0x00c30000			; r0=rConstants[291] (195.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ce]
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_719
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_719:
	; BC_CONST [fe]
	mov r0, #0x00e40000			; r0=rConstants[318] (228.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_720
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_720:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_721
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_721:
	; BC_CONST [fe]
	mov r0, #0x00ec0000			; r0=rConstants[323] (236.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00570000			; r0=rConstants[324] (87.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_722
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_722:
	; BC_CONST [fe]
	mov r0, #0x00490000			; r0=rConstants[242] (73.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9b]
	mov r0, #0x00160000			; r0=rConstants[27] (22.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_723
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_723:
	; BC_CONST [fe]
	mov r0, #0x00e70000			; r0=rConstants[325] (231.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x006c0000			; r0=rConstants[261] (108.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_724
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_724:
	; BC_CONST [fe]
	mov r0, #0x00cd0000			; r0=rConstants[316] (205.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ce]
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_725
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_725:
	; BC_CONST [fe]
	mov r0, #0x00eb0000			; r0=rConstants[326] (235.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a8]
	mov r0, #0x00600000			; r0=rConstants[40] (96.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_726
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_726:
	; BC_CONST [fe]
	mov r0, #0x00da0000			; r0=rConstants[304] (218.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_727
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_727:
	; BC_CONST [fe]
	mov r0, #0x00f20000			; r0=rConstants[303] (242.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00570000			; r0=rConstants[324] (87.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_728
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_728:
	; BC_CONST [ce]
	mov r0, #0x000d0000			; r0=rConstants[78] (13.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_729
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_729:
	; BC_CONST [fe]
	mov r0, #0x00f50000			; r0=rConstants[256] (245.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_730
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_730:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_731
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_731:
	; BC_CONST [fe]
	mov r0, #0x01040000			; r0=rConstants[327] (260.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00540000			; r0=rConstants[313] (84.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_732
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_732:
	; BC_CONST [fe]
	mov r0, #0x007a0000			; r0=rConstants[233] (122.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_733
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_733:
	; BC_CONST [fe]
	mov r0, #0x00fd0000			; r0=rConstants[328] (253.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00550000			; r0=rConstants[226] (85.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_734
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_734:
	; BC_CONST [fe]
	mov r0, #0x005b0000			; r0=rConstants[320] (91.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_735
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_735:
	; BC_CONST [fe]
	mov r0, #0x00f90000			; r0=rConstants[288] (249.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b4]
	mov r0, #0x005a0000			; r0=rConstants[52] (90.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_736
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_736:
	; BC_CONST [aa]
	mov r0, #0x00230000			; r0=rConstants[42] (35.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_737
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_737:
	; BC_CONST [fe]
	mov r0, #0x00fe0000			; r0=rConstants[329] (254.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a8]
	mov r0, #0x00600000			; r0=rConstants[40] (96.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_738
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_738:
	; BC_CONST [bb]
	mov r0, #0x00390000			; r0=rConstants[59] (57.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_739
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_739:
	; BC_CONST [fe]
	mov r0, #0x00ff0000			; r0=rConstants[330] (255.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a4]
	mov r0, #0x00660000			; r0=rConstants[36] (102.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_740
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_740:
	; BC_CONST [fe]
	mov r0, #0x00680000			; r0=rConstants[245] (104.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_741
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_741:
	; BC_CONST [fe]
	mov r0, #0x00f90000			; r0=rConstants[288] (249.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x006a0000			; r0=rConstants[249] (106.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_742
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_742:
	; BC_CONST [fe]
	mov r0, #0x008d0000			; r0=rConstants[331] (141.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_743
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_743:
	; BC_CONST [fe]
	mov r0, #0x00f30000			; r0=rConstants[332] (243.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00680000			; r0=rConstants[245] (104.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_744
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_744:
	; BC_CONST [9d]
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_745
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_745:
	; BC_CONST [fe]
	mov r0, #0x01060000			; r0=rConstants[333] (262.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x005c0000			; r0=rConstants[243] (92.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_746
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_746:
	; BC_CONST [fe]
	mov r0, #0x00f50000			; r0=rConstants[256] (245.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_747
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_747:
	; BC_CONST [fe]
	mov r0, #0x01110000			; r0=rConstants[334] (273.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00590000			; r0=rConstants[286] (89.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_748
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_748:
	; BC_CONST [8c]
	mov r0, #0x00c80000			; r0=rConstants[12] (200.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_749
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_749:
	; BC_CONST [fe]
	mov r0, #0x01120000			; r0=rConstants[335] (274.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00540000			; r0=rConstants[313] (84.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_750
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_750:
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_751
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_751:
	; BC_CONST [fe]
	mov r0, #0x01100000			; r0=rConstants[336] (272.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [96]
	mov r0, #0x00520000			; r0=rConstants[22] (82.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_752
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_752:
	; BC_CONST [c4]
	mov r0, #0x00690000			; r0=rConstants[68] (105.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_753
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_753:
	; BC_CONST [fe]
	mov r0, #0x010b0000			; r0=rConstants[337] (267.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00550000			; r0=rConstants[226] (85.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_754
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_754:
	; BC_CONST [fe]
	mov r0, #0x00510000			; r0=rConstants[246] (81.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c6]
	mov r0, #0x000f0000			; r0=rConstants[70] (15.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_755
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_755:
	; BC_CONST [fe]
	mov r0, #0x01050000			; r0=rConstants[338] (261.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x00620000			; r0=rConstants[339] (98.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_756
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_756:
	; BC_CONST [fe]
	mov r0, #0x002d0000			; r0=rConstants[170] (45.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_757
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_757:
	; BC_CONST [fe]
	mov r0, #0x01070000			; r0=rConstants[181] (263.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a4]
	mov r0, #0x00660000			; r0=rConstants[36] (102.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_758
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_758:
	; BC_CONST [fe]
	mov r0, #0x00f40000			; r0=rConstants[340] (244.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [8b]
	mov r0, #0x00080000			; r0=rConstants[11] (8.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_759
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_759:
	; BC_CONST [fe]
	mov r0, #0x010e0000			; r0=rConstants[341] (270.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [92]
	mov r0, #0x00640000			; r0=rConstants[18] (100.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_760
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_760:
	; BC_CONST [fe]
	mov r0, #0x00d60000			; r0=rConstants[342] (214.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [88]
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00020000			; r0=rConstants[28] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_761
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_761:
	; BC_CONST [fe]
	mov r0, #0x01110000			; r0=rConstants[334] (273.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ba]
	mov r0, #0x005f0000			; r0=rConstants[58] (95.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_762
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_762:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_117_end:

proc_118_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [ca]
	mov r0, #0x000c0000			; r0=rConstants[74] (12.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [c0]
	ldr r0, [r4, #64*4]			; r0=rConstants[64]=0x14bc3c49 (5308.2355)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_763
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_763:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_764
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_764:
	; BC_CONST [fe]
	ldr r0, [r4, #193*4]			; r0=rConstants[193]=0x881f1f81 (34847.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_765
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_765:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_766
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_766:
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_767
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_767:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_768
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_768:
	; BC_CONST [d6]
	ldr r0, [r4, #86*4]			; r0=rConstants[86]=0x189c2186 (6300.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_769
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_769:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_770
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_770:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_771
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_771:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_772
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_772:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_773
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_773:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_774
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_774:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_775
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_775:
	; BC_CONST [d8]
	ldr r0, [r4, #88*4]			; r0=rConstants[88]=0x147f1c49 (5247.1105)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_776
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_776:
	; BC_CONST [d4]
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_777
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_777:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_778
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_778:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_779
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_779:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_780
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_780:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_781
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_781:
	; BC_CONST [bf]
	ldr r0, [r4, #63*4]			; r0=rConstants[63]=0xf0410107 (61505.0040)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_782
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_782:
	; BC_CONST [c2]
	ldr r0, [r4, #66*4]			; r0=rConstants[66]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_783
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_783:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_118_end:

proc_119_start:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [fe]
	mov r0, #0x00580000			; r0=rConstants[171] (88.0000)
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00230000			; r0=rConstants[42] (35.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [cc]
	mov r0, #0x008c0000			; r0=rConstants[76] (140.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_784
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_784:
	; BC_CONST [fe]
	ldr r0, [r4, #343*4]			; r0=rConstants[343]=0x989c2f46 (39068.1847)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_785
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_785:
	; BC_CONST [d3]
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_786
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_786:
	; BC_CONST [bd]
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_787
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_787:
	; BC_CONST [be]
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_788
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_788:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_789
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_789:
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_790
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_790:
	; BC_CONST [c1]
	ldr r0, [r4, #65*4]			; r0=rConstants[65]=0x083f3082 (2111.1895)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_791
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_791:
	; BC_CONST [d9]
	ldr r0, [r4, #89*4]			; r0=rConstants[89]=0x185e1e86 (6238.1192)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_792
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_792:
	; BC_CONST [fe]
	ldr r0, [r4, #187*4]			; r0=rConstants[187]=0x040f0f42 (1039.0596)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_793
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_793:
	; BC_CONST [c3]
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [81]
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_794
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_794:
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_119_end:

proc_120_start:
	; BC_CONST [b2]
	mov r0, #0x00a00000			; r0=rConstants[50] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00500000			; r0=rConstants[53] (80.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b6]
	mov r0, #0x00280000			; r0=rConstants[54] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RSTATE [73]
	ldr r0, [r5, #ST_SIZE*4]		; r0=State[ST_SIZE]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_120_continue_795
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_120_continue_795:
	; BC_CONST [fe]
	mov r0, #0x0bb80000			; r0=rConstants[344] (3000.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_120_end:

proc_121_start:
	; BC_CONST [c7]
	mov r0, #0x00800000			; r0=rConstants[71] (128.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [fe]
	mov r0, #0x006c0000			; r0=rConstants[261] (108.0000)
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WSTATE [5d]
	str r0, [r5, #ST_WIRE5*4]		; State[ST_WIRE5]=r0
	; BC_CONST [97]
	mov r0, #0x00070000			; r0=rConstants[23] (7.0000)
	; BC_WSTATE [5c]
	str r0, [r5, #ST_WIRE4*4]		; State[ST_WIRE4]=r0
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_WSTATE [5b]
	str r0, [r5, #ST_WIRE3*4]		; State[ST_WIRE3]=r0
	; BC_CONST [85]
	mov r0, #0x00030000			; r0=rConstants[5] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #180*4]			; r0=rConstants[180]=0x987f14aa (39039.0807)
	; BC_CONST [d3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #83*4]			; r0=rConstants[83]=0x081f1f82 (2079.1231)
	; BC_CONST [da]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_CONST [da]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #90*4]			; r0=rConstants[90]=0x927f0104 (37503.0040)
	; BC_CONST [c3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #67*4]			; r0=rConstants[67]=0x9a7f2186 (39551.1310)
	; BC_CONST [d4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #84*4]			; r0=rConstants[84]=0x107f2c49 (4223.1730)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #61*4]			; r0=rConstants[61]=0xf8602087 (63584.1271)
	; BC_CONST [be]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #62*4]			; r0=rConstants[62]=0x107e3c08 (4222.2345)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #95*4]			; r0=rConstants[95]=0x98bc3ba6 (39100.2330)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #195*4]			; r0=rConstants[195]=0x00202002 (32.1250)
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [2b]
	mov r1, #11
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_121_end:

proc_122_start:
	; BC_RAND [03]
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[2] (32.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RAND [03]
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00120000			; r0=rConstants[39] (18.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RAND [03]
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[17] (20.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [81]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[1] (5.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RAND [03]
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[8] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [73]
	ldr r0, [r5, #ST_SIZE*4]		; r0=State[ST_SIZE]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [83]
	mov r0, #0x00000000			; r0=rConstants[3] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00040000			; r0=rConstants[49] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RAND [03]
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[29] (10.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WAIT [0a]
	adr r1, proc_122_continue_796
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_122_continue_796:
	; BC_PROC [07]
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_122_end:

proc_123_start:
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [8a]
	mov r0, #0x00010000			; r0=rConstants[10] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_123_continue_797
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_123_continue_797:
	; BC_PROC [07]
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_123_end:


; ============================================================================
; Constants.
; ============================================================================

r_Constants:
.long 0x00400000				; [0] = 64.0000
.long 0x00050000				; [1] = 5.0000
.long 0x00200000				; [2] = 32.0000
.long 0x00000000				; [3] = 0.0000
.long 0x002b0000				; [4] = 43.0000
.long 0x00030000				; [5] = 3.0000
.long 0x00300000				; [6] = 48.0000
.long 0x002a0000				; [7] = 42.0000
.long 0x00060000				; [8] = 6.0000
.long 0x00380000				; [9] = 56.0000
.long 0x00010000				; [10] = 1.0000
.long 0x00080000				; [11] = 8.0000
.long 0x00c80000				; [12] = 200.0000
.long 0x00b30000				; [13] = 179.0000
.long 0x003e0000				; [14] = 62.0000
.long 0x00002666				; [15] = 0.1500
.long 0x00004ccd				; [16] = 0.3000
.long 0x00140000				; [17] = 20.0000
.long 0x00640000				; [18] = 100.0000
.long 0x00c40000				; [19] = 196.0000
.long 0x0000599a				; [20] = 0.3500
.long 0x00bb0000				; [21] = 187.0000
.long 0x00520000				; [22] = 82.0000
.long 0x00070000				; [23] = 7.0000
.long 0x00b00000				; [24] = 176.0000
.long 0x00530000				; [25] = 83.0000
.long 0x00f00000				; [26] = 240.0000
.long 0x00160000				; [27] = 22.0000
.long 0x00020000				; [28] = 2.0000
.long 0x000a0000				; [29] = 10.0000
.long 0x00b80000				; [30] = 184.0000
.long 0x00ea0000				; [31] = 234.0000
.long 0x00b60000				; [32] = 182.0000
.long 0x00960000				; [33] = 150.0000
.long 0x001e0000				; [34] = 30.0000
.long 0x009a0000				; [35] = 154.0000
.long 0x00660000				; [36] = 102.0000
.long 0x00320000				; [37] = 50.0000
.long 0x00e00000				; [38] = 224.0000
.long 0x00120000				; [39] = 18.0000
.long 0x00600000				; [40] = 96.0000
.long 0x00018000				; [41] = 1.5000
.long 0x00230000				; [42] = 35.0000
.long 0x00006666				; [43] = 0.4000
.long 0x00460000				; [44] = 70.0000
.long 0x00780000				; [45] = 120.0000
.long 0x00008000				; [46] = 0.5000
.long 0x01f40000				; [47] = 500.0000
.long 0x00100000				; [48] = 16.0000
.long 0x00040000				; [49] = 4.0000
.long 0x00a00000				; [50] = 160.0000
.long 0x00c00000				; [51] = 192.0000
.long 0x005a0000				; [52] = 90.0000
.long 0x00500000				; [53] = 80.0000
.long 0x00280000				; [54] = 40.0000
.long 0x00410000				; [55] = 65.0000
.long 0x00180000				; [56] = 24.0000
.long 0x00240000				; [57] = 36.0000
.long 0x005f0000				; [58] = 95.0000
.long 0x00390000				; [59] = 57.0000
.long 0x00750000				; [60] = 117.0000
.long 0xf8602087				; [61] = 63584.1271
.long 0x107e3c08				; [62] = 4222.2345
.long 0xf0410107				; [63] = 61505.0040
.long 0x14bc3c49				; [64] = 5308.2355
.long 0x083f3082				; [65] = 2111.1895
.long 0x9a6e19a6				; [66] = 39534.1002
.long 0x9a7f2186				; [67] = 39551.1310
.long 0x00690000				; [68] = 105.0000
.long 0x000e0000				; [69] = 14.0000
.long 0x000f0000				; [70] = 15.0000
.long 0x00800000				; [71] = 128.0000
.long 0x00090000				; [72] = 9.0000
.long 0x000b0000				; [73] = 11.0000
.long 0x000c0000				; [74] = 12.0000
.long 0x00130000				; [75] = 19.0000
.long 0x008c0000				; [76] = 140.0000
.long 0x002e0000				; [77] = 46.0000
.long 0x000d0000				; [78] = 13.0000
.long 0x00004000				; [79] = 0.2500
.long 0x00110000				; [80] = 17.0000
.long 0x006e0000				; [81] = 110.0000
.long 0x00650000				; [82] = 101.0000
.long 0x081f1f82				; [83] = 2079.1231
.long 0x107f2c49				; [84] = 4223.1730
.long 0x40bf3f08				; [85] = 16575.2462
.long 0x189c2186				; [86] = 6300.1310
.long 0x823f3f20				; [87] = 33343.2466
.long 0x147f1c49				; [88] = 5247.1105
.long 0x185e1e86				; [89] = 6238.1192
.long 0x927f0104				; [90] = 37503.0040
.long 0x187f3c8a				; [91] = 6271.2365
.long 0xf0000002				; [92] = 61440.0000
.long 0x00088000				; [93] = 8.5000
.long 0x82071fa2				; [94] = 33287.1236
.long 0x98bc3ba6				; [95] = 39100.2330
.long 0x90400e26				; [96] = 36928.0553
.long 0x009d0000				; [97] = 157.0000
.long 0x01400000				; [98] = 320.0000
.long 0x00001999				; [99] = 0.1000
.long 0x00a50000				; [100] = 165.0000
.long 0x01180000				; [101] = 280.0000
.long 0x00250000				; [102] = 37.0000
.long 0x00a60000				; [103] = 166.0000
.long 0xf8800083				; [104] = 63616.0020
.long 0x98611bb6				; [105] = 39009.1082
.long 0x18410725				; [106] = 6209.0279
.long 0x00190000				; [107] = 25.0000
.long 0x9a5616a6				; [108] = 39510.0885
.long 0x92461ea6				; [109] = 37446.1197
.long 0x820f08f0				; [110] = 33295.0349
.long 0x003c0000				; [111] = 60.0000
.long 0x3c7ec001				; [112] = 15486.7500
.long 0x00080004				; [113] = 8.0001
.long 0x20034092				; [114] = 8195.2522
.long 0xc0824882				; [115] = 49282.2832
.long 0x41442138				; [116] = 16708.1298
.long 0x1e081008				; [117] = 7688.0626
.long 0x10041004				; [118] = 4100.0626
.long 0x20042084				; [119] = 8196.1270
.long 0x00007ffe				; [120] = 0.5000
.long 0x3ffc5ffa				; [121] = 16380.3749
.long 0x6ff677ee				; [122] = 28662.4685
.long 0x68165ffa				; [123] = 26646.3749
.long 0x3ffc7ffe				; [124] = 16380.5000
.long 0x78384648				; [125] = 30776.2745
.long 0x21903000				; [126] = 8592.1875
.long 0x43b04448				; [127] = 17328.2667
.long 0x86680440				; [128] = 34408.0166
.long 0x03be201d				; [129] = 958.1254
.long 0x20091001				; [130] = 8201.0625
.long 0x08090612				; [131] = 2057.0237
.long 0x05ec0800				; [132] = 1516.0312
.long 0x62236223				; [133] = 25123.3833
.long 0x77777777				; [134] = 30583.4667
.long 0x00007777				; [135] = 0.4667
.long 0x08180c28				; [136] = 2072.0475
.long 0x0bc8040c				; [137] = 3016.0158
.long 0x06c20922				; [138] = 1730.0357
.long 0x0da116c0				; [139] = 3489.0889
.long 0x20044004				; [140] = 8196.2501
.long 0x4008a830				; [141] = 16392.6570
.long 0x80c08120				; [142] = 32960.5044
.long 0x42103c10				; [143] = 16912.2346
.long 0x44004404				; [144] = 17408.2657
.long 0x888480c2				; [145] = 34948.5030
.long 0x41e223e4				; [146] = 16866.1402
.long 0x00200f80				; [147] = 32.0605
.long 0x1fec1dfc				; [148] = 8172.1171
.long 0x0ff86000				; [149] = 4088.3750
.long 0xff74ffde				; [150] = 65396.9995
.long 0x7ffe1ffc				; [151] = 32766.1249
.long 0x00000ff8				; [152] = 0.0624
.long 0x0ff80000				; [153] = 4088.0000
.long 0x01c001c0				; [154] = 448.0068
.long 0x01c00ff8				; [155] = 448.0624
.long 0x07f003e0				; [156] = 2032.0151
.long 0x01c00080				; [157] = 448.0020
.long 0x04100a28				; [158] = 1040.0397
.long 0x11442082				; [159] = 4420.1270
.long 0x1004280a				; [160] = 4100.1564
.long 0x14140808				; [161] = 5140.0314
.long 0x10042082				; [162] = 4100.1270
.long 0x11442aaa				; [163] = 4420.1667
.long 0x15540a28				; [164] = 5460.0397
.long 0x04100000				; [165] = 1040.0000
.long 0x00480000				; [166] = 72.0000
.long 0x00290000				; [167] = 41.0000
.long 0x005d0000				; [168] = 93.0000
.long 0x00870000				; [169] = 135.0000
.long 0x002d0000				; [170] = 45.0000
.long 0x00580000				; [171] = 88.0000
.long 0x00150000				; [172] = 21.0000
.long 0x00a80000				; [173] = 168.0000
.long 0x00210000				; [174] = 33.0000
.long 0x01220000				; [175] = 290.0000
.long 0x01900000				; [176] = 400.0000
.long 0x001a0000				; [177] = 26.0000
.long 0x00000002				; [178] = 0.0000
.long 0x001d0000				; [179] = 29.0000
.long 0x987f14aa				; [180] = 39039.0807
.long 0x01070000				; [181] = 263.0000
.long 0x823f2350				; [182] = 33343.1379
.long 0x00810281				; [183] = 129.0098
.long 0xc4444444				; [184] = 50244.2667
.long 0x10109010				; [185] = 4112.5627
.long 0x00000001				; [186] = 0.0000
.long 0x040f0f42				; [187] = 1039.0596
.long 0xffffffff				; [188] = 65536.0000
.long 0x001f0000				; [189] = 31.0000
.long 0x00fa0000				; [190] = 250.0000
.long 0x00420000				; [191] = 66.0000
.long 0x18710f46				; [192] = 6257.0597
.long 0x881f1f81				; [193] = 34847.1231
.long 0x9a7226a6				; [194] = 39538.1510
.long 0x00202002				; [195] = 32.1250
.long 0x008f0000				; [196] = 143.0000
.long 0x00000025				; [197] = 0.0006
.long 0x55656235				; [198] = 21861.3836
.long 0x65446665				; [199] = 25924.4000
.long 0x64334444				; [200] = 25651.2667
.long 0x33466634				; [201] = 13126.3992
.long 0x66424385				; [202] = 26178.2637
.long 0x54466548				; [203] = 21574.3956
.long 0x9668aa63				; [204] = 38504.6656
.long 0x36898987				; [205] = 13961.5372
.long 0x879dfbaa				; [206] = 34717.9831
.long 0x878bceeb				; [207] = 34699.8083
.long 0x7889c9bf				; [208] = 30857.7881
.long 0x00021999				; [209] = 2.1000
.long 0xeac88dca				; [210] = 60104.5539
.long 0xced8bbba				; [211] = 52952.7333
.long 0x99daaffd				; [212] = 39386.6875
.long 0x866568df				; [213] = 34405.4097
.long 0xffffeefe				; [214] = 65535.9336
.long 0xeeebffdb				; [215] = 61163.9994
.long 0xceffddee				; [216] = 52991.8669
.long 0xcdddddbc				; [217] = 52701.8661
.long 0xc9ddcddd				; [218] = 51677.8042
.long 0xdcbdbedc				; [219] = 56509.7455
.long 0xa8338cc1				; [220] = 43059.5498
.long 0x00610000				; [221] = 97.0000
.long 0x008a0000				; [222] = 138.0000
.long 0x001c0000				; [223] = 28.0000
.long 0x00370000				; [224] = 55.0000
.long 0x003b0000				; [225] = 59.0000
.long 0x00550000				; [226] = 85.0000
.long 0x004b0000				; [227] = 75.0000
.long 0x00470000				; [228] = 71.0000
.long 0x00330000				; [229] = 51.0000
.long 0x004d0000				; [230] = 77.0000
.long 0x003a0000				; [231] = 58.0000
.long 0x00350000				; [232] = 53.0000
.long 0x007a0000				; [233] = 122.0000
.long 0x005e0000				; [234] = 94.0000
.long 0x00340000				; [235] = 52.0000
.long 0x00450000				; [236] = 69.0000
.long 0x002f0000				; [237] = 47.0000
.long 0x00c50000				; [238] = 197.0000
.long 0x00310000				; [239] = 49.0000
.long 0x00f70000				; [240] = 247.0000
.long 0x002c0000				; [241] = 44.0000
.long 0x00490000				; [242] = 73.0000
.long 0x005c0000				; [243] = 92.0000
.long 0x003f0000				; [244] = 63.0000
.long 0x00680000				; [245] = 104.0000
.long 0x00510000				; [246] = 81.0000
.long 0x00710000				; [247] = 113.0000
.long 0x00440000				; [248] = 68.0000
.long 0x006a0000				; [249] = 106.0000
.long 0x00e80000				; [250] = 232.0000
.long 0x00630000				; [251] = 99.0000
.long 0x00d90000				; [252] = 217.0000
.long 0x006b0000				; [253] = 107.0000
.long 0x00ba0000				; [254] = 186.0000
.long 0x00430000				; [255] = 67.0000
.long 0x00f50000				; [256] = 245.0000
.long 0x00790000				; [257] = 121.0000
.long 0x00cf0000				; [258] = 207.0000
.long 0x007b0000				; [259] = 123.0000
.long 0x00720000				; [260] = 114.0000
.long 0x006c0000				; [261] = 108.0000
.long 0x004a0000				; [262] = 74.0000
.long 0x00700000				; [263] = 112.0000
.long 0x00f10000				; [264] = 241.0000
.long 0x00820000				; [265] = 130.0000
.long 0x007c0000				; [266] = 124.0000
.long 0x00d10000				; [267] = 209.0000
.long 0x00830000				; [268] = 131.0000
.long 0x00e50000				; [269] = 229.0000
.long 0x008b0000				; [270] = 139.0000
.long 0x00360000				; [271] = 54.0000
.long 0x00850000				; [272] = 133.0000
.long 0x00d20000				; [273] = 210.0000
.long 0x00e20000				; [274] = 226.0000
.long 0x00940000				; [275] = 148.0000
.long 0x00920000				; [276] = 146.0000
.long 0x004e0000				; [277] = 78.0000
.long 0x00970000				; [278] = 151.0000
.long 0x00260000				; [279] = 38.0000
.long 0x00a40000				; [280] = 164.0000
.long 0x00ab0000				; [281] = 171.0000
.long 0x00f80000				; [282] = 248.0000
.long 0x00b10000				; [283] = 177.0000
.long 0x00bc0000				; [284] = 188.0000
.long 0x00b40000				; [285] = 180.0000
.long 0x00590000				; [286] = 89.0000
.long 0x00af0000				; [287] = 175.0000
.long 0x00f90000				; [288] = 249.0000
.long 0x00b50000				; [289] = 181.0000
.long 0x00d70000				; [290] = 215.0000
.long 0x00c30000				; [291] = 195.0000
.long 0x00d80000				; [292] = 216.0000
.long 0x00890000				; [293] = 137.0000
.long 0x00d40000				; [294] = 212.0000
.long 0x00ce0000				; [295] = 206.0000
.long 0x00c90000				; [296] = 201.0000
.long 0x00ca0000				; [297] = 202.0000
.long 0x00ed0000				; [298] = 237.0000
.long 0x00db0000				; [299] = 219.0000
.long 0x004f0000				; [300] = 79.0000
.long 0x00d50000				; [301] = 213.0000
.long 0x003d0000				; [302] = 61.0000
.long 0x00f20000				; [303] = 242.0000
.long 0x00da0000				; [304] = 218.0000
.long 0x00ae0000				; [305] = 174.0000
.long 0x00a30000				; [306] = 163.0000
.long 0x00d00000				; [307] = 208.0000
.long 0x00c60000				; [308] = 198.0000
.long 0x00770000				; [309] = 119.0000
.long 0x00a10000				; [310] = 161.0000
.long 0x00e10000				; [311] = 225.0000
.long 0x00740000				; [312] = 116.0000
.long 0x00540000				; [313] = 84.0000
.long 0x00cb0000				; [314] = 203.0000
.long 0x006f0000				; [315] = 111.0000
.long 0x00cd0000				; [316] = 205.0000
.long 0x00dc0000				; [317] = 220.0000
.long 0x00e40000				; [318] = 228.0000
.long 0x00dd0000				; [319] = 221.0000
.long 0x005b0000				; [320] = 91.0000
.long 0x006d0000				; [321] = 109.0000
.long 0x00e30000				; [322] = 227.0000
.long 0x00ec0000				; [323] = 236.0000
.long 0x00570000				; [324] = 87.0000
.long 0x00e70000				; [325] = 231.0000
.long 0x00eb0000				; [326] = 235.0000
.long 0x01040000				; [327] = 260.0000
.long 0x00fd0000				; [328] = 253.0000
.long 0x00fe0000				; [329] = 254.0000
.long 0x00ff0000				; [330] = 255.0000
.long 0x008d0000				; [331] = 141.0000
.long 0x00f30000				; [332] = 243.0000
.long 0x01060000				; [333] = 262.0000
.long 0x01110000				; [334] = 273.0000
.long 0x01120000				; [335] = 274.0000
.long 0x01100000				; [336] = 272.0000
.long 0x010b0000				; [337] = 267.0000
.long 0x01050000				; [338] = 261.0000
.long 0x00620000				; [339] = 98.0000
.long 0x00f40000				; [340] = 244.0000
.long 0x010e0000				; [341] = 270.0000
.long 0x00d60000				; [342] = 214.0000
.long 0x989c2f46				; [343] = 39068.1847
.long 0x0bb80000				; [344] = 3000.0000

; ============================================================================
; Color Script.
; ============================================================================

r_ColorScript:
.long -1, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05333333, 0x06aaaaaa, 0x07cccccc			; delta_frames=1 [0]
.long -960			; delta_frames=960 [960]
.long -960, 0x06aaaaaa			; delta_frames=960 [1920]
.long -2, 0x06999999			; delta_frames=2 [1922]
.long -3, 0x06888888			; delta_frames=3 [1925]
.long -3, 0x06777777			; delta_frames=3 [1928]
.long -3, 0x06666666			; delta_frames=3 [1931]
.long -2, 0x06555555			; delta_frames=2 [1933]
.long -3, 0x06444444			; delta_frames=3 [1936]
.long -3, 0x06333333			; delta_frames=3 [1939]
.long -3, 0x06444444			; delta_frames=3 [1942]
.long -3, 0x06555555			; delta_frames=3 [1945]
.long -3, 0x06666666			; delta_frames=3 [1948]
.long -2, 0x06777777			; delta_frames=2 [1950]
.long -3, 0x06888888			; delta_frames=3 [1953]
.long -3, 0x06999999			; delta_frames=3 [1956]
.long -3, 0x06aaaaaa			; delta_frames=3 [1959]
.long -3, 0x06999999			; delta_frames=3 [1962]
.long -3, 0x06888888			; delta_frames=3 [1965]
.long -3, 0x06777777			; delta_frames=3 [1968]
.long -3, 0x06666666			; delta_frames=3 [1971]
.long -2, 0x06555555			; delta_frames=2 [1973]
.long -3, 0x06444444			; delta_frames=3 [1976]
.long -3, 0x06333333			; delta_frames=3 [1979]
.long -3, 0x06444444			; delta_frames=3 [1982]
.long -3, 0x06555555			; delta_frames=3 [1985]
.long -3, 0x06666666			; delta_frames=3 [1988]
.long -2, 0x06777777			; delta_frames=2 [1990]
.long -3, 0x06888888			; delta_frames=3 [1993]
.long -3, 0x06999999			; delta_frames=3 [1996]
.long -3, 0x06aaaaaa			; delta_frames=3 [1999]
.long -3, 0x06999999			; delta_frames=3 [2002]
.long -3, 0x06888888			; delta_frames=3 [2005]
.long -3, 0x06777777			; delta_frames=3 [2008]
.long -3, 0x06666666			; delta_frames=3 [2011]
.long -2, 0x06555555			; delta_frames=2 [2013]
.long -3, 0x06444444			; delta_frames=3 [2016]
.long -3, 0x06333333			; delta_frames=3 [2019]
.long -3, 0x06444444			; delta_frames=3 [2022]
.long -3, 0x06555555			; delta_frames=3 [2025]
.long -3, 0x06666666			; delta_frames=3 [2028]
.long -2, 0x06777777			; delta_frames=2 [2030]
.long -3, 0x06888888			; delta_frames=3 [2033]
.long -3, 0x06999999			; delta_frames=3 [2036]
.long -3, 0x06aaaaaa			; delta_frames=3 [2039]
.long -3, 0x06999999			; delta_frames=3 [2042]
.long -3, 0x06888888			; delta_frames=3 [2045]
.long -3, 0x06777777			; delta_frames=3 [2048]
.long -3, 0x06666666			; delta_frames=3 [2051]
.long -2, 0x06555555			; delta_frames=2 [2053]
.long -3, 0x06444444			; delta_frames=3 [2056]
.long -3, 0x06333333			; delta_frames=3 [2059]
.long -3, 0x06444444			; delta_frames=3 [2062]
.long -3, 0x06555555			; delta_frames=3 [2065]
.long -3, 0x06666666			; delta_frames=3 [2068]
.long -2, 0x06777777			; delta_frames=2 [2070]
.long -3, 0x06888888			; delta_frames=3 [2073]
.long -3, 0x06999999			; delta_frames=3 [2076]
.long -3, 0x06aaaaaa			; delta_frames=3 [2079]
.long -3, 0x06999999			; delta_frames=3 [2082]
.long -3, 0x06888888			; delta_frames=3 [2085]
.long -3, 0x06777777			; delta_frames=3 [2088]
.long -3, 0x06666666			; delta_frames=3 [2091]
.long -2, 0x06555555			; delta_frames=2 [2093]
.long -3, 0x06444444			; delta_frames=3 [2096]
.long -3, 0x06333333			; delta_frames=3 [2099]
.long -3, 0x06444444			; delta_frames=3 [2102]
.long -3, 0x06555555			; delta_frames=3 [2105]
.long -3, 0x06666666			; delta_frames=3 [2108]
.long -2, 0x06777777			; delta_frames=2 [2110]
.long -3, 0x06888888			; delta_frames=3 [2113]
.long -3, 0x06999999			; delta_frames=3 [2116]
.long -3, 0x06aaaaaa			; delta_frames=3 [2119]
.long -3, 0x06999999			; delta_frames=3 [2122]
.long -3, 0x06888888			; delta_frames=3 [2125]
.long -3, 0x06777777			; delta_frames=3 [2128]
.long -3, 0x06666666			; delta_frames=3 [2131]
.long -2, 0x06555555			; delta_frames=2 [2133]
.long -3, 0x06444444			; delta_frames=3 [2136]
.long -3, 0x06333333			; delta_frames=3 [2139]
.long -3, 0x06444444			; delta_frames=3 [2142]
.long -3, 0x06555555			; delta_frames=3 [2145]
.long -3, 0x06666666			; delta_frames=3 [2148]
.long -2, 0x06777777			; delta_frames=2 [2150]
.long -3, 0x06888888			; delta_frames=3 [2153]
.long -3, 0x06999999			; delta_frames=3 [2156]
.long -3, 0x06aaaaaa			; delta_frames=3 [2159]
.long -3, 0x06999999			; delta_frames=3 [2162]
.long -3, 0x06888888			; delta_frames=3 [2165]
.long -3, 0x06777777			; delta_frames=3 [2168]
.long -3, 0x06666666			; delta_frames=3 [2171]
.long -2, 0x06555555			; delta_frames=2 [2173]
.long -3, 0x06444444			; delta_frames=3 [2176]
.long -3, 0x06333333			; delta_frames=3 [2179]
.long -3, 0x06444444			; delta_frames=3 [2182]
.long -3, 0x06555555			; delta_frames=3 [2185]
.long -3, 0x06666666			; delta_frames=3 [2188]
.long -2, 0x06777777			; delta_frames=2 [2190]
.long -3, 0x06888888			; delta_frames=3 [2193]
.long -3, 0x06999999			; delta_frames=3 [2196]
.long -3, 0x06aaaaaa			; delta_frames=3 [2199]
.long -3, 0x06999999			; delta_frames=3 [2202]
.long -3, 0x06888888			; delta_frames=3 [2205]
.long -3, 0x06777777			; delta_frames=3 [2208]
.long -3, 0x06666666			; delta_frames=3 [2211]
.long -2, 0x06555555			; delta_frames=2 [2213]
.long -3, 0x06444444			; delta_frames=3 [2216]
.long -3, 0x06333333			; delta_frames=3 [2219]
.long -3, 0x06444444			; delta_frames=3 [2222]
.long -3, 0x06555555			; delta_frames=3 [2225]
.long -3, 0x06666666			; delta_frames=3 [2228]
.long -2, 0x06777777			; delta_frames=2 [2230]
.long -3, 0x06888888			; delta_frames=3 [2233]
.long -3, 0x06999999			; delta_frames=3 [2236]
.long -3, 0x06aaaaaa			; delta_frames=3 [2239]
.long -3, 0x06999999			; delta_frames=3 [2242]
.long -3, 0x06888888			; delta_frames=3 [2245]
.long -3, 0x06777777			; delta_frames=3 [2248]
.long -3, 0x06666666			; delta_frames=3 [2251]
.long -2, 0x06555555			; delta_frames=2 [2253]
.long -3, 0x06444444			; delta_frames=3 [2256]
.long -3, 0x06333333			; delta_frames=3 [2259]
.long -3, 0x06444444			; delta_frames=3 [2262]
.long -3, 0x06555555			; delta_frames=3 [2265]
.long -3, 0x06666666			; delta_frames=3 [2268]
.long -2, 0x06777777			; delta_frames=2 [2270]
.long -3, 0x06888888			; delta_frames=3 [2273]
.long -3, 0x06999999			; delta_frames=3 [2276]
.long -3, 0x06aaaaaa			; delta_frames=3 [2279]
.long -3, 0x06999999			; delta_frames=3 [2282]
.long -3, 0x06888888			; delta_frames=3 [2285]
.long -3, 0x06777777			; delta_frames=3 [2288]
.long -3, 0x06666666			; delta_frames=3 [2291]
.long -2, 0x06555555			; delta_frames=2 [2293]
.long -3, 0x06444444			; delta_frames=3 [2296]
.long -3, 0x06333333			; delta_frames=3 [2299]
.long -3, 0x06444444			; delta_frames=3 [2302]
.long -3, 0x06555555			; delta_frames=3 [2305]
.long -3, 0x06666666			; delta_frames=3 [2308]
.long -2, 0x06777777			; delta_frames=2 [2310]
.long -3, 0x06888888			; delta_frames=3 [2313]
.long -3, 0x06999999			; delta_frames=3 [2316]
.long -3, 0x06aaaaaa			; delta_frames=3 [2319]
.long -3, 0x06999999			; delta_frames=3 [2322]
.long -3, 0x06888888			; delta_frames=3 [2325]
.long -3, 0x06777777			; delta_frames=3 [2328]
.long -3, 0x06666666			; delta_frames=3 [2331]
.long -2, 0x06555555			; delta_frames=2 [2333]
.long -3, 0x06444444			; delta_frames=3 [2336]
.long -3, 0x06333333			; delta_frames=3 [2339]
.long -3, 0x06444444			; delta_frames=3 [2342]
.long -3, 0x06555555			; delta_frames=3 [2345]
.long -3, 0x06666666			; delta_frames=3 [2348]
.long -2, 0x06777777			; delta_frames=2 [2350]
.long -3, 0x06888888			; delta_frames=3 [2353]
.long -3, 0x06999999			; delta_frames=3 [2356]
.long -3, 0x06aaaaaa			; delta_frames=3 [2359]
.long -3, 0x06999999			; delta_frames=3 [2362]
.long -3, 0x06888888			; delta_frames=3 [2365]
.long -3, 0x06777777			; delta_frames=3 [2368]
.long -3, 0x06666666			; delta_frames=3 [2371]
.long -2, 0x06555555			; delta_frames=2 [2373]
.long -3, 0x06444444			; delta_frames=3 [2376]
.long -3, 0x06333333			; delta_frames=3 [2379]
.long -3, 0x06444444			; delta_frames=3 [2382]
.long -3, 0x06555555			; delta_frames=3 [2385]
.long -3, 0x06666666			; delta_frames=3 [2388]
.long -2, 0x06777777			; delta_frames=2 [2390]
.long -3, 0x06888888			; delta_frames=3 [2393]
.long -3, 0x06999999			; delta_frames=3 [2396]
.long -3, 0x06aaaaaa			; delta_frames=3 [2399]
.long -3, 0x06999999			; delta_frames=3 [2402]
.long -3, 0x06888888			; delta_frames=3 [2405]
.long -3, 0x06777777			; delta_frames=3 [2408]
.long -3, 0x06666666			; delta_frames=3 [2411]
.long -2, 0x06555555			; delta_frames=2 [2413]
.long -3, 0x06444444			; delta_frames=3 [2416]
.long -3, 0x06333333			; delta_frames=3 [2419]
.long -3, 0x06444444			; delta_frames=3 [2422]
.long -3, 0x06555555			; delta_frames=3 [2425]
.long -3, 0x06666666			; delta_frames=3 [2428]
.long -2, 0x06777777			; delta_frames=2 [2430]
.long -3, 0x06888888			; delta_frames=3 [2433]
.long -3, 0x06999999			; delta_frames=3 [2436]
.long -3, 0x06aaaaaa			; delta_frames=3 [2439]
.long -3, 0x06999999			; delta_frames=3 [2442]
.long -3, 0x06888888			; delta_frames=3 [2445]
.long -3, 0x06777777			; delta_frames=3 [2448]
.long -3, 0x06666666			; delta_frames=3 [2451]
.long -2, 0x06555555			; delta_frames=2 [2453]
.long -3, 0x06444444			; delta_frames=3 [2456]
.long -3, 0x06333333			; delta_frames=3 [2459]
.long -3, 0x06444444			; delta_frames=3 [2462]
.long -3, 0x06555555			; delta_frames=3 [2465]
.long -3, 0x06666666			; delta_frames=3 [2468]
.long -2, 0x06777777			; delta_frames=2 [2470]
.long -3, 0x06888888			; delta_frames=3 [2473]
.long -3, 0x06999999			; delta_frames=3 [2476]
.long -3, 0x06aaaaaa			; delta_frames=3 [2479]
.long -3, 0x06999999			; delta_frames=3 [2482]
.long -3, 0x06888888			; delta_frames=3 [2485]
.long -3, 0x06777777			; delta_frames=3 [2488]
.long -3, 0x06666666			; delta_frames=3 [2491]
.long -2, 0x06555555			; delta_frames=2 [2493]
.long -3, 0x06444444			; delta_frames=3 [2496]
.long -3, 0x06333333			; delta_frames=3 [2499]
.long -3, 0x06444444			; delta_frames=3 [2502]
.long -3, 0x06555555			; delta_frames=3 [2505]
.long -3, 0x06666666			; delta_frames=3 [2508]
.long -2, 0x06777777			; delta_frames=2 [2510]
.long -3, 0x06888888			; delta_frames=3 [2513]
.long -3, 0x06999999			; delta_frames=3 [2516]
.long -3, 0x06aaaaaa			; delta_frames=3 [2519]
.long -3, 0x06999999			; delta_frames=3 [2522]
.long -3, 0x06888888			; delta_frames=3 [2525]
.long -3, 0x06777777			; delta_frames=3 [2528]
.long -3, 0x06666666			; delta_frames=3 [2531]
.long -2, 0x06555555			; delta_frames=2 [2533]
.long -3, 0x06444444			; delta_frames=3 [2536]
.long -3, 0x06333333			; delta_frames=3 [2539]
.long -3, 0x06444444			; delta_frames=3 [2542]
.long -3, 0x06555555			; delta_frames=3 [2545]
.long -3, 0x06666666			; delta_frames=3 [2548]
.long -2, 0x06777777			; delta_frames=2 [2550]
.long -3, 0x06888888			; delta_frames=3 [2553]
.long -3, 0x06999999			; delta_frames=3 [2556]
.long -3, 0x06aaaaaa			; delta_frames=3 [2559]
.long -3, 0x06999999			; delta_frames=3 [2562]
.long -3, 0x06888888			; delta_frames=3 [2565]
.long -3, 0x06777777			; delta_frames=3 [2568]
.long -3, 0x06666666			; delta_frames=3 [2571]
.long -2, 0x06555555			; delta_frames=2 [2573]
.long -3, 0x06444444			; delta_frames=3 [2576]
.long -3, 0x06333333			; delta_frames=3 [2579]
.long -3, 0x06444444			; delta_frames=3 [2582]
.long -3, 0x06555555			; delta_frames=3 [2585]
.long -3, 0x06666666			; delta_frames=3 [2588]
.long -2, 0x06777777			; delta_frames=2 [2590]
.long -3, 0x06888888			; delta_frames=3 [2593]
.long -3, 0x06999999			; delta_frames=3 [2596]
.long -3, 0x06aaaaaa			; delta_frames=3 [2599]
.long -3, 0x06999999			; delta_frames=3 [2602]
.long -3, 0x06888888			; delta_frames=3 [2605]
.long -3, 0x06777777			; delta_frames=3 [2608]
.long -3, 0x06666666			; delta_frames=3 [2611]
.long -2, 0x06555555			; delta_frames=2 [2613]
.long -3, 0x06444444			; delta_frames=3 [2616]
.long -3, 0x06333333			; delta_frames=3 [2619]
.long -3, 0x06444444			; delta_frames=3 [2622]
.long -3, 0x06555555			; delta_frames=3 [2625]
.long -3, 0x06666666			; delta_frames=3 [2628]
.long -2, 0x06777777			; delta_frames=2 [2630]
.long -3, 0x06888888			; delta_frames=3 [2633]
.long -3, 0x06999999			; delta_frames=3 [2636]
.long -3, 0x06aaaaaa			; delta_frames=3 [2639]
.long -3, 0x06999999			; delta_frames=3 [2642]
.long -3, 0x06888888			; delta_frames=3 [2645]
.long -3, 0x06777777			; delta_frames=3 [2648]
.long -3, 0x06666666			; delta_frames=3 [2651]
.long -2, 0x06555555			; delta_frames=2 [2653]
.long -3, 0x06444444			; delta_frames=3 [2656]
.long -3, 0x06333333			; delta_frames=3 [2659]
.long -3, 0x06444444			; delta_frames=3 [2662]
.long -3, 0x06555555			; delta_frames=3 [2665]
.long -3, 0x06666666			; delta_frames=3 [2668]
.long -2, 0x06777777			; delta_frames=2 [2670]
.long -3, 0x06888888			; delta_frames=3 [2673]
.long -3, 0x06999999			; delta_frames=3 [2676]
.long -3, 0x06aaaaaa			; delta_frames=3 [2679]
.long -3, 0x06999999			; delta_frames=3 [2682]
.long -3, 0x06888888			; delta_frames=3 [2685]
.long -3, 0x06777777			; delta_frames=3 [2688]
.long -3, 0x06666666			; delta_frames=3 [2691]
.long -2, 0x06555555			; delta_frames=2 [2693]
.long -3, 0x06444444			; delta_frames=3 [2696]
.long -3, 0x06333333			; delta_frames=3 [2699]
.long -3, 0x06444444			; delta_frames=3 [2702]
.long -3, 0x06555555			; delta_frames=3 [2705]
.long -3, 0x06666666			; delta_frames=3 [2708]
.long -2, 0x06777777			; delta_frames=2 [2710]
.long -3, 0x06888888			; delta_frames=3 [2713]
.long -3, 0x06999999			; delta_frames=3 [2716]
.long -3, 0x06aaaaaa			; delta_frames=3 [2719]
.long -3, 0x06999999			; delta_frames=3 [2722]
.long -3, 0x06888888			; delta_frames=3 [2725]
.long -3, 0x06777777			; delta_frames=3 [2728]
.long -3, 0x06666666			; delta_frames=3 [2731]
.long -2, 0x06555555			; delta_frames=2 [2733]
.long -3, 0x06444444			; delta_frames=3 [2736]
.long -3, 0x06333333			; delta_frames=3 [2739]
.long -3, 0x06444444			; delta_frames=3 [2742]
.long -3, 0x06555555			; delta_frames=3 [2745]
.long -3, 0x06666666			; delta_frames=3 [2748]
.long -2, 0x06777777			; delta_frames=2 [2750]
.long -3, 0x06888888			; delta_frames=3 [2753]
.long -3, 0x06999999			; delta_frames=3 [2756]
.long -3, 0x06aaaaaa			; delta_frames=3 [2759]
.long -3, 0x06999999			; delta_frames=3 [2762]
.long -3, 0x06888888			; delta_frames=3 [2765]
.long -3, 0x06777777			; delta_frames=3 [2768]
.long -3, 0x06666666			; delta_frames=3 [2771]
.long -2, 0x06555555			; delta_frames=2 [2773]
.long -3, 0x06444444			; delta_frames=3 [2776]
.long -3, 0x06333333			; delta_frames=3 [2779]
.long -21, 0x05666666, 0x06aaaaaa			; delta_frames=21 [2800]
.long -320, 0x00333333, 0x01777777, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=320 [3120]
.long -165, 0x01bb8844			; delta_frames=165 [3285]
.long -1, 0x01777777			; delta_frames=1 [3286]
.long -1, 0x01bb8844			; delta_frames=1 [3287]
.long -1, 0x01777777			; delta_frames=1 [3288]
.long -1, 0x01bb8844			; delta_frames=1 [3289]
.long -1, 0x01777777			; delta_frames=1 [3290]
.long -1, 0x01bb8844			; delta_frames=1 [3291]
.long -1, 0x01777777			; delta_frames=1 [3292]
.long -1, 0x01bb8844			; delta_frames=1 [3293]
.long -1, 0x01777777			; delta_frames=1 [3294]
.long -1, 0x01bb8844			; delta_frames=1 [3295]
.long -1, 0x01777777			; delta_frames=1 [3296]
.long -1, 0x01bb8844			; delta_frames=1 [3297]
.long -1, 0x01777777			; delta_frames=1 [3298]
.long -1, 0x01bb8844			; delta_frames=1 [3299]
.long -1, 0x01777777			; delta_frames=1 [3300]
.long -1, 0x01bb8844			; delta_frames=1 [3301]
.long -1, 0x01777777			; delta_frames=1 [3302]
.long -1, 0x01bb8844			; delta_frames=1 [3303]
.long -1, 0x01777777			; delta_frames=1 [3304]
.long -31, 0x00333333, 0x01444444, 0x02999999, 0x03777777, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=31 [3335]
.long -40, 0x03ffffff			; delta_frames=40 [3375]
.long -1, 0x03eeeeee			; delta_frames=1 [3376]
.long -1, 0x03dddddd			; delta_frames=1 [3377]
.long -2, 0x03cccccc			; delta_frames=2 [3379]
.long -1, 0x03bbbbbb			; delta_frames=1 [3380]
.long -1, 0x03aaaaaa			; delta_frames=1 [3381]
.long -1, 0x03999999			; delta_frames=1 [3382]
.long -2, 0x03888888			; delta_frames=2 [3384]
.long -1, 0x03777777			; delta_frames=1 [3385]
.long -70, 0x03ffffff			; delta_frames=70 [3455]
.long -1, 0x03eeeeee			; delta_frames=1 [3456]
.long -1, 0x03dddddd			; delta_frames=1 [3457]
.long -2, 0x03cccccc			; delta_frames=2 [3459]
.long -1, 0x03bbbbbb			; delta_frames=1 [3460]
.long -1, 0x03aaaaaa			; delta_frames=1 [3461]
.long -1, 0x03999999			; delta_frames=1 [3462]
.long -2, 0x03888888			; delta_frames=2 [3464]
.long -1, 0x03777777			; delta_frames=1 [3465]
.long -55, 0x03ffffff			; delta_frames=55 [3520]
.long -55, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=55 [3575]
.long -66, 0x01bb8844			; delta_frames=66 [3641]
.long -1, 0x01aa7744			; delta_frames=1 [3642]
.long -1, 0x01997744			; delta_frames=1 [3643]
.long -1, 0x01886644			; delta_frames=1 [3644]
.long -1, 0x01665544			; delta_frames=1 [3645]
.long -1, 0x01555544			; delta_frames=1 [3646]
.long -1, 0x01444444			; delta_frames=1 [3647]
.long -6, 0x01bb8844			; delta_frames=6 [3653]
.long -1, 0x01aa7744			; delta_frames=1 [3654]
.long -1, 0x01997744			; delta_frames=1 [3655]
.long -1, 0x01886644			; delta_frames=1 [3656]
.long -1, 0x01665544			; delta_frames=1 [3657]
.long -1, 0x01555544			; delta_frames=1 [3658]
.long -1, 0x01444444			; delta_frames=1 [3659]
.long -6, 0x01bb8844			; delta_frames=6 [3665]
.long -1, 0x01aa7744			; delta_frames=1 [3666]
.long -1, 0x01997744			; delta_frames=1 [3667]
.long -1, 0x01886644			; delta_frames=1 [3668]
.long -1, 0x01665544			; delta_frames=1 [3669]
.long -1, 0x01555544			; delta_frames=1 [3670]
.long -1, 0x01444444			; delta_frames=1 [3671]
.long -6, 0x01bb8844			; delta_frames=6 [3677]
.long -1, 0x01aa7744			; delta_frames=1 [3678]
.long -1, 0x01997744			; delta_frames=1 [3679]
.long -1, 0x01886644			; delta_frames=1 [3680]
.long -1, 0x01665544			; delta_frames=1 [3681]
.long -1, 0x01555544			; delta_frames=1 [3682]
.long -1, 0x01444444			; delta_frames=1 [3683]
.long -310, 0x00333333, 0x01777777, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=310 [3993]
.long -105, 0x01bb8844			; delta_frames=105 [4098]
.long -1, 0x01777777			; delta_frames=1 [4099]
.long -1, 0x01bb8844			; delta_frames=1 [4100]
.long -1, 0x01777777			; delta_frames=1 [4101]
.long -1, 0x01bb8844			; delta_frames=1 [4102]
.long -1, 0x01777777			; delta_frames=1 [4103]
.long -1, 0x01bb8844			; delta_frames=1 [4104]
.long -1, 0x01777777			; delta_frames=1 [4105]
.long -1, 0x01bb8844			; delta_frames=1 [4106]
.long -1, 0x01777777			; delta_frames=1 [4107]
.long -1, 0x01bb8844			; delta_frames=1 [4108]
.long -1, 0x01777777			; delta_frames=1 [4109]
.long -1, 0x01bb8844			; delta_frames=1 [4110]
.long -1, 0x01777777			; delta_frames=1 [4111]
.long -1, 0x01bb8844			; delta_frames=1 [4112]
.long -1, 0x01777777			; delta_frames=1 [4113]
.long -1, 0x01bb8844			; delta_frames=1 [4114]
.long -1, 0x01777777			; delta_frames=1 [4115]
.long -1, 0x01bb8844			; delta_frames=1 [4116]
.long -1, 0x01777777			; delta_frames=1 [4117]
.long -36, 0x00333333, 0x01444444, 0x02999999, 0x03777777, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=36 [4153]
.long -40, 0x03ffffff			; delta_frames=40 [4193]
.long -1, 0x03eeeeee			; delta_frames=1 [4194]
.long -1, 0x03dddddd			; delta_frames=1 [4195]
.long -2, 0x03cccccc			; delta_frames=2 [4197]
.long -1, 0x03bbbbbb			; delta_frames=1 [4198]
.long -1, 0x03aaaaaa			; delta_frames=1 [4199]
.long -1, 0x03999999			; delta_frames=1 [4200]
.long -2, 0x03888888			; delta_frames=2 [4202]
.long -1, 0x03777777			; delta_frames=1 [4203]
.long -70, 0x03ffffff			; delta_frames=70 [4273]
.long -1, 0x03eeeeee			; delta_frames=1 [4274]
.long -1, 0x03dddddd			; delta_frames=1 [4275]
.long -2, 0x03cccccc			; delta_frames=2 [4277]
.long -1, 0x03bbbbbb			; delta_frames=1 [4278]
.long -1, 0x03aaaaaa			; delta_frames=1 [4279]
.long -1, 0x03999999			; delta_frames=1 [4280]
.long -2, 0x03888888			; delta_frames=2 [4282]
.long -1, 0x03777777			; delta_frames=1 [4283]
.long -55, 0x03ffffff			; delta_frames=55 [4338]
.long -55, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=55 [4393]
.long -280, 0x01bb8844			; delta_frames=280 [4673]
.long -1, 0x01777777			; delta_frames=1 [4674]
.long -1, 0x01bb8844			; delta_frames=1 [4675]
.long -1, 0x01777777			; delta_frames=1 [4676]
.long -1, 0x01bb8844			; delta_frames=1 [4677]
.long -1, 0x01777777			; delta_frames=1 [4678]
.long -1, 0x01bb8844			; delta_frames=1 [4679]
.long -1, 0x01777777			; delta_frames=1 [4680]
.long -1, 0x01bb8844			; delta_frames=1 [4681]
.long -1, 0x01777777			; delta_frames=1 [4682]
.long -1, 0x01bb8844			; delta_frames=1 [4683]
.long -1, 0x01777777			; delta_frames=1 [4684]
.long -1, 0x01bb8844			; delta_frames=1 [4685]
.long -1, 0x01777777			; delta_frames=1 [4686]
.long -1, 0x01bb8844			; delta_frames=1 [4687]
.long -1, 0x01777777			; delta_frames=1 [4688]
.long -1, 0x01bb8844			; delta_frames=1 [4689]
.long -1, 0x01777777			; delta_frames=1 [4690]
.long -1, 0x01bb8844			; delta_frames=1 [4691]
.long -1, 0x01777777			; delta_frames=1 [4692]
.long -701, 0x00333333, 0x01777777, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=701 [5393]
.long -160, 0x01bb8844			; delta_frames=160 [5553]
.long -1, 0x01777777			; delta_frames=1 [5554]
.long -1, 0x01bb8844			; delta_frames=1 [5555]
.long -1, 0x01777777			; delta_frames=1 [5556]
.long -1, 0x01bb8844			; delta_frames=1 [5557]
.long -1, 0x01777777			; delta_frames=1 [5558]
.long -1, 0x01bb8844			; delta_frames=1 [5559]
.long -1, 0x01777777			; delta_frames=1 [5560]
.long -1, 0x01bb8844			; delta_frames=1 [5561]
.long -1, 0x01777777			; delta_frames=1 [5562]
.long -1, 0x01bb8844			; delta_frames=1 [5563]
.long -1, 0x01777777			; delta_frames=1 [5564]
.long -1, 0x01bb8844			; delta_frames=1 [5565]
.long -1, 0x01777777			; delta_frames=1 [5566]
.long -1, 0x01bb8844			; delta_frames=1 [5567]
.long -1, 0x01777777			; delta_frames=1 [5568]
.long -1, 0x01bb8844			; delta_frames=1 [5569]
.long -1, 0x01777777			; delta_frames=1 [5570]
.long -1, 0x01bb8844			; delta_frames=1 [5571]
.long -1, 0x01777777			; delta_frames=1 [5572]
.long -61, 0x00333333, 0x01444444, 0x02999999, 0x03777777, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=61 [5633]
.long -40, 0x03ffffff			; delta_frames=40 [5673]
.long -1, 0x03eeeeee			; delta_frames=1 [5674]
.long -1, 0x03dddddd			; delta_frames=1 [5675]
.long -2, 0x03cccccc			; delta_frames=2 [5677]
.long -1, 0x03bbbbbb			; delta_frames=1 [5678]
.long -1, 0x03aaaaaa			; delta_frames=1 [5679]
.long -1, 0x03999999			; delta_frames=1 [5680]
.long -2, 0x03888888			; delta_frames=2 [5682]
.long -1, 0x03777777			; delta_frames=1 [5683]
.long -70, 0x03ffffff			; delta_frames=70 [5753]
.long -1, 0x03eeeeee			; delta_frames=1 [5754]
.long -1, 0x03dddddd			; delta_frames=1 [5755]
.long -2, 0x03cccccc			; delta_frames=2 [5757]
.long -1, 0x03bbbbbb			; delta_frames=1 [5758]
.long -1, 0x03aaaaaa			; delta_frames=1 [5759]
.long -1, 0x03999999			; delta_frames=1 [5760]
.long -2, 0x03888888			; delta_frames=2 [5762]
.long -1, 0x03777777			; delta_frames=1 [5763]
.long -55, 0x03ffffff			; delta_frames=55 [5818]
.long -55, 0x01777777			; delta_frames=55 [5873]
.long -1360, 0x0122ff33			; delta_frames=1360 [7233]
.long -1, 0x0133dd44			; delta_frames=1 [7234]
.long -1, 0x0144cc55			; delta_frames=1 [7235]
.long -1, 0x0155aa55			; delta_frames=1 [7236]
.long -1, 0x01669966			; delta_frames=1 [7237]
.long -1, 0x01777777			; delta_frames=1 [7238]
.long -5, 0x0122ff33			; delta_frames=5 [7243]
.long -1, 0x0133dd44			; delta_frames=1 [7244]
.long -1, 0x0144cc55			; delta_frames=1 [7245]
.long -1, 0x0155aa55			; delta_frames=1 [7246]
.long -1, 0x01669966			; delta_frames=1 [7247]
.long -1, 0x01777777			; delta_frames=1 [7248]
.long -5, 0x0122ff33			; delta_frames=5 [7253]
.long -1, 0x0133dd44			; delta_frames=1 [7254]
.long -1, 0x0144cc55			; delta_frames=1 [7255]
.long -1, 0x0155aa55			; delta_frames=1 [7256]
.long -1, 0x01669966			; delta_frames=1 [7257]
.long -1, 0x01777777			; delta_frames=1 [7258]
.long -5, 0x0122ff33			; delta_frames=5 [7263]
.long -1, 0x0133dd44			; delta_frames=1 [7264]
.long -1, 0x0144cc55			; delta_frames=1 [7265]
.long -1, 0x0155aa55			; delta_frames=1 [7266]
.long -1, 0x01669966			; delta_frames=1 [7267]
.long -1, 0x01777777			; delta_frames=1 [7268]
.long -5, 0x0122ff33			; delta_frames=5 [7273]
.long -1, 0x0133dd44			; delta_frames=1 [7274]
.long -1, 0x0144cc55			; delta_frames=1 [7275]
.long -1, 0x0155aa55			; delta_frames=1 [7276]
.long -1, 0x01669966			; delta_frames=1 [7277]
.long -1, 0x01777777			; delta_frames=1 [7278]
.long -115, 0x00333333, 0x01777777, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=115 [7393]
.long -130, 0x01bb8844			; delta_frames=130 [7523]
.long -1, 0x01777777			; delta_frames=1 [7524]
.long -1, 0x01bb8844			; delta_frames=1 [7525]
.long -1, 0x01777777			; delta_frames=1 [7526]
.long -1, 0x01bb8844			; delta_frames=1 [7527]
.long -1, 0x01777777			; delta_frames=1 [7528]
.long -1, 0x01bb8844			; delta_frames=1 [7529]
.long -1, 0x01777777			; delta_frames=1 [7530]
.long -1, 0x01bb8844			; delta_frames=1 [7531]
.long -1, 0x01777777			; delta_frames=1 [7532]
.long -1, 0x01bb8844			; delta_frames=1 [7533]
.long -1, 0x01777777			; delta_frames=1 [7534]
.long -1, 0x01bb8844			; delta_frames=1 [7535]
.long -1, 0x01777777			; delta_frames=1 [7536]
.long -1, 0x01bb8844			; delta_frames=1 [7537]
.long -1, 0x01777777			; delta_frames=1 [7538]
.long -1, 0x01bb8844			; delta_frames=1 [7539]
.long -1, 0x01777777			; delta_frames=1 [7540]
.long -1, 0x01bb8844			; delta_frames=1 [7541]
.long -1, 0x01777777			; delta_frames=1 [7542]
.long -51, 0x00333333, 0x01444444, 0x02999999, 0x03777777, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=51 [7593]
.long -40, 0x03ffffff			; delta_frames=40 [7633]
.long -1, 0x03eeeeee			; delta_frames=1 [7634]
.long -1, 0x03dddddd			; delta_frames=1 [7635]
.long -2, 0x03cccccc			; delta_frames=2 [7637]
.long -1, 0x03bbbbbb			; delta_frames=1 [7638]
.long -1, 0x03aaaaaa			; delta_frames=1 [7639]
.long -1, 0x03999999			; delta_frames=1 [7640]
.long -2, 0x03888888			; delta_frames=2 [7642]
.long -1, 0x03777777			; delta_frames=1 [7643]
.long -70, 0x03ffffff			; delta_frames=70 [7713]
.long -1, 0x03eeeeee			; delta_frames=1 [7714]
.long -1, 0x03dddddd			; delta_frames=1 [7715]
.long -2, 0x03cccccc			; delta_frames=2 [7717]
.long -1, 0x03bbbbbb			; delta_frames=1 [7718]
.long -1, 0x03aaaaaa			; delta_frames=1 [7719]
.long -1, 0x03999999			; delta_frames=1 [7720]
.long -2, 0x03888888			; delta_frames=2 [7722]
.long -1, 0x03777777			; delta_frames=1 [7723]
.long -55, 0x03ffffff			; delta_frames=55 [7778]
.long -55, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc, 0x06777777			; delta_frames=55 [7833]
.long -270, 0x01bb8844			; delta_frames=270 [8103]
.long -1, 0x01777777			; delta_frames=1 [8104]
.long -1, 0x01bb8844			; delta_frames=1 [8105]
.long -1, 0x01777777			; delta_frames=1 [8106]
.long -1, 0x01bb8844			; delta_frames=1 [8107]
.long -1, 0x01777777			; delta_frames=1 [8108]
.long -1, 0x01bb8844			; delta_frames=1 [8109]
.long -1, 0x01777777			; delta_frames=1 [8110]
.long -1, 0x01bb8844			; delta_frames=1 [8111]
.long -1, 0x01777777			; delta_frames=1 [8112]
.long -1, 0x01bb8844			; delta_frames=1 [8113]
.long -1, 0x01777777			; delta_frames=1 [8114]
.long -1, 0x01bb8844			; delta_frames=1 [8115]
.long -1, 0x01777777			; delta_frames=1 [8116]
.long -1, 0x01bb8844			; delta_frames=1 [8117]
.long -1, 0x01777777			; delta_frames=1 [8118]
.long -1, 0x01bb8844			; delta_frames=1 [8119]
.long -1, 0x01777777			; delta_frames=1 [8120]
.long -1, 0x01bb8844			; delta_frames=1 [8121]
.long -1, 0x01777777			; delta_frames=1 [8122]
.long -1, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc, 0x06777777			; delta_frames=1 [8123]
.long -430, 0x01bb8844			; delta_frames=430 [8553]
.long -1, 0x01777777			; delta_frames=1 [8554]
.long -1, 0x01bb8844			; delta_frames=1 [8555]
.long -1, 0x01777777			; delta_frames=1 [8556]
.long -1, 0x01bb8844			; delta_frames=1 [8557]
.long -1, 0x01777777			; delta_frames=1 [8558]
.long -1, 0x01bb8844			; delta_frames=1 [8559]
.long -1, 0x01777777			; delta_frames=1 [8560]
.long -1, 0x01bb8844			; delta_frames=1 [8561]
.long -1, 0x01777777			; delta_frames=1 [8562]
.long -1, 0x01bb8844			; delta_frames=1 [8563]
.long -1, 0x01777777			; delta_frames=1 [8564]
.long -1, 0x01bb8844			; delta_frames=1 [8565]
.long -1, 0x01777777			; delta_frames=1 [8566]
.long -1, 0x01bb8844			; delta_frames=1 [8567]
.long -1, 0x01777777			; delta_frames=1 [8568]
.long -1, 0x01bb8844			; delta_frames=1 [8569]
.long -1, 0x01777777			; delta_frames=1 [8570]
.long -1, 0x01bb8844			; delta_frames=1 [8571]
.long -1, 0x01777777			; delta_frames=1 [8572]
.long -1, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc, 0x06777777			; delta_frames=1 [8573]
.long -380, 0x0622ff33			; delta_frames=380 [8953]
.long -1, 0x0633dd44			; delta_frames=1 [8954]
.long -1, 0x0644cc55			; delta_frames=1 [8955]
.long -1, 0x0655aa55			; delta_frames=1 [8956]
.long -1, 0x06669966			; delta_frames=1 [8957]
.long -1, 0x06777777			; delta_frames=1 [8958]
.long -5, 0x0622ff33			; delta_frames=5 [8963]
.long -1, 0x0633dd44			; delta_frames=1 [8964]
.long -1, 0x0644cc55			; delta_frames=1 [8965]
.long -1, 0x0655aa55			; delta_frames=1 [8966]
.long -1, 0x06669966			; delta_frames=1 [8967]
.long -1, 0x06777777			; delta_frames=1 [8968]
.long -5, 0x0622ff33			; delta_frames=5 [8973]
.long -1, 0x0633dd44			; delta_frames=1 [8974]
.long -1, 0x0644cc55			; delta_frames=1 [8975]
.long -1, 0x0655aa55			; delta_frames=1 [8976]
.long -1, 0x06669966			; delta_frames=1 [8977]
.long -1, 0x06777777			; delta_frames=1 [8978]
.long -5, 0x0622ff33			; delta_frames=5 [8983]
.long -1, 0x0633dd44			; delta_frames=1 [8984]
.long -1, 0x0644cc55			; delta_frames=1 [8985]
.long -1, 0x0655aa55			; delta_frames=1 [8986]
.long -1, 0x06669966			; delta_frames=1 [8987]
.long -1, 0x06777777			; delta_frames=1 [8988]
.long -5, 0x0622ff33			; delta_frames=5 [8993]
.long -1, 0x0633dd44			; delta_frames=1 [8994]
.long -1, 0x0644cc55			; delta_frames=1 [8995]
.long -1, 0x0655aa55			; delta_frames=1 [8996]
.long -1, 0x06669966			; delta_frames=1 [8997]
.long -1, 0x06777777			; delta_frames=1 [8998]
.long -115, 0x00333333, 0x01777777, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=115 [9113]
.long -100, 0x01bb8844			; delta_frames=100 [9213]
.long -1, 0x01777777			; delta_frames=1 [9214]
.long -1, 0x01bb8844			; delta_frames=1 [9215]
.long -1, 0x01777777			; delta_frames=1 [9216]
.long -1, 0x01bb8844			; delta_frames=1 [9217]
.long -1, 0x01777777			; delta_frames=1 [9218]
.long -1, 0x01bb8844			; delta_frames=1 [9219]
.long -1, 0x01777777			; delta_frames=1 [9220]
.long -1, 0x01bb8844			; delta_frames=1 [9221]
.long -1, 0x01777777			; delta_frames=1 [9222]
.long -1, 0x01bb8844			; delta_frames=1 [9223]
.long -1, 0x01777777			; delta_frames=1 [9224]
.long -1, 0x01bb8844			; delta_frames=1 [9225]
.long -1, 0x01777777			; delta_frames=1 [9226]
.long -1, 0x01bb8844			; delta_frames=1 [9227]
.long -1, 0x01777777			; delta_frames=1 [9228]
.long -1, 0x01bb8844			; delta_frames=1 [9229]
.long -1, 0x01777777			; delta_frames=1 [9230]
.long -1, 0x01bb8844			; delta_frames=1 [9231]
.long -1, 0x01777777			; delta_frames=1 [9232]
.long -41, 0x00333333, 0x01444444, 0x02999999, 0x03777777, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=41 [9273]
.long -40, 0x03ffffff			; delta_frames=40 [9313]
.long -1, 0x03eeeeee			; delta_frames=1 [9314]
.long -1, 0x03dddddd			; delta_frames=1 [9315]
.long -2, 0x03cccccc			; delta_frames=2 [9317]
.long -1, 0x03bbbbbb			; delta_frames=1 [9318]
.long -1, 0x03aaaaaa			; delta_frames=1 [9319]
.long -1, 0x03999999			; delta_frames=1 [9320]
.long -2, 0x03888888			; delta_frames=2 [9322]
.long -1, 0x03777777			; delta_frames=1 [9323]
.long -70, 0x03ffffff			; delta_frames=70 [9393]
.long -1, 0x03eeeeee			; delta_frames=1 [9394]
.long -1, 0x03dddddd			; delta_frames=1 [9395]
.long -2, 0x03cccccc			; delta_frames=2 [9397]
.long -1, 0x03bbbbbb			; delta_frames=1 [9398]
.long -1, 0x03aaaaaa			; delta_frames=1 [9399]
.long -1, 0x03999999			; delta_frames=1 [9400]
.long -2, 0x03888888			; delta_frames=2 [9402]
.long -1, 0x03777777			; delta_frames=1 [9403]
.long -70, 0x03ffffff			; delta_frames=70 [9473]
.long -1, 0x03eeeeee			; delta_frames=1 [9474]
.long -1, 0x03dddddd			; delta_frames=1 [9475]
.long -2, 0x03cccccc			; delta_frames=2 [9477]
.long -1, 0x03bbbbbb			; delta_frames=1 [9478]
.long -1, 0x03aaaaaa			; delta_frames=1 [9479]
.long -1, 0x03999999			; delta_frames=1 [9480]
.long -2, 0x03888888			; delta_frames=2 [9482]
.long -1, 0x03777777			; delta_frames=1 [9483]
.long -55, 0x03ffffff			; delta_frames=55 [9538]
.long -55, 0x06777777			; delta_frames=55 [9593]
.long -1480, 0x0622ff33			; delta_frames=1480 [11073]
.long -1, 0x0633dd44			; delta_frames=1 [11074]
.long -1, 0x0644cc55			; delta_frames=1 [11075]
.long -1, 0x0655aa55			; delta_frames=1 [11076]
.long -1, 0x06669966			; delta_frames=1 [11077]
.long -1, 0x06777777			; delta_frames=1 [11078]
.long -5, 0x0622ff33			; delta_frames=5 [11083]
.long -1, 0x0633dd44			; delta_frames=1 [11084]
.long -1, 0x0644cc55			; delta_frames=1 [11085]
.long -1, 0x0655aa55			; delta_frames=1 [11086]
.long -1, 0x06669966			; delta_frames=1 [11087]
.long -1, 0x06777777			; delta_frames=1 [11088]
.long -5, 0x0622ff33			; delta_frames=5 [11093]
.long -1, 0x0633dd44			; delta_frames=1 [11094]
.long -1, 0x0644cc55			; delta_frames=1 [11095]
.long -1, 0x0655aa55			; delta_frames=1 [11096]
.long -1, 0x06669966			; delta_frames=1 [11097]
.long -1, 0x06777777			; delta_frames=1 [11098]
.long -5, 0x0622ff33			; delta_frames=5 [11103]
.long -1, 0x0633dd44			; delta_frames=1 [11104]
.long -1, 0x0644cc55			; delta_frames=1 [11105]
.long -1, 0x0655aa55			; delta_frames=1 [11106]
.long -1, 0x06669966			; delta_frames=1 [11107]
.long -1, 0x06777777			; delta_frames=1 [11108]
.long -5, 0x0622ff33			; delta_frames=5 [11113]
.long -1, 0x0633dd44			; delta_frames=1 [11114]
.long -1, 0x0644cc55			; delta_frames=1 [11115]
.long -1, 0x0655aa55			; delta_frames=1 [11116]
.long -1, 0x06669966			; delta_frames=1 [11117]
.long -1, 0x06777777			; delta_frames=1 [11118]
.long -115, 0x00333333, 0x01777777, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=115 [11233]
.long -100, 0x01bb8844			; delta_frames=100 [11333]
.long -1, 0x01777777			; delta_frames=1 [11334]
.long -1, 0x01bb8844			; delta_frames=1 [11335]
.long -1, 0x01777777			; delta_frames=1 [11336]
.long -1, 0x01bb8844			; delta_frames=1 [11337]
.long -1, 0x01777777			; delta_frames=1 [11338]
.long -1, 0x01bb8844			; delta_frames=1 [11339]
.long -1, 0x01777777			; delta_frames=1 [11340]
.long -1, 0x01bb8844			; delta_frames=1 [11341]
.long -1, 0x01777777			; delta_frames=1 [11342]
.long -1, 0x01bb8844			; delta_frames=1 [11343]
.long -1, 0x01777777			; delta_frames=1 [11344]
.long -1, 0x01bb8844			; delta_frames=1 [11345]
.long -1, 0x01777777			; delta_frames=1 [11346]
.long -1, 0x01bb8844			; delta_frames=1 [11347]
.long -1, 0x01777777			; delta_frames=1 [11348]
.long -1, 0x01bb8844			; delta_frames=1 [11349]
.long -1, 0x01777777			; delta_frames=1 [11350]
.long -1, 0x01bb8844			; delta_frames=1 [11351]
.long -1, 0x01777777			; delta_frames=1 [11352]
.long -41, 0x00333333, 0x01444444, 0x02999999, 0x03777777, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc			; delta_frames=41 [11393]
.long -40, 0x03ffffff			; delta_frames=40 [11433]
.long -1, 0x03eeeeee			; delta_frames=1 [11434]
.long -1, 0x03dddddd			; delta_frames=1 [11435]
.long -2, 0x03cccccc			; delta_frames=2 [11437]
.long -1, 0x03bbbbbb			; delta_frames=1 [11438]
.long -1, 0x03aaaaaa			; delta_frames=1 [11439]
.long -1, 0x03999999			; delta_frames=1 [11440]
.long -2, 0x03888888			; delta_frames=2 [11442]
.long -1, 0x03777777			; delta_frames=1 [11443]
.long -70, 0x03ffffff			; delta_frames=70 [11513]
.long -1, 0x03eeeeee			; delta_frames=1 [11514]
.long -1, 0x03dddddd			; delta_frames=1 [11515]
.long -2, 0x03cccccc			; delta_frames=2 [11517]
.long -1, 0x03bbbbbb			; delta_frames=1 [11518]
.long -1, 0x03aaaaaa			; delta_frames=1 [11519]
.long -1, 0x03999999			; delta_frames=1 [11520]
.long -2, 0x03888888			; delta_frames=2 [11522]
.long -1, 0x03777777			; delta_frames=1 [11523]
.long -55, 0x03ffffff			; delta_frames=55 [11578]
.long -485, 0x01bb8844			; delta_frames=485 [12063]
.long -1, 0x01777777			; delta_frames=1 [12064]
.long -1, 0x01bb8844			; delta_frames=1 [12065]
.long -1, 0x01777777			; delta_frames=1 [12066]
.long -1, 0x01bb8844			; delta_frames=1 [12067]
.long -1, 0x01777777			; delta_frames=1 [12068]
.long -1, 0x01bb8844			; delta_frames=1 [12069]
.long -1, 0x01777777			; delta_frames=1 [12070]
.long -1, 0x01bb8844			; delta_frames=1 [12071]
.long -1, 0x01777777			; delta_frames=1 [12072]
.long -1, 0x01bb8844			; delta_frames=1 [12073]
.long -1, 0x01777777			; delta_frames=1 [12074]
.long -1, 0x01bb8844			; delta_frames=1 [12075]
.long -1, 0x01777777			; delta_frames=1 [12076]
.long -1, 0x01bb8844			; delta_frames=1 [12077]
.long -1, 0x01777777			; delta_frames=1 [12078]
.long -1, 0x01bb8844			; delta_frames=1 [12079]
.long -1, 0x01777777			; delta_frames=1 [12080]
.long -1, 0x01bb8844			; delta_frames=1 [12081]
.long -1, 0x01777777			; delta_frames=1 [12082]
.long -1, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc, 0x06777777			; delta_frames=1 [12083]
.long -390, 0x01aa1155			; delta_frames=390 [12473]
.long -5, 0x01aa11aa			; delta_frames=5 [12478]
.long -5, 0x01554488			; delta_frames=5 [12483]
.long -5, 0x01ff1122			; delta_frames=5 [12488]
.long -5, 0x01aa66ff			; delta_frames=5 [12493]
.long -5, 0x01aa4466			; delta_frames=5 [12498]
.long -5, 0x01662244			; delta_frames=5 [12503]
.long -5, 0x01aa1155			; delta_frames=5 [12508]
.long -5, 0x01aa11aa			; delta_frames=5 [12513]
.long -5, 0x01554488			; delta_frames=5 [12518]
.long -5, 0x01ff1122			; delta_frames=5 [12523]
.long -5, 0x01aa66ff			; delta_frames=5 [12528]
.long -5, 0x01aa4466			; delta_frames=5 [12533]
.long -5, 0x01662244			; delta_frames=5 [12538]
.long -5, 0x01555555			; delta_frames=5 [12543]
.long -50, 0x01bb8844			; delta_frames=50 [12593]
.long -1, 0x01777777			; delta_frames=1 [12594]
.long -1, 0x01bb8844			; delta_frames=1 [12595]
.long -1, 0x01777777			; delta_frames=1 [12596]
.long -1, 0x01bb8844			; delta_frames=1 [12597]
.long -1, 0x01777777			; delta_frames=1 [12598]
.long -1, 0x01bb8844			; delta_frames=1 [12599]
.long -1, 0x01777777			; delta_frames=1 [12600]
.long -1, 0x01bb8844			; delta_frames=1 [12601]
.long -1, 0x01777777			; delta_frames=1 [12602]
.long -1, 0x01bb8844			; delta_frames=1 [12603]
.long -1, 0x01777777			; delta_frames=1 [12604]
.long -1, 0x01bb8844			; delta_frames=1 [12605]
.long -1, 0x01777777			; delta_frames=1 [12606]
.long -1, 0x01bb8844			; delta_frames=1 [12607]
.long -1, 0x01777777			; delta_frames=1 [12608]
.long -1, 0x01bb8844			; delta_frames=1 [12609]
.long -1, 0x01777777			; delta_frames=1 [12610]
.long -1, 0x01bb8844			; delta_frames=1 [12611]
.long -1, 0x01777777			; delta_frames=1 [12612]
.long -1, 0x00333333, 0x01444444, 0x02999999, 0x03ffffff, 0x04000000, 0x05666666, 0x06aaaaaa, 0x07cccccc, 0x06777777			; delta_frames=1 [12613]
.long -340, 0x01aa1155			; delta_frames=340 [12953]
.long -5, 0x01aa11aa			; delta_frames=5 [12958]
.long -5, 0x01554488			; delta_frames=5 [12963]
.long -5, 0x01ff1122			; delta_frames=5 [12968]
.long -5, 0x01aa66ff			; delta_frames=5 [12973]
.long -5, 0x01aa4466			; delta_frames=5 [12978]
.long -5, 0x01662244			; delta_frames=5 [12983]
.long -5, 0x01aa1155			; delta_frames=5 [12988]
.long -5, 0x01aa11aa			; delta_frames=5 [12993]
.long -5, 0x01554488			; delta_frames=5 [12998]
.long -5, 0x01ff1122			; delta_frames=5 [13003]
.long -5, 0x01aa66ff			; delta_frames=5 [13008]
.long -5, 0x01aa4466			; delta_frames=5 [13013]
.long -5, 0x01662244			; delta_frames=5 [13018]
.long -5, 0x01554488			; delta_frames=5 [13023]
.long -5, 0x01ff1122			; delta_frames=5 [13028]
.long -5, 0x01555555			; delta_frames=5 [13033]
.long -541, 0x00444444, 0x04111111			; delta_frames=541 [13574]
.long -1, 0x01666666, 0x02aaaaaa, 0x05777777, 0x06888888			; delta_frames=1 [13575]
.long -1, 0x00555555, 0x04222222			; delta_frames=1 [13576]
.long -1, 0x01777777, 0x04333333, 0x05888888, 0x06999999, 0x07dddddd			; delta_frames=1 [13577]
.long -1, 0x00666666, 0x01888888, 0x02bbbbbb, 0x04444444			; delta_frames=1 [13578]
.long -1, 0x00777777, 0x05999999			; delta_frames=1 [13579]
.long -1, 0x04555555, 0x06aaaaaa			; delta_frames=1 [13580]
.long -1, 0x00888888, 0x01999999, 0x04666666, 0x05aaaaaa			; delta_frames=1 [13581]
.long -1, 0x02cccccc, 0x04777777, 0x06bbbbbb			; delta_frames=1 [13582]
.long -1, 0x00999999, 0x01aaaaaa, 0x04888888, 0x05bbbbbb, 0x07eeeeee			; delta_frames=1 [13583]
.long -1, 0x00aaaaaa			; delta_frames=1 [13584]
.long -1, 0x01bbbbbb, 0x02dddddd, 0x04999999, 0x06cccccc			; delta_frames=1 [13585]
.long -1, 0x00bbbbbb, 0x04aaaaaa, 0x05cccccc			; delta_frames=1 [13586]
.long -1, 0x01cccccc, 0x06dddddd			; delta_frames=1 [13587]
.long -1, 0x00cccccc, 0x01dddddd, 0x02eeeeee, 0x04bbbbbb, 0x05dddddd			; delta_frames=1 [13588]
.long -1, 0x00dddddd, 0x04cccccc			; delta_frames=1 [13589]
.long -1, 0x04dddddd, 0x05eeeeee, 0x06eeeeee, 0x07ffffff			; delta_frames=1 [13590]
.long -1, 0x00eeeeee, 0x01eeeeee			; delta_frames=1 [13591]
.long -1, 0x02ffffff, 0x04eeeeee, 0x05ffffff, 0x06ffffff			; delta_frames=1 [13592]
.long -1, 0x00ffffff, 0x01ffffff, 0x04ffffff			; delta_frames=1 [13593]
.long -1, 0x00000000, 0x01000000, 0x02000000, 0x03000000, 0x04000000, 0x05000000, 0x06000000, 0x07000000			; delta_frames=1 [13594]
.long -169, 0x03111111, 0x07111111			; delta_frames=169 [13763]
.long -4, 0x06111111			; delta_frames=4 [13767]
.long -3, 0x03222222, 0x07222222			; delta_frames=3 [13770]
.long -2, 0x05111111			; delta_frames=2 [13772]
.long -4, 0x01111111, 0x03333333, 0x07333333			; delta_frames=4 [13776]
.long -5, 0x06222222			; delta_frames=5 [13781]
.long -2, 0x03444444, 0x07444444			; delta_frames=2 [13783]
.long -1, 0x02111111			; delta_frames=1 [13784]
.long -6, 0x03555555, 0x07555555			; delta_frames=6 [13790]
.long -5, 0x06333333			; delta_frames=5 [13795]
.long -1, 0x03666666, 0x07666666			; delta_frames=1 [13796]
.long -1, 0x05222222			; delta_frames=1 [13797]
.long -6, 0x03777777, 0x07777777			; delta_frames=6 [13803]
.long -6, 0x01222222, 0x03888888, 0x06444444, 0x07888888			; delta_frames=6 [13809]
.long -7, 0x03999999, 0x07999999			; delta_frames=7 [13816]
.long -6, 0x05333333			; delta_frames=6 [13822]
.long -1, 0x03aaaaaa, 0x07aaaaaa			; delta_frames=1 [13823]
.long -1, 0x06555555			; delta_frames=1 [13824]
.long -6, 0x03bbbbbb, 0x07bbbbbb			; delta_frames=6 [13830]
.long -4, 0x02222222			; delta_frames=4 [13834]
.long -2, 0x03cccccc, 0x07cccccc			; delta_frames=2 [13836]
.long -2, 0x06666666			; delta_frames=2 [13838]
.long -5, 0x01333333, 0x03dddddd, 0x07dddddd			; delta_frames=5 [13843]
.long -4, 0x05444444			; delta_frames=4 [13847]
.long -3, 0x03eeeeee, 0x07eeeeee			; delta_frames=3 [13850]
.long -2, 0x06777777			; delta_frames=2 [13852]
.long -4, 0x03ffffff, 0x07ffffff			; delta_frames=4 [13856]
.long -367, 0x03eeeeee, 0x07eeeeee			; delta_frames=367 [14223]
.long -4, 0x06666666			; delta_frames=4 [14227]
.long -3, 0x03dddddd, 0x07dddddd			; delta_frames=3 [14230]
.long -2, 0x05333333			; delta_frames=2 [14232]
.long -4, 0x01222222, 0x03cccccc, 0x07cccccc			; delta_frames=4 [14236]
.long -5, 0x06555555			; delta_frames=5 [14241]
.long -2, 0x03bbbbbb, 0x07bbbbbb			; delta_frames=2 [14243]
.long -2, 0x02111111			; delta_frames=2 [14245]
.long -5, 0x03aaaaaa, 0x07aaaaaa			; delta_frames=5 [14250]
.long -5, 0x06444444			; delta_frames=5 [14255]
.long -1, 0x03999999, 0x07999999			; delta_frames=1 [14256]
.long -1, 0x05222222			; delta_frames=1 [14257]
.long -6, 0x03888888, 0x07888888			; delta_frames=6 [14263]
.long -7, 0x01111111, 0x03777777, 0x06333333, 0x07777777			; delta_frames=7 [14270]
.long -6, 0x03666666, 0x07666666			; delta_frames=6 [14276]
.long -6, 0x05111111			; delta_frames=6 [14282]
.long -1, 0x03555555, 0x07555555			; delta_frames=1 [14283]
.long -1, 0x06222222			; delta_frames=1 [14284]
.long -6, 0x03444444, 0x07444444			; delta_frames=6 [14290]
.long -5, 0x02000000			; delta_frames=5 [14295]
.long -1, 0x03333333, 0x07333333			; delta_frames=1 [14296]
.long -2, 0x06111111			; delta_frames=2 [14298]
.long -5, 0x01000000, 0x03222222, 0x07222222			; delta_frames=5 [14303]
.long -4, 0x05000000			; delta_frames=4 [14307]
.long -3, 0x03111111, 0x07111111			; delta_frames=3 [14310]
.long -2, 0x06000000			; delta_frames=2 [14312]
.long -4, 0x03000000, 0x07000000			; delta_frames=4 [14316]
.long 0x80000000	; END_SCRIPT.
