; ============================================================================
; rose2arc.py
; input = examples/waytoorude/bytecodes.bin.
; ============================================================================

.equ ST_PROC, 0
.equ ST_X, 1
.equ ST_Y, 2
.equ ST_SIZE, 3
.equ ST_TINT, 4
.equ ST_RAND, 5
.equ ST_DIR, 6
.equ ST_TIME, 7
.equ ST_WIRE0, 8
.equ ST_WIRE1, 9
.equ ST_WIRE2, 10
.equ ST_WIRE3, 11
.equ ST_WIRE4, 12
.equ ST_WIRE5, 13
.equ ST_WIRE6, 14
.equ ST_WIRE7, 15

; ============================================================================
; r3 = p_StateStack.
; r4 = r_Constants.
; r5 = p_State.
; r6 = <temp>           ; r_StateSpace.
; r7 = r_Sinus.
; ============================================================================

proc_0_start:
	; BC_PROC [07]
	adr r0, proc_19_start		; r0=r_Procedures[19]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_0
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_0:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_1
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_1:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_2
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_2:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_3
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_3:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_4
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_4:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_5
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_5:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_6
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_6:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_7
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_7:
	; BC_PROC [07]
	adr r0, proc_50_start		; r0=r_Procedures[50]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_8
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_8:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_9
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_9:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_10
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_10:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_11
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_11:
	; BC_PROC [07]
	adr r0, proc_114_start		; r0=r_Procedures[114]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_12
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_12:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_13
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_13:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_14
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_14:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_15
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_15:
	; BC_PROC [07]
	adr r0, proc_141_start		; r0=r_Procedures[141]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_16
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_16:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_17
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_17:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_18
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_18:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_19
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_19:
	; BC_PROC [07]
	adr r0, proc_169_start		; r0=r_Procedures[169]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_20
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_20:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_21
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_21:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_22
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_22:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_23
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_23:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_24
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_24:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_25
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_25:
	; BC_PROC [07]
	adr r0, proc_185_start		; r0=r_Procedures[185]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_26
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_26:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_27
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_27:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_28
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_28:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_0_continue_29
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_0_continue_29:
	; BC_PROC [07]
	adr r0, proc_192_start		; r0=r_Procedures[192]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_0_end:

proc_1_start:
	; BC_PROC [07]
	adr r0, proc_19_start		; r0=r_Procedures[19]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_1_end:

proc_2_start:
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [cd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00440000			; r0=rConstants[77] (68.0000)
	; BC_CONST [b4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_4_start		; r0=r_Procedures[4]
	; BC_FORK [25]
	mov r1, #5
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_CONST [b4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_4_start		; r0=r_Procedures[4]
	; BC_FORK [25]
	mov r1, #5
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [b7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001c0000			; r0=rConstants[55] (28.0000)
	; BC_CONST [b4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_4_start		; r0=r_Procedures[4]
	; BC_FORK [25]
	mov r1, #5
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_2_continue_30
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_2_continue_30:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [ce]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_3_start		; r0=r_Procedures[3]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_2_end:

proc_3_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_3_target_31
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_3_continue_32
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_3_continue_32:
	; BC_PROC [07]
	adr r0, proc_3_start		; r0=r_Procedures[3]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_3_target_31:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_3_end:

proc_4_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_4_target_33
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [64]
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_4_target_34
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_4_target_35
proc_4_target_34:
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_4_target_35:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_4_continue_36
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_4_continue_36:
	; BC_PROC [07]
	adr r0, proc_4_start		; r0=r_Procedures[4]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_4_target_33:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_4_end:

proc_5_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_5_continue_37
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_5_continue_37:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #6*4]			; r0=rConstants[6]=0x00004ccc (0.3000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_5_continue_38
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_5_continue_38:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #8*4]			; r0=rConstants[8]=0x00009999 (0.6000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WAIT [0a]
	adr r1, proc_5_continue_39
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_5_continue_39:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_5_end:

proc_6_start:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_6_continue_40
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_6_continue_40:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #6*4]			; r0=rConstants[6]=0x00004ccc (0.3000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_6_continue_41
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_6_continue_41:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #8*4]			; r0=rConstants[8]=0x00009999 (0.6000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WAIT [0a]
	adr r1, proc_6_continue_42
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_6_continue_42:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_6_end:

proc_7_start:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_7_continue_43
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_7_continue_43:
	; BC_CONST [c0]
	mov r0, #0x00290000			; r0=rConstants[64] (41.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_7_continue_44
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_7_continue_44:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_7_end:

proc_8_start:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_8_continue_45
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_8_continue_45:
	; BC_CONST [c0]
	mov r0, #0x00290000			; r0=rConstants[64] (41.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_8_continue_46
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_8_continue_46:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_8_end:

proc_9_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_9_continue_47
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_9_continue_47:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_9_continue_48
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_9_continue_48:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #8*4]			; r0=rConstants[8]=0x00009999 (0.6000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_9_continue_49
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_9_continue_49:
	; BC_CONST [be]
	mov r0, #0x00270000			; r0=rConstants[62] (39.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_9_end:

proc_10_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_10_continue_50
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_10_continue_50:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #6*4]			; r0=rConstants[6]=0x00004ccc (0.3000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_10_continue_51
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_10_continue_51:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_10_continue_52
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_10_continue_52:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #6*4]			; r0=rConstants[6]=0x00004ccc (0.3000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_10_continue_53
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_10_continue_53:
	; BC_CONST [c5]
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_10_end:

proc_11_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_11_continue_54
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_11_continue_54:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_11_continue_55
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_11_continue_55:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_11_continue_56
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_11_continue_56:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_11_continue_57
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_11_continue_57:
	; BC_CONST [c5]
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_11_end:

proc_12_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_13_start		; r0=r_Procedures[13]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_12_end:

proc_13_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_13_target_58
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_59
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_59:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [86]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #6*4]			; r0=rConstants[6]=0x00004ccc (0.3000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_60
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_60:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [88]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #8*4]			; r0=rConstants[8]=0x00009999 (0.6000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_61
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_61:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_13_continue_62
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_13_continue_62:
	; BC_PROC [07]
	adr r0, proc_13_start		; r0=r_Procedures[13]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_13_target_58:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_13_end:

proc_14_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_14_target_63
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_15_start		; r0=r_Procedures[15]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_14_continue_64
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_14_continue_64:
	; BC_CONST [c2]
	mov r0, #0x002c0000			; r0=rConstants[66] (44.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_14_start		; r0=r_Procedures[14]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_14_target_63:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_14_end:

proc_15_start:
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_17_start		; r0=r_Procedures[17]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_18_start		; r0=r_Procedures[18]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_18_start		; r0=r_Procedures[18]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_18_start		; r0=r_Procedures[18]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_18_start		; r0=r_Procedures[18]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_15_end:

proc_16_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_16_end:

proc_17_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_17_end:

proc_18_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_18_target_65
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_18_start		; r0=r_Procedures[18]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_18_target_65:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_18_end:

proc_19_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [d2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_47_start		; r0=r_Procedures[47]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_66
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_66:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_SEED [0c]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_67
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_67:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_68
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_68:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_69
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_69:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_70
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_70:
	; BC_PROC [07]
	adr r0, proc_29_start		; r0=r_Procedures[29]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_71
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_71:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_72
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_72:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_73
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_73:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_74
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_74:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_75
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_75:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_76
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_76:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_77
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_77:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_78
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_78:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_79
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_79:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_80
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_80:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_81
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_81:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_82
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_82:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_83
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_83:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_84
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_84:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_85
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_85:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_86
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_86:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_87
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_87:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_88
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_88:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_89
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_89:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_90
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_90:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_91
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_91:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_25_start		; r0=r_Procedures[25]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_92
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_92:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_93
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_93:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [d2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_94
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_94:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_95
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_95:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_96
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_96:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_97
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_97:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_98
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_98:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_99
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_99:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_19_continue_100
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_100:
	; BC_PROC [07]
	adr r0, proc_22_start		; r0=r_Procedures[22]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [cc]
	mov r0, #0x00410000			; r0=rConstants[76] (65.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_101
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_101:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_102
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_102:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_19_continue_103
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_19_continue_103:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_20_start		; r0=r_Procedures[20]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_19_end:

proc_20_start:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_20_end:

proc_21_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_21_target_104
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_21_continue_105
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_21_continue_105:
	; BC_PROC [07]
	adr r0, proc_21_start		; r0=r_Procedures[21]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_21_target_104:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_21_end:

proc_22_start:
	; BC_CONST [cf]
	mov r0, #0x004a0000			; r0=rConstants[79] (74.0000)
	; BC_CONST [e6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x008c0000			; r0=rConstants[102] (140.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [c6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00340000			; r0=rConstants[70] (52.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_22_continue_106
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_22_continue_106:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001c0000			; r0=rConstants[55] (28.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [ca]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_CONST [8e]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #14*4]			; r0=rConstants[14]=0x0000e666 (0.9000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d7]
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ef]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00be0000			; r0=rConstants[111] (190.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_CONST [8c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #12*4]			; r0=rConstants[12]=0x0000cccc (0.8000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [ba]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_22_continue_107
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_22_continue_107:
	; BC_CONST [cf]
	mov r0, #0x004a0000			; r0=rConstants[79] (74.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [dd]
	mov r0, #0x00720000			; r0=rConstants[93] (114.0000)
	; BC_CONST [f5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00f00000			; r0=rConstants[117] (240.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [ba]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_22_end:

proc_23_start:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_23_target_108
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_24_start		; r0=r_Procedures[24]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [85]
	mov r0, #0x00004000			; r0=rConstants[5] (0.2500)
	; BC_WAIT [0a]
	adr r1, proc_23_continue_109
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_23_continue_109:
	; BC_PROC [07]
	adr r0, proc_23_start		; r0=r_Procedures[23]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_23_target_108:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_23_end:

proc_24_start:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [82]
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_24_end:

proc_25_start:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_25_continue_110
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_25_continue_110:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_25_end:

proc_26_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_26_target_111
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_27_start		; r0=r_Procedures[27]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_26_continue_112
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_26_continue_112:
	; BC_PROC [07]
	adr r0, proc_26_start		; r0=r_Procedures[26]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_26_target_111:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_26_end:

proc_27_start:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_27_continue_113
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_27_continue_113:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_27_continue_114
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_27_continue_114:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_27_continue_115
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_27_continue_115:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_27_end:

proc_28_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_28_target_116
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_28_continue_117
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_28_continue_117:
	; BC_PROC [07]
	adr r0, proc_28_start		; r0=r_Procedures[28]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_28_target_116:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_28_end:

proc_29_start:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_31_start		; r0=r_Procedures[31]
	; BC_CONST [b9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001f0000			; r0=rConstants[57] (31.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [f3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00d20000			; r0=rConstants[115] (210.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_31_start		; r0=r_Procedures[31]
	; BC_CONST [b9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001f0000			; r0=rConstants[57] (31.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_29_continue_118
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_29_continue_118:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_33_start		; r0=r_Procedures[33]
	; BC_CONST [c9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003f0000			; r0=rConstants[73] (63.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_29_continue_119
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_29_continue_119:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_29_continue_120
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_29_continue_120:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_29_continue_121
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_29_continue_121:
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_31_start		; r0=r_Procedures[31]
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_CONST [d7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_29_continue_122
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_29_continue_122:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_29_continue_123
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_29_continue_123:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_29_continue_124
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_29_continue_124:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_29_end:

proc_30_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_30_target_125
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WAIT [0a]
	adr r1, proc_30_continue_126
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_30_continue_126:
	; BC_PROC [07]
	adr r0, proc_30_start		; r0=r_Procedures[30]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_30_target_125:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_30_end:

proc_31_start:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_127
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_127:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_128
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_128:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_31_continue_129
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_31_continue_129:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_31_end:

proc_32_start:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_32_continue_130
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_32_continue_130:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_32_continue_131
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_32_continue_131:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_32_continue_132
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_32_continue_132:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_32_end:

proc_33_start:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_34_start		; r0=r_Procedures[34]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_33_end:

proc_34_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_34_target_133
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9a]
	ldr r0, [r4, #26*4]			; r0=rConstants[26]=0x0001d999 (1.8500)
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [98]
	ldr r0, [r4, #24*4]			; r0=rConstants[24]=0x0001b333 (1.7000)
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_34_continue_134
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_34_continue_134:
	; BC_PROC [07]
	adr r0, proc_34_start		; r0=r_Procedures[34]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_34_target_135
proc_34_target_133:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_34_target_135:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_34_end:

proc_35_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_35_target_136
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_35_target_137
proc_35_target_136:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_35_target_137:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_35_continue_138
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_35_continue_138:
	; BC_CONST [c5]
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_35_end:

proc_36_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_36_target_139
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_36_continue_140
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_36_continue_140:
	; BC_PROC [07]
	adr r0, proc_36_start		; r0=r_Procedures[36]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [94]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #20*4]			; r0=rConstants[20]=0x00012b85 (1.1700)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_36_target_139:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_36_end:

proc_37_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_37_target_141
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_38_start		; r0=r_Procedures[38]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_37_start		; r0=r_Procedures[37]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_37_target_141:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_37_end:

proc_38_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_38_target_142
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_38_target_143
proc_38_target_142:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_38_target_143:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_38_end:

proc_39_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_39_target_144
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_40_start		; r0=r_Procedures[40]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_39_continue_145
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_39_continue_145:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_39_continue_146
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_39_continue_146:
	; BC_PROC [07]
	adr r0, proc_39_start		; r0=r_Procedures[39]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_39_target_144:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_39_end:

proc_40_start:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_147
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_147:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_148
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_148:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_149
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_149:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_150
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_150:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_151
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_151:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_152
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_152:
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_35_start		; r0=r_Procedures[35]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_153
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_153:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_154
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_154:
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_35_start		; r0=r_Procedures[35]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_155
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_155:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_156
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_156:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_157
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_157:
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_35_start		; r0=r_Procedures[35]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_158
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_158:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_159
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_159:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_160
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_160:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_161
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_161:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_40_continue_162
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_40_continue_162:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_40_end:

proc_41_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_41_continue_163
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_41_continue_163:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_45_start		; r0=r_Procedures[45]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WAIT [0a]
	adr r1, proc_41_continue_164
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_41_continue_164:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_41_end:

proc_42_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_42_continue_165
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_42_continue_165:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_46_start		; r0=r_Procedures[46]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WAIT [0a]
	adr r1, proc_42_continue_166
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_42_continue_166:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_42_end:

proc_43_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_43_continue_167
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_43_continue_167:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_46_start		; r0=r_Procedures[46]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_43_continue_168
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_43_continue_168:
	; BC_CONST [b3]
	mov r0, #0x00150000			; r0=rConstants[51] (21.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_46_start		; r0=r_Procedures[46]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_43_continue_169
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_43_continue_169:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_46_start		; r0=r_Procedures[46]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WAIT [0a]
	adr r1, proc_43_continue_170
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_43_continue_170:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_43_continue_171
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_43_continue_171:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_46_start		; r0=r_Procedures[46]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WAIT [0a]
	adr r1, proc_43_continue_172
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_43_continue_172:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_43_end:

proc_44_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_44_target_173
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_44_start		; r0=r_Procedures[44]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_44_target_173:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_44_end:

proc_45_start:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_45_end:

proc_46_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_46_end:

proc_47_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_47_target_174
	; BC_CONST [f0]
	mov r0, #0x00c00000			; r0=rConstants[112] (192.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_175
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_175:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_176
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_176:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_177
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_177:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_178
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_178:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_179
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_179:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_180
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_180:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_181
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_181:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_182
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_182:
	; BC_CONST [d7]
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_183
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_183:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_184
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_184:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_185
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_185:
	; BC_CONST [d7]
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_186
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_186:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_187
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_187:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_188
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_188:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_189
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_189:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_190
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_190:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_191
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_191:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_192
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_192:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_193
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_193:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_194
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_194:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_195
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_195:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_196
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_196:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_197
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_197:
	; BC_CONST [d7]
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_198
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_198:
	; BC_CONST [d7]
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_199
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_199:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_200
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_200:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_201
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_201:
	; BC_CONST [d7]
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_202
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_202:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_203
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_203:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_204
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_204:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_48_start		; r0=r_Procedures[48]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_205
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_205:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_47_continue_206
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_47_continue_206:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_47_start		; r0=r_Procedures[47]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_47_target_174:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_47_end:

proc_48_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_48_continue_207
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_48_continue_207:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_48_continue_208
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_48_continue_208:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_48_end:

proc_49_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_49_target_209
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_49_continue_210
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_49_continue_210:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_49_start		; r0=r_Procedures[49]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_49_target_209:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_49_end:

proc_50_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_PROC [07]
	adr r0, proc_52_start		; r0=r_Procedures[52]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_88_start		; r0=r_Procedures[88]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_211
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_211:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_212
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_212:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_213
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_213:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_214
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_214:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_215
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_215:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_216
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_216:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_217
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_217:
	; BC_PROC [07]
	adr r0, proc_81_start		; r0=r_Procedures[81]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_218
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_218:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_219
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_219:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_220
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_220:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_221
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_221:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_222
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_222:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_223
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_223:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_224
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_224:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_225
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_225:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_226
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_226:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_227
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_227:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_228
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_228:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_229
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_229:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_230
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_230:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_231
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_231:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_232
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_232:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_233
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_233:
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_234
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_234:
	; BC_PROC [07]
	adr r0, proc_6_start		; r0=r_Procedures[6]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_235
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_235:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_88_start		; r0=r_Procedures[88]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_236
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_236:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_237
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_237:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_238
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_238:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_239
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_239:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_240
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_240:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_241
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_241:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_54_start		; r0=r_Procedures[54]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_242
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_242:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_PROC [07]
	adr r0, proc_51_start		; r0=r_Procedures[51]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_243
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_243:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_244
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_244:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_245
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_245:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_246
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_246:
	; BC_PROC [07]
	adr r0, proc_100_start		; r0=r_Procedures[100]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_247
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_247:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_248
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_248:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_249
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_249:
	; BC_PROC [07]
	adr r0, proc_82_start		; r0=r_Procedures[82]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_250
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_250:
	; BC_PROC [07]
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_251
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_251:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_252
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_252:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_253
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_253:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_254
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_254:
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_255
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_255:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_256
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_256:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_257
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_257:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_258
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_258:
	; BC_PROC [07]
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_259
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_259:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_260
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_260:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_261
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_261:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_262
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_262:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00260000			; r0=rConstants[61] (38.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_263
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_263:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_264
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_264:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_265
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_265:
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_266
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_266:
	; BC_PROC [07]
	adr r0, proc_6_start		; r0=r_Procedures[6]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_267
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_267:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_88_start		; r0=r_Procedures[88]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_268
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_268:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_269
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_269:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_270
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_270:
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_97_start		; r0=r_Procedures[97]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_271
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_271:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_272
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_272:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_53_start		; r0=r_Procedures[53]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_273
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_273:
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_274
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_274:
	; BC_PROC [07]
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_50_continue_275
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_50_continue_275:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_50_end:

proc_51_start:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [fa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x012c0000			; r0=rConstants[122] (300.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b9]
	mov r0, #0x001f0000			; r0=rConstants[57] (31.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ef]
	mov r0, #0x00be0000			; r0=rConstants[111] (190.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b9]
	mov r0, #0x001f0000			; r0=rConstants[57] (31.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_276
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_276:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_277
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_277:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_278
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_278:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_279
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_279:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_280
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_280:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_281
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_281:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_282
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_282:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_283
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_283:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_284
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_284:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [fa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x012c0000			; r0=rConstants[122] (300.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ef]
	mov r0, #0x00be0000			; r0=rConstants[111] (190.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_285
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_285:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_286
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_286:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_287
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_287:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_288
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_288:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_289
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_289:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_290
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_290:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_291
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_291:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_292
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_292:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_293
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_293:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_294
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_294:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_295
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_295:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_296
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_296:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_297
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_297:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_298
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_298:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_299
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_299:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_300
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_300:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_301
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_301:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_302
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_302:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_303
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_303:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_304
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_304:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_51_continue_305
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_51_continue_305:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [fa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x012c0000			; r0=rConstants[122] (300.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ef]
	mov r0, #0x00be0000			; r0=rConstants[111] (190.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_51_end:

proc_52_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_CONST [fc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x014a0000			; r0=rConstants[124] (330.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_306
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_306:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_307
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_307:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_308
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_308:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_309
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_309:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_310
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_310:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_311
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_311:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_312
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_312:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_313
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_313:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_314
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_314:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_CONST [fc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x014a0000			; r0=rConstants[124] (330.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_315
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_315:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_316
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_316:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_317
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_317:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_318
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_318:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_319
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_319:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_320
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_320:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_321
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_321:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_322
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_322:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_323
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_323:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_324
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_324:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_325
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_325:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_326
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_326:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_327
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_327:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_328
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_328:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_329
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_329:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_330
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_330:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_331
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_331:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_332
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_332:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_333
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_333:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_334
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_334:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_335
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_335:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_CONST [fc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x014a0000			; r0=rConstants[124] (330.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_336
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_336:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_337
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_337:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_52_continue_338
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_52_continue_338:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_52_end:

proc_53_start:
	; BC_CONST [9e]
	ldr r0, [r4, #30*4]			; r0=rConstants[30]=0x00039999 (3.6000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #153*4]			; r0=rConstants[153]=0x881f1f81 (34847.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #149*4]			; r0=rConstants[149]=0x82071fa2 (33287.1236)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_55_start		; r0=r_Procedures[55]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_53_continue_339
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_53_continue_339:
	; BC_CONST [fe]
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_55_start		; r0=r_Procedures[55]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_53_continue_340
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_53_continue_340:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_55_start		; r0=r_Procedures[55]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_53_continue_341
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_53_continue_341:
	; BC_PROC [07]
	adr r0, proc_75_start		; r0=r_Procedures[75]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_53_end:

proc_54_start:
	; BC_CONST [c3]
	mov r0, #0x002d0000			; r0=rConstants[67] (45.0000)
	; BC_CONST [cc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00410000			; r0=rConstants[76] (65.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_55_start		; r0=r_Procedures[55]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_54_continue_342
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_54_continue_342:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_55_start		; r0=r_Procedures[55]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_54_continue_343
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_54_continue_343:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_55_start		; r0=r_Procedures[55]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00130000			; r0=rConstants[49] (19.0000)
	; BC_WAIT [0a]
	adr r1, proc_54_continue_344
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_54_continue_344:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_54_end:

proc_55_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_55_target_345
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_55_target_345:
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_55_continue_346
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_55_continue_346:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_55_target_347
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_55_target_347:
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_55_continue_348
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_55_continue_348:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_55_target_349
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_55_target_349:
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_55_continue_350
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_55_continue_350:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_55_target_351
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_55_target_351:
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_55_continue_352
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_55_continue_352:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_55_end:

proc_56_start:
	; BC_CONST [fe]
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_56_continue_353
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_56_continue_353:
	; BC_CONST [fe]
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_56_continue_354
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_56_continue_354:
	; BC_CONST [fe]
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_56_continue_355
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_56_continue_355:
	; BC_CONST [fe]
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_56_continue_356
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_56_continue_356:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_56_end:

proc_57_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #153*4]			; r0=rConstants[153]=0x881f1f81 (34847.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_57_continue_357
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_57_continue_357:
	; BC_CONST [fe]
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_57_continue_358
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_57_continue_358:
	; BC_CONST [fe]
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_57_continue_359
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_57_continue_359:
	; BC_CONST [fe]
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_57_end:

proc_58_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_58_continue_360
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_58_continue_360:
	; BC_CONST [fe]
	ldr r0, [r4, #152*4]			; r0=rConstants[152]=0x823f3f20 (33343.2466)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_71_start		; r0=r_Procedures[71]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_58_end:

proc_59_start:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_361
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_361:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_362
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_362:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_363
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_363:
	; BC_PROC [07]
	adr r0, proc_60_start		; r0=r_Procedures[60]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_364
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_364:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_365
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_365:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_366
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_366:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_367
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_367:
	; BC_PROC [07]
	adr r0, proc_62_start		; r0=r_Procedures[62]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_368
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_368:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_369
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_369:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_370
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_370:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_371
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_371:
	; BC_PROC [07]
	adr r0, proc_60_start		; r0=r_Procedures[60]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_372
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_372:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_373
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_373:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_374
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_374:
	; BC_PROC [07]
	adr r0, proc_63_start		; r0=r_Procedures[63]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_375
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_375:
	; BC_PROC [07]
	adr r0, proc_61_start		; r0=r_Procedures[61]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_59_continue_376
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_59_continue_376:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_59_end:

proc_60_start:
	; BC_CONST [bb]
	mov r0, #0x00210000			; r0=rConstants[59] (33.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #169*4]			; r0=rConstants[169]=0xf8800083 (63616.0020)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_377
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_377:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_378
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_378:
	; BC_CONST [fe]
	ldr r0, [r4, #160*4]			; r0=rConstants[160]=0x9a7226a6 (39538.1510)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_379
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_379:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_380
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_380:
	; BC_CONST [fe]
	ldr r0, [r4, #155*4]			; r0=rConstants[155]=0x98611bb6 (39009.1082)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_381
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_381:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_382
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_382:
	; BC_CONST [fe]
	ldr r0, [r4, #151*4]			; r0=rConstants[151]=0x820f08f0 (33295.0349)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_383
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_383:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_384
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_384:
	; BC_CONST [fe]
	ldr r0, [r4, #151*4]			; r0=rConstants[151]=0x820f08f0 (33295.0349)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_385
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_385:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_60_continue_386
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_60_continue_386:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_60_end:

proc_61_start:
	; BC_CONST [bb]
	mov r0, #0x00210000			; r0=rConstants[59] (33.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #169*4]			; r0=rConstants[169]=0xf8800083 (63616.0020)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_387
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_387:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_388
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_388:
	; BC_CONST [fe]
	ldr r0, [r4, #169*4]			; r0=rConstants[169]=0xf8800083 (63616.0020)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_389
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_389:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_390
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_390:
	; BC_CONST [fe]
	ldr r0, [r4, #169*4]			; r0=rConstants[169]=0xf8800083 (63616.0020)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_391
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_391:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_392
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_392:
	; BC_CONST [fe]
	ldr r0, [r4, #155*4]			; r0=rConstants[155]=0x98611bb6 (39009.1082)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_393
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_393:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_394
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_394:
	; BC_CONST [fe]
	ldr r0, [r4, #151*4]			; r0=rConstants[151]=0x820f08f0 (33295.0349)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_395
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_395:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_61_continue_396
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_61_continue_396:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_61_end:

proc_62_start:
	; BC_CONST [bb]
	mov r0, #0x00210000			; r0=rConstants[59] (33.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #169*4]			; r0=rConstants[169]=0xf8800083 (63616.0020)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_397
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_397:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_398
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_398:
	; BC_CONST [fe]
	ldr r0, [r4, #160*4]			; r0=rConstants[160]=0x9a7226a6 (39538.1510)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_399
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_399:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_400
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_400:
	; BC_CONST [fe]
	ldr r0, [r4, #155*4]			; r0=rConstants[155]=0x98611bb6 (39009.1082)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00130000			; r0=rConstants[49] (19.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_401
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_401:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_402
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_402:
	; BC_CONST [fe]
	ldr r0, [r4, #160*4]			; r0=rConstants[160]=0x9a7226a6 (39538.1510)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ad]
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_403
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_403:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_404
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_404:
	; BC_CONST [fe]
	ldr r0, [r4, #151*4]			; r0=rConstants[151]=0x820f08f0 (33295.0349)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_405
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_405:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_62_continue_406
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_62_continue_406:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_62_end:

proc_63_start:
	; BC_CONST [bb]
	mov r0, #0x00210000			; r0=rConstants[59] (33.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #169*4]			; r0=rConstants[169]=0xf8800083 (63616.0020)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_407
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_407:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_408
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_408:
	; BC_CONST [fe]
	ldr r0, [r4, #160*4]			; r0=rConstants[160]=0x9a7226a6 (39538.1510)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_409
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_409:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_410
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_410:
	; BC_CONST [fe]
	ldr r0, [r4, #155*4]			; r0=rConstants[155]=0x98611bb6 (39009.1082)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_411
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_411:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_412
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_412:
	; BC_CONST [fe]
	ldr r0, [r4, #151*4]			; r0=rConstants[151]=0x820f08f0 (33295.0349)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_67_start		; r0=r_Procedures[67]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_413
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_413:
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9c]
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_63_continue_414
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_63_continue_414:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_63_end:

proc_64_start:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_65_start		; r0=r_Procedures[65]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_64_end:

proc_65_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_65_target_415
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_65_continue_416
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_65_continue_416:
	; BC_PROC [07]
	adr r0, proc_65_start		; r0=r_Procedures[65]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_65_target_415:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_65_end:

proc_66_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_68_start		; r0=r_Procedures[68]
	; BC_FORK [25]
	mov r1, #5
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_66_end:

proc_67_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_67_end:

proc_68_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_68_target_417
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_69_start		; r0=r_Procedures[69]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WAIT [0a]
	adr r1, proc_68_continue_418
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_68_continue_418:
	; BC_PROC [07]
	adr r0, proc_68_start		; r0=r_Procedures[68]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_68_target_417:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_68_end:

proc_69_start:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_70_start		; r0=r_Procedures[70]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_69_end:

proc_70_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_70_target_419
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_70_target_420
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_70_target_420:
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WAIT [0a]
	adr r1, proc_70_continue_421
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_70_continue_421:
	; BC_PROC [07]
	adr r0, proc_70_start		; r0=r_Procedures[70]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_70_target_419:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_70_end:

proc_71_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_72_start		; r0=r_Procedures[72]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_71_end:

proc_72_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_72_target_422
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_73_start		; r0=r_Procedures[73]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_72_continue_423
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_72_continue_423:
	; BC_PROC [07]
	adr r0, proc_72_start		; r0=r_Procedures[72]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_72_target_422:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_72_end:

proc_73_start:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_73_end:

proc_74_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_74_target_424
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_74_target_425
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_74_target_425:
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_74_start		; r0=r_Procedures[74]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [33]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, ror r1			; r0=r0 ror r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_74_target_424:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_74_end:

proc_75_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c3]
	mov r0, #0x002d0000			; r0=rConstants[67] (45.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [c3]
	mov r0, #0x002d0000			; r0=rConstants[67] (45.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_76_start		; r0=r_Procedures[76]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [e4]
	mov r0, #0x00860000			; r0=rConstants[100] (134.0000)
	; BC_CONST [f9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01180000			; r0=rConstants[121] (280.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_76_start		; r0=r_Procedures[76]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_75_end:

proc_76_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_76_target_426
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_76_start		; r0=r_Procedures[76]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_76_target_426:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_76_end:

proc_77_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_77_target_427
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_77_start		; r0=r_Procedures[77]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_77_target_427:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_77_end:

proc_78_start:
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_79_start		; r0=r_Procedures[79]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_77_start		; r0=r_Procedures[77]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_78_end:

proc_79_start:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [b4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_80_start		; r0=r_Procedures[80]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_79_continue_428
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_79_continue_428:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [b4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_80_start		; r0=r_Procedures[80]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_79_continue_429
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_79_continue_429:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [b4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_80_start		; r0=r_Procedures[80]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_79_continue_430
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_79_continue_430:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_CONST [b4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_80_start		; r0=r_Procedures[80]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_79_end:

proc_80_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_80_target_431
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_80_continue_432
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_80_continue_432:
	; BC_PROC [07]
	adr r0, proc_80_start		; r0=r_Procedures[80]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_80_target_431:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_80_end:

proc_81_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [e3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00820000			; r0=rConstants[99] (130.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_81_continue_433
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_81_continue_433:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_81_continue_434
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_81_continue_434:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_81_continue_435
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_81_continue_435:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_81_end:

proc_82_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_82_continue_436
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_82_continue_436:
	; BC_CONST [c3]
	mov r0, #0x002d0000			; r0=rConstants[67] (45.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [c5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_82_continue_437
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_82_continue_437:
	; BC_CONST [c3]
	mov r0, #0x002d0000			; r0=rConstants[67] (45.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [c5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_82_continue_438
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_82_continue_438:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_82_end:

proc_83_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_83_target_439
	; BC_PROC [07]
	adr r0, proc_84_start		; r0=r_Procedures[84]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_86_start		; r0=r_Procedures[86]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [85]
	mov r0, #0x00004000			; r0=rConstants[5] (0.2500)
	; BC_WAIT [0a]
	adr r1, proc_83_continue_440
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_83_continue_440:
	; BC_CONST [82]
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_83_start		; r0=r_Procedures[83]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_83_target_439:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_83_end:

proc_84_start:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_84_continue_441
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_84_continue_441:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_84_continue_442
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_84_continue_442:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_84_continue_443
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_84_continue_443:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_84_end:

proc_85_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_85_continue_444
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_444:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_85_continue_445
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_445:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_85_continue_446
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_85_continue_446:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_85_end:

proc_86_start:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_86_continue_447
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_86_continue_447:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_86_continue_448
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_86_continue_448:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_86_continue_449
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_86_continue_449:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_86_end:

proc_87_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_SEED [0c]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_91_start		; r0=r_Procedures[91]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_89_start		; r0=r_Procedures[89]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WAIT [0a]
	adr r1, proc_87_continue_450
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_87_continue_450:
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_CONST [f5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00f00000			; r0=rConstants[117] (240.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [f3]
	mov r0, #0x00d20000			; r0=rConstants[115] (210.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [f3]
	mov r0, #0x00d20000			; r0=rConstants[115] (210.0000)
	; BC_CONST [f5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00f00000			; r0=rConstants[117] (240.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_87_end:

proc_88_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_SEED [0c]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_91_start		; r0=r_Procedures[91]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_89_start		; r0=r_Procedures[89]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WAIT [0a]
	adr r1, proc_88_continue_451
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_88_continue_451:
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_CONST [f5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00f00000			; r0=rConstants[117] (240.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [f3]
	mov r0, #0x00d20000			; r0=rConstants[115] (210.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [f3]
	mov r0, #0x00d20000			; r0=rConstants[115] (210.0000)
	; BC_CONST [f5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00f00000			; r0=rConstants[117] (240.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_88_end:

proc_89_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_89_target_452
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_CONST [b9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001f0000			; r0=rConstants[57] (31.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00018000			; r0=rConstants[23] (1.5000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_90_start		; r0=r_Procedures[90]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_89_start		; r0=r_Procedures[89]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_89_target_452:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_89_end:

proc_90_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_90_target_453
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_90_continue_454
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_90_continue_454:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_90_start		; r0=r_Procedures[90]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8e]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #14*4]			; r0=rConstants[14]=0x0000e666 (0.9000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_90_target_453:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_90_end:

proc_91_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_91_target_455
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_91_continue_456
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_91_continue_456:
	; BC_PROC [07]
	adr r0, proc_91_start		; r0=r_Procedures[91]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_91_target_455:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_91_end:

proc_92_start:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [c5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_92_end:

proc_93_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_93_target_457
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_94_start		; r0=r_Procedures[94]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_93_continue_458
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_93_continue_458:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_93_start		; r0=r_Procedures[93]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [92]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #18*4]			; r0=rConstants[18]=0x000107ae (1.0300)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_93_target_457:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_93_end:

proc_94_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_94_end:

proc_95_start:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [e3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00820000			; r0=rConstants[99] (130.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_95_end:

proc_96_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_96_target_459
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_96_continue_460
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_96_continue_460:
	; BC_PROC [07]
	adr r0, proc_96_start		; r0=r_Procedures[96]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_96_target_459:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_96_end:

proc_97_start:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_CONST [ce]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [db]
	mov r0, #0x006e0000			; r0=rConstants[91] (110.0000)
	; BC_CONST [f7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00fa0000			; r0=rConstants[119] (250.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_97_end:

proc_98_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_98_target_461
	; BC_CONST [95]
	ldr r0, [r4, #21*4]			; r0=rConstants[21]=0x00016666 (1.4000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_98_continue_462
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_98_continue_462:
	; BC_PROC [07]
	adr r0, proc_98_start		; r0=r_Procedures[98]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_98_target_463
proc_98_target_461:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_98_target_463:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_98_end:

proc_99_start:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_99_continue_464
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_99_continue_464:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_99_continue_465
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_99_continue_465:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_99_continue_466
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_99_continue_466:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WAIT [0a]
	adr r1, proc_99_continue_467
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_99_continue_467:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_99_end:

proc_100_start:
	; BC_CONST [e6]
	mov r0, #0x008c0000			; r0=rConstants[102] (140.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [ed]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_100_continue_468
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_100_continue_468:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_100_continue_469
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_100_continue_469:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_100_continue_470
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_100_continue_470:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_100_continue_471
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_100_continue_471:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_100_continue_472
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_100_continue_472:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_100_continue_473
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_100_continue_473:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_100_continue_474
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_100_continue_474:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_101_start		; r0=r_Procedures[101]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_100_end:

proc_101_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_102_start		; r0=r_Procedures[102]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_101_end:

proc_102_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_102_target_475
	; BC_PROC [07]
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_102_continue_476
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_102_continue_476:
	; BC_PROC [07]
	adr r0, proc_102_start		; r0=r_Procedures[102]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_102_target_475:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_102_end:

proc_103_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_103_end:

proc_104_start:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [ce]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_99_start		; r0=r_Procedures[99]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_104_end:

proc_105_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_105_target_477
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_105_target_478
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_105_target_479
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_DONE [00]
proc_105_target_479:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_105_continue_480
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_105_continue_480:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_105_start		; r0=r_Procedures[105]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_105_target_481
proc_105_target_478:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_105_start		; r0=r_Procedures[105]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_105_target_481:
	; BC_DONE [00]
proc_105_target_477:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_105_target_482
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_105_target_483
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_105_continue_484
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_105_continue_484:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_105_start		; r0=r_Procedures[105]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_105_target_485
proc_105_target_483:
	; BC_PROC [07]
	adr r0, proc_105_start		; r0=r_Procedures[105]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_105_target_485:
	; BC_DONE [00]
proc_105_target_482:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_105_end:

proc_106_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_106_target_486
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_106_target_487
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_106_target_488
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_DONE [00]
proc_106_target_488:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_106_continue_489
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_106_continue_489:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_106_target_490
proc_106_target_487:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_106_target_490:
	; BC_DONE [00]
proc_106_target_486:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_106_target_491
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_106_target_492
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_106_target_493
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_DONE [00]
proc_106_target_493:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_106_continue_494
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_106_continue_494:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_106_target_495
proc_106_target_492:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_106_target_495:
	; BC_DONE [00]
proc_106_target_491:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_106_target_496
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_106_target_497
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_106_continue_498
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_106_continue_498:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_106_target_499
proc_106_target_497:
	; BC_PROC [07]
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_106_target_499:
	; BC_DONE [00]
proc_106_target_496:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_106_end:

proc_107_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_107_target_500
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_107_target_501
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_107_target_502
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_107_target_502:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_107_continue_503
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_107_continue_503:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_107_target_504
proc_107_target_501:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_107_target_504:
	; BC_DONE [00]
proc_107_target_500:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_107_target_505
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_107_target_506
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_107_continue_507
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_107_continue_507:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_107_target_508
proc_107_target_506:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_107_target_508:
	; BC_DONE [00]
proc_107_target_505:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_107_target_509
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_107_target_510
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_107_continue_511
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_107_continue_511:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_107_target_512
proc_107_target_510:
	; BC_PROC [07]
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_107_target_512:
	; BC_DONE [00]
proc_107_target_509:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_107_end:

proc_108_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_108_target_513
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_108_target_514
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a0]
	mov r0, #0x00048000			; r0=rConstants[32] (4.5000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_108_continue_515
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_108_continue_515:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_108_target_516
proc_108_target_514:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_108_target_516:
	; BC_DONE [00]
proc_108_target_513:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_108_target_517
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_108_target_518
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_108_target_519
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_108_target_519:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_108_continue_520
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_108_continue_520:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_108_target_521
proc_108_target_518:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_108_target_521:
	; BC_DONE [00]
proc_108_target_517:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_108_target_522
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_108_target_523
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_108_continue_524
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_108_continue_524:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_108_target_525
proc_108_target_523:
	; BC_PROC [07]
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_108_target_525:
	; BC_DONE [00]
proc_108_target_522:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_108_end:

proc_109_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_109_target_526
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_110_start		; r0=r_Procedures[110]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_109_continue_527
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_109_continue_527:
	; BC_PROC [07]
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_109_target_526:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_109_end:

proc_110_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_110_target_528
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_111_start		; r0=r_Procedures[111]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [bc]
	mov r0, #0x00230000			; r0=rConstants[60] (35.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_110_start		; r0=r_Procedures[110]
	; BC_CONST [8a]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #10*4]			; r0=rConstants[10]=0x0000b333 (0.7000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_110_target_528:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_110_end:

proc_111_start:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_113_start		; r0=r_Procedures[113]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_111_continue_529
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_111_continue_529:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_112_start		; r0=r_Procedures[112]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_111_end:

proc_112_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_112_target_530
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_112_continue_531
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_112_continue_531:
	; BC_PROC [07]
	adr r0, proc_112_start		; r0=r_Procedures[112]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_112_target_530:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_112_end:

proc_113_start:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_113_target_532
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_113_start		; r0=r_Procedures[113]
	; BC_RSTATE [78]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_113_target_533
proc_113_target_532:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_113_target_533:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_113_end:

proc_114_start:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_115_start		; r0=r_Procedures[115]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_137_start		; r0=r_Procedures[137]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_114_end:

proc_115_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [85]
	mov r0, #0x00004000			; r0=rConstants[5] (0.2500)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_133_start		; r0=r_Procedures[133]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [da]
	mov r0, #0x00670000			; r0=rConstants[90] (103.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_534
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_534:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_535
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_535:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_536
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_536:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_537
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_537:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_127_start		; r0=r_Procedures[127]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_538
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_538:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_539
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_539:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_540
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_540:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_541
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_541:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_542
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_542:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_129_start		; r0=r_Procedures[129]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_543
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_543:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_544
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_544:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_545
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_545:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_546
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_546:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_547
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_547:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_127_start		; r0=r_Procedures[127]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_548
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_548:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_549
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_549:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_127_start		; r0=r_Procedures[127]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_550
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_550:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_551
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_551:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_125_start		; r0=r_Procedures[125]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_552
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_552:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_125_start		; r0=r_Procedures[125]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_553
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_553:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_126_start		; r0=r_Procedures[126]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_554
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_554:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_126_start		; r0=r_Procedures[126]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_555
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_555:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_556
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_556:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_557
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_557:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_558
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_558:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_559
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_559:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_128_start		; r0=r_Procedures[128]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_560
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_560:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_561
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_561:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_562
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_562:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_124_start		; r0=r_Procedures[124]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_563
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_563:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_130_start		; r0=r_Procedures[130]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_130_start		; r0=r_Procedures[130]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_564
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_564:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PROC [07]
	adr r0, proc_116_start		; r0=r_Procedures[116]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_565
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_565:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_566
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_566:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_567
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_567:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_568
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_568:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_569
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_569:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_127_start		; r0=r_Procedures[127]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_570
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_570:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_115_continue_571
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_571:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_128_start		; r0=r_Procedures[128]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_572
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_572:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_129_start		; r0=r_Procedures[129]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_573
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_573:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PROC [07]
	adr r0, proc_121_start		; r0=r_Procedures[121]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_574
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_574:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [82]
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_133_start		; r0=r_Procedures[133]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_7_start		; r0=r_Procedures[7]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b4]
	mov r0, #0x00170000			; r0=rConstants[52] (23.0000)
	; BC_WAIT [0a]
	adr r1, proc_115_continue_575
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_115_continue_575:
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_115_end:

proc_116_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_117_start		; r0=r_Procedures[117]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_117_start		; r0=r_Procedures[117]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_116_continue_576
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_116_continue_576:
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PROC [07]
	adr r0, proc_118_start		; r0=r_Procedures[118]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_119_start		; r0=r_Procedures[119]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_119_start		; r0=r_Procedures[119]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_116_end:

proc_117_start:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_577
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_577:
	; BC_CONST [b1]
	mov r0, #0x00130000			; r0=rConstants[49] (19.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_578
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_578:
	; BC_CONST [ac]
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_117_continue_579
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_117_continue_579:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_117_end:

proc_118_start:
	; BC_CONST [ac]
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_580
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_580:
	; BC_CONST [b1]
	mov r0, #0x00130000			; r0=rConstants[49] (19.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_118_continue_581
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_118_continue_581:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_118_end:

proc_119_start:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ac]
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b1]
	mov r0, #0x00130000			; r0=rConstants[49] (19.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_582
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_582:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ac]
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_119_continue_583
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_119_continue_583:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_119_end:

proc_120_start:
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_120_end:

proc_121_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_121_continue_584
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_121_continue_584:
	; BC_CONST [b1]
	mov r0, #0x00130000			; r0=rConstants[49] (19.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_121_continue_585
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_121_continue_585:
	; BC_CONST [ac]
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_120_start		; r0=r_Procedures[120]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_121_continue_586
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_121_continue_586:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_121_end:

proc_122_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_122_target_587
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_125_start		; r0=r_Procedures[125]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_122_continue_588
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_122_continue_588:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_122_start		; r0=r_Procedures[122]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_122_target_589
proc_122_target_587:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_122_target_589:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_122_end:

proc_123_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_123_target_590
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_124_start		; r0=r_Procedures[124]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_123_continue_591
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_123_continue_591:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_123_start		; r0=r_Procedures[123]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_123_target_592
proc_123_target_590:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_123_target_592:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_123_end:

proc_124_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_124_target_593
	; BC_CONST [84]
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_132_start		; r0=r_Procedures[132]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_124_continue_594
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_124_continue_594:
	; BC_PROC [07]
	adr r0, proc_124_start		; r0=r_Procedures[124]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_124_target_593:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_124_end:

proc_125_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_125_target_595
	; BC_CONST [84]
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_131_start		; r0=r_Procedures[131]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_125_continue_596
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_125_continue_596:
	; BC_PROC [07]
	adr r0, proc_125_start		; r0=r_Procedures[125]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_125_target_595:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_125_end:

proc_126_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_126_target_597
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c5]
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_135_start		; r0=r_Procedures[135]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_126_continue_598
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_126_continue_598:
	; BC_PROC [07]
	adr r0, proc_126_start		; r0=r_Procedures[126]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_126_target_597:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_126_end:

proc_127_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_127_target_599
	; BC_CONST [84]
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e1]
	mov r0, #0x007f0000			; r0=rConstants[97] (127.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00018000			; r0=rConstants[23] (1.5000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_135_start		; r0=r_Procedures[135]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_127_continue_600
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_127_continue_600:
	; BC_PROC [07]
	adr r0, proc_127_start		; r0=r_Procedures[127]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_127_target_599:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_127_end:

proc_128_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_128_target_601
	; BC_CONST [84]
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e1]
	mov r0, #0x007f0000			; r0=rConstants[97] (127.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [c8]
	mov r0, #0x003e0000			; r0=rConstants[72] (62.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [97]
	mov r0, #0x00018000			; r0=rConstants[23] (1.5000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_135_start		; r0=r_Procedures[135]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_128_continue_602
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_128_continue_602:
	; BC_PROC [07]
	adr r0, proc_128_start		; r0=r_Procedures[128]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_128_target_601:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_128_end:

proc_129_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_129_target_603
	; BC_CONST [84]
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_131_start		; r0=r_Procedures[131]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_129_continue_604
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_129_continue_604:
	; BC_PROC [07]
	adr r0, proc_129_start		; r0=r_Procedures[129]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_129_target_603:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_129_end:

proc_130_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_130_target_605
	; BC_CONST [84]
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_SINE [0b]
	mov r1, #0xfffc
	and r0, r0, r1
	ldr r0, [r7, r0]			; r7=r_Sinus
	mov r0, r0, asl #2
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_132_start		; r0=r_Procedures[132]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_130_continue_606
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_130_continue_606:
	; BC_PROC [07]
	adr r0, proc_130_start		; r0=r_Procedures[130]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_130_target_605:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_130_end:

proc_131_start:
	; BC_PROC [07]
	adr r0, proc_135_start		; r0=r_Procedures[135]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_131_end:

proc_132_start:
	; BC_PROC [07]
	adr r0, proc_135_start		; r0=r_Procedures[135]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_132_end:

proc_133_start:
	; BC_CONST [fb]
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_133_target_607
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WAIT [0a]
	adr r1, proc_133_continue_608
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_133_continue_608:
	; BC_PROC [07]
	adr r0, proc_133_start		; r0=r_Procedures[133]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_133_target_607:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_133_end:

proc_134_start:
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #34*4]			; r0=rConstants[34]=0x00054ccc (5.3000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_127_start		; r0=r_Procedures[127]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [cc]
	mov r0, #0x00410000			; r0=rConstants[76] (65.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_134_continue_609
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_134_continue_609:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_134_end:

proc_135_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_136_start		; r0=r_Procedures[136]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_136_start		; r0=r_Procedures[136]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_136_start		; r0=r_Procedures[136]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_136_start		; r0=r_Procedures[136]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_135_end:

proc_136_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1f]
	ble proc_136_target_610
	; BC_CONST [96]
	mov r0, #0x00016a00			; r0=rConstants[22] (1.4141)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_136_start		; r0=r_Procedures[136]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_136_target_610:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_136_end:

proc_137_start:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_611
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_611:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_612
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_612:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_613
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_613:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_614
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_614:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_615
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_615:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_616
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_616:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_617
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_617:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_618
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_618:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_137_continue_619
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_137_continue_619:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_137_end:

proc_138_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_138_target_620
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_RAND [03]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_RAND*4]
	bic r1, r0, #0xff000000
	bic r1, r1, #0x00ff0000
	mov r2, r0, lsl #16
	orr r0, r2, r0, lsr #16
	mov r2, #0x9d3d
	mul r1, r2, r1
	add r0, r0, r1
	str r0, [r5, #ST_RAND*4]
	mov r0, r0, lsr #16
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_139_start		; r0=r_Procedures[139]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_138_continue_621
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_138_continue_621:
	; BC_PROC [07]
	adr r0, proc_138_start		; r0=r_Procedures[138]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_138_target_620:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_138_end:

proc_139_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_139_target_622
	; BC_PROC [07]
	adr r0, proc_140_start		; r0=r_Procedures[140]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ab]
	ldr r0, [r4, #43*4]			; r0=rConstants[43]=0x000d5553 (13.3333)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_139_continue_623
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_139_continue_623:
	; BC_PROC [07]
	adr r0, proc_139_start		; r0=r_Procedures[139]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_139_target_622:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_139_end:

proc_140_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_140_continue_624
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_140_continue_624:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_140_continue_625
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_140_continue_625:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_140_continue_626
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_140_continue_626:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_140_continue_627
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_140_continue_627:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_140_continue_628
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_140_continue_628:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_140_end:

proc_141_start:
	; BC_CONST [e0]
	mov r0, #0x007d0000			; r0=rConstants[96] (125.0000)
	; BC_CONST [ce]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_146_start		; r0=r_Procedures[146]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [f0]
	mov r0, #0x00c00000			; r0=rConstants[112] (192.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_145_start		; r0=r_Procedures[145]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [db]
	mov r0, #0x006e0000			; r0=rConstants[91] (110.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_59_start		; r0=r_Procedures[59]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_149_start		; r0=r_Procedures[149]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_148_start		; r0=r_Procedures[148]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [f7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00fa0000			; r0=rConstants[119] (250.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_156_start		; r0=r_Procedures[156]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [af]
	mov r0, #0x00110000			; r0=rConstants[47] (17.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_141_continue_629
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_141_continue_629:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_147_start		; r0=r_Procedures[147]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ad]
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_141_continue_630
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_141_continue_630:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [f7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00fa0000			; r0=rConstants[119] (250.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_143_start		; r0=r_Procedures[143]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_141_continue_631
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_141_continue_631:
	; BC_PROC [07]
	adr r0, proc_142_start		; r0=r_Procedures[142]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_141_continue_632
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_141_continue_632:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_143_start		; r0=r_Procedures[143]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_141_end:

proc_142_start:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_633
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_633:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_634
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_634:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_635
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_635:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_636
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_636:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_637
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_637:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_638
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_638:
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_639
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_639:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_640
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_640:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_641
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_641:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_642
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_642:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_643
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_643:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_644
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_644:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_645
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_645:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_142_continue_646
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_142_continue_646:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_142_end:

proc_143_start:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_647
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_647:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_648
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_648:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_649
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_649:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_650
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_650:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_651
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_651:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_652
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_652:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_653
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_653:
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_654
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_654:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_655
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_655:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_656
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_656:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_657
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_657:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_658
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_658:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_143_continue_659
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_143_continue_659:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_143_end:

proc_144_start:
	; BC_CONST [a9]
	mov r0, #0x000b0000			; r0=rConstants[41] (11.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_144_target_660
	; BC_CONST [c5]
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_144_target_660:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_144_target_661
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_144_continue_662
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_144_continue_662:
	; BC_PROC [07]
	adr r0, proc_144_start		; r0=r_Procedures[144]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_CONST [8c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #12*4]			; r0=rConstants[12]=0x0000cccc (0.8000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_144_target_663
proc_144_target_661:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_144_target_663:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_144_end:

proc_145_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_145_target_664
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_665
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_665:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_666
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_666:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_667
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_667:
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_668
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_668:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_58_start		; r0=r_Procedures[58]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_669
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_669:
	; BC_PROC [07]
	adr r0, proc_58_start		; r0=r_Procedures[58]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_670
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_670:
	; BC_PROC [07]
	adr r0, proc_58_start		; r0=r_Procedures[58]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_671
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_671:
	; BC_PROC [07]
	adr r0, proc_58_start		; r0=r_Procedures[58]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_672
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_672:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_673
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_673:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_674
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_674:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_145_continue_675
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_145_continue_675:
	; BC_PROC [07]
	adr r0, proc_145_start		; r0=r_Procedures[145]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_145_target_664:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_145_end:

proc_146_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_146_target_676
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_57_start		; r0=r_Procedures[57]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_677
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_677:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_57_start		; r0=r_Procedures[57]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_678
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_678:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_679
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_679:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_680
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_680:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_681
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_681:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_682
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_682:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_683
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_683:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_684
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_684:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_146_continue_685
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_146_continue_685:
	; BC_PROC [07]
	adr r0, proc_146_start		; r0=r_Procedures[146]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_146_target_676:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_146_end:

proc_147_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_147_target_686
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_150_start		; r0=r_Procedures[150]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_148_start		; r0=r_Procedures[148]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_WAIT [0a]
	adr r1, proc_147_continue_687
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_147_continue_687:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_151_start		; r0=r_Procedures[151]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_148_start		; r0=r_Procedures[148]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_WAIT [0a]
	adr r1, proc_147_continue_688
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_147_continue_688:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_151_start		; r0=r_Procedures[151]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_148_start		; r0=r_Procedures[148]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_WAIT [0a]
	adr r1, proc_147_continue_689
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_147_continue_689:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [16]
	bne proc_147_target_690
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_150_start		; r0=r_Procedures[150]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_148_start		; r0=r_Procedures[148]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_150_start		; r0=r_Procedures[150]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_148_start		; r0=r_Procedures[148]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_ELSE [01]
	b proc_147_target_691
proc_147_target_690:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_150_start		; r0=r_Procedures[150]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_148_start		; r0=r_Procedures[148]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_147_target_691:
	; BC_CONST [c4]
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_WAIT [0a]
	adr r1, proc_147_continue_692
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_147_continue_692:
	; BC_PROC [07]
	adr r0, proc_147_start		; r0=r_Procedures[147]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_147_target_686:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_147_end:

proc_148_start:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [ef]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00be0000			; r0=rConstants[111] (190.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_154_start		; r0=r_Procedures[154]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_148_continue_693
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_148_continue_693:
	; BC_CONST [b3]
	mov r0, #0x00150000			; r0=rConstants[51] (21.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_154_start		; r0=r_Procedures[154]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_148_continue_694
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_148_continue_694:
	; BC_CONST [b3]
	mov r0, #0x00150000			; r0=rConstants[51] (21.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_154_start		; r0=r_Procedures[154]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_148_continue_695
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_148_continue_695:
	; BC_CONST [b3]
	mov r0, #0x00150000			; r0=rConstants[51] (21.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_154_start		; r0=r_Procedures[154]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_148_continue_696
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_148_continue_696:
	; BC_CONST [b3]
	mov r0, #0x00150000			; r0=rConstants[51] (21.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_154_start		; r0=r_Procedures[154]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_148_continue_697
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_148_continue_697:
	; BC_CONST [b3]
	mov r0, #0x00150000			; r0=rConstants[51] (21.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_154_start		; r0=r_Procedures[154]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_148_end:

proc_149_start:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_149_end:

proc_150_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_153_start		; r0=r_Procedures[153]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_150_end:

proc_151_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_152_start		; r0=r_Procedures[152]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_151_end:

proc_152_start:
	; BC_CONST [ad]
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1e]
	bgt proc_152_target_698
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_152_continue_699
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_152_continue_699:
	; BC_PROC [07]
	adr r0, proc_152_start		; r0=r_Procedures[152]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_152_target_698:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_152_end:

proc_153_start:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1e]
	bgt proc_153_target_700
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_153_continue_701
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_153_continue_701:
	; BC_PROC [07]
	adr r0, proc_153_start		; r0=r_Procedures[153]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_153_target_700:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_153_end:

proc_154_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_154_target_702
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b3]
	mov r0, #0x00150000			; r0=rConstants[51] (21.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_154_continue_703
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_154_continue_703:
	; BC_PROC [07]
	adr r0, proc_154_start		; r0=r_Procedures[154]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_154_target_702:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_154_end:

proc_155_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_155_target_704
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_155_continue_705
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_155_continue_705:
	; BC_PROC [07]
	adr r0, proc_155_start		; r0=r_Procedures[155]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_155_target_704:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_155_end:

proc_156_start:
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_157_start		; r0=r_Procedures[157]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_156_end:

proc_157_start:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_159_start		; r0=r_Procedures[159]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_706
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_706:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_160_start		; r0=r_Procedures[160]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_707
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_707:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_161_start		; r0=r_Procedures[161]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_708
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_708:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [99]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #25*4]			; r0=rConstants[25]=0x0001c7ae (1.7800)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_162_start		; r0=r_Procedures[162]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_709
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_709:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [95]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #21*4]			; r0=rConstants[21]=0x00016666 (1.4000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_710
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_710:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [93]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #19*4]			; r0=rConstants[19]=0x000128f5 (1.1600)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_164_start		; r0=r_Procedures[164]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_711
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_711:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [8f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #15*4]			; r0=rConstants[15]=0x0000fd70 (0.9900)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_165_start		; r0=r_Procedures[165]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_712
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_712:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [8d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #13*4]			; r0=rConstants[13]=0x0000deb8 (0.8700)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_713
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_713:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [8b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #11*4]			; r0=rConstants[11]=0x0000c51e (0.7700)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_167_start		; r0=r_Procedures[167]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_714
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_714:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_CONST [89]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #9*4]			; r0=rConstants[9]=0x0000b0a3 (0.6900)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_168_start		; r0=r_Procedures[168]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_157_continue_715
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_157_continue_715:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_157_end:

proc_158_start:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_158_end:

proc_159_start:
	; BC_CONST [b6]
	mov r0, #0x00190000			; r0=rConstants[54] (25.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_159_target_716
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_159_continue_717
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_159_continue_717:
	; BC_PROC [07]
	adr r0, proc_159_start		; r0=r_Procedures[159]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_159_target_716:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_159_end:

proc_160_start:
	; BC_CONST [f8]
	mov r0, #0x01000000			; r0=rConstants[120] (256.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_160_target_718
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_160_continue_719
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_160_continue_719:
	; BC_PROC [07]
	adr r0, proc_160_start		; r0=r_Procedures[160]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_160_target_718:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_160_end:

proc_161_start:
	; BC_CONST [e4]
	mov r0, #0x00860000			; r0=rConstants[100] (134.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_161_target_720
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_161_continue_721
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_161_continue_721:
	; BC_PROC [07]
	adr r0, proc_161_start		; r0=r_Procedures[161]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_161_target_722
proc_161_target_720:
	; BC_CONST [ec]
	mov r0, #0x00b00000			; r0=rConstants[108] (176.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_161_target_723
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_161_continue_724
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_161_continue_724:
	; BC_PROC [07]
	adr r0, proc_161_start		; r0=r_Procedures[161]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_161_target_723:
	; BC_DONE [00]
proc_161_target_722:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_161_end:

proc_162_start:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_162_target_725
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_162_continue_726
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_162_continue_726:
	; BC_PROC [07]
	adr r0, proc_162_start		; r0=r_Procedures[162]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_162_target_727
proc_162_target_725:
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_162_target_728
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_162_continue_729
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_162_continue_729:
	; BC_PROC [07]
	adr r0, proc_162_start		; r0=r_Procedures[162]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_162_target_730
proc_162_target_728:
	; BC_CONST [d3]
	mov r0, #0x00520000			; r0=rConstants[83] (82.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_162_target_731
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_162_continue_732
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_162_continue_732:
	; BC_PROC [07]
	adr r0, proc_162_start		; r0=r_Procedures[162]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_162_target_733
proc_162_target_731:
	; BC_CONST [dc]
	mov r0, #0x00700000			; r0=rConstants[92] (112.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_162_target_734
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_162_continue_735
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_162_continue_735:
	; BC_PROC [07]
	adr r0, proc_162_start		; r0=r_Procedures[162]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_162_target_736
proc_162_target_734:
	; BC_CONST [f0]
	mov r0, #0x00c00000			; r0=rConstants[112] (192.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_162_target_737
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_162_continue_738
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_162_continue_738:
	; BC_PROC [07]
	adr r0, proc_162_start		; r0=r_Procedures[162]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_162_target_739
proc_162_target_737:
	; BC_CONST [f2]
	mov r0, #0x00cc0000			; r0=rConstants[114] (204.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_162_target_740
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_162_continue_741
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_162_continue_741:
	; BC_PROC [07]
	adr r0, proc_162_start		; r0=r_Procedures[162]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_162_target_740:
	; BC_DONE [00]
proc_162_target_739:
	; BC_DONE [00]
proc_162_target_736:
	; BC_DONE [00]
proc_162_target_733:
	; BC_DONE [00]
proc_162_target_730:
	; BC_DONE [00]
proc_162_target_727:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_162_end:

proc_163_start:
	; BC_CONST [bc]
	mov r0, #0x00230000			; r0=rConstants[60] (35.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_163_target_742
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_163_continue_743
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_163_continue_743:
	; BC_PROC [07]
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_163_target_744
proc_163_target_742:
	; BC_CONST [c6]
	mov r0, #0x00340000			; r0=rConstants[70] (52.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_163_target_745
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_163_continue_746
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_163_continue_746:
	; BC_PROC [07]
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_163_target_747
proc_163_target_745:
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_163_target_748
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_163_continue_749
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_163_continue_749:
	; BC_PROC [07]
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_163_target_750
proc_163_target_748:
	; BC_CONST [ee]
	mov r0, #0x00b60000			; r0=rConstants[110] (182.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_163_target_751
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_163_continue_752
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_163_continue_752:
	; BC_PROC [07]
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_163_target_753
proc_163_target_751:
	; BC_CONST [f4]
	mov r0, #0x00e00000			; r0=rConstants[116] (224.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_163_target_754
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_163_continue_755
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_163_continue_755:
	; BC_PROC [07]
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_163_target_756
proc_163_target_754:
	; BC_CONST [f6]
	mov r0, #0x00f40000			; r0=rConstants[118] (244.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_163_target_757
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_163_continue_758
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_163_continue_758:
	; BC_PROC [07]
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_163_target_759
proc_163_target_757:
	; BC_CONST [f8]
	mov r0, #0x01000000			; r0=rConstants[120] (256.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_163_target_760
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_163_continue_761
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_163_continue_761:
	; BC_PROC [07]
	adr r0, proc_163_start		; r0=r_Procedures[163]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_163_target_760:
	; BC_DONE [00]
proc_163_target_759:
	; BC_DONE [00]
proc_163_target_756:
	; BC_DONE [00]
proc_163_target_753:
	; BC_DONE [00]
proc_163_target_750:
	; BC_DONE [00]
proc_163_target_747:
	; BC_DONE [00]
proc_163_target_744:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_163_end:

proc_164_start:
	; BC_CONST [f8]
	mov r0, #0x01000000			; r0=rConstants[120] (256.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_164_target_762
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_164_continue_763
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_164_continue_763:
	; BC_PROC [07]
	adr r0, proc_164_start		; r0=r_Procedures[164]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_164_target_762:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_164_end:

proc_165_start:
	; BC_CONST [f8]
	mov r0, #0x01000000			; r0=rConstants[120] (256.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_165_target_764
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_165_continue_765
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_165_continue_765:
	; BC_PROC [07]
	adr r0, proc_165_start		; r0=r_Procedures[165]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_165_target_764:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_165_end:

proc_166_start:
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_766
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_767
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_767:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_768
proc_166_target_766:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_769
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_770
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_770:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_771
proc_166_target_769:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_772
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_773
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_773:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_774
proc_166_target_772:
	; BC_CONST [d1]
	mov r0, #0x004e0000			; r0=rConstants[81] (78.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_775
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_776
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_776:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_777
proc_166_target_775:
	; BC_CONST [d5]
	mov r0, #0x00580000			; r0=rConstants[85] (88.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_778
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_779
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_779:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_780
proc_166_target_778:
	; BC_CONST [d7]
	mov r0, #0x00600000			; r0=rConstants[87] (96.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_781
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_782
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_782:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_783
proc_166_target_781:
	; BC_CONST [dc]
	mov r0, #0x00700000			; r0=rConstants[92] (112.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_784
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_785
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_785:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_786
proc_166_target_784:
	; BC_CONST [e4]
	mov r0, #0x00860000			; r0=rConstants[100] (134.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_787
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_788
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_788:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_789
proc_166_target_787:
	; BC_CONST [e9]
	mov r0, #0x009c0000			; r0=rConstants[105] (156.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_790
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_791
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_791:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_792
proc_166_target_790:
	; BC_CONST [f1]
	mov r0, #0x00c80000			; r0=rConstants[113] (200.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_793
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_794
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_794:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_795
proc_166_target_793:
	; BC_CONST [f5]
	mov r0, #0x00f00000			; r0=rConstants[117] (240.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_796
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_797
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_797:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_166_target_798
proc_166_target_796:
	; BC_CONST [f8]
	mov r0, #0x01000000			; r0=rConstants[120] (256.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_166_target_799
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_166_continue_800
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_166_continue_800:
	; BC_PROC [07]
	adr r0, proc_166_start		; r0=r_Procedures[166]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_166_target_799:
	; BC_DONE [00]
proc_166_target_798:
	; BC_DONE [00]
proc_166_target_795:
	; BC_DONE [00]
proc_166_target_792:
	; BC_DONE [00]
proc_166_target_789:
	; BC_DONE [00]
proc_166_target_786:
	; BC_DONE [00]
proc_166_target_783:
	; BC_DONE [00]
proc_166_target_780:
	; BC_DONE [00]
proc_166_target_777:
	; BC_DONE [00]
proc_166_target_774:
	; BC_DONE [00]
proc_166_target_771:
	; BC_DONE [00]
proc_166_target_768:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_166_end:

proc_167_start:
	; BC_CONST [f8]
	mov r0, #0x01000000			; r0=rConstants[120] (256.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_167_target_801
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_167_continue_802
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_167_continue_802:
	; BC_PROC [07]
	adr r0, proc_167_start		; r0=r_Procedures[167]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_167_target_801:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_167_end:

proc_168_start:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_168_target_803
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_168_continue_804
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_168_continue_804:
	; BC_PROC [07]
	adr r0, proc_168_start		; r0=r_Procedures[168]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_168_target_805
proc_168_target_803:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_168_target_806
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_168_continue_807
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_168_continue_807:
	; BC_PROC [07]
	adr r0, proc_168_start		; r0=r_Procedures[168]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_168_target_808
proc_168_target_806:
	; BC_CONST [e8]
	mov r0, #0x009a0000			; r0=rConstants[104] (154.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_168_target_809
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_168_continue_810
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_168_continue_810:
	; BC_PROC [07]
	adr r0, proc_168_start		; r0=r_Procedures[168]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_168_target_811
proc_168_target_809:
	; BC_CONST [eb]
	mov r0, #0x00a20000			; r0=rConstants[107] (162.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_168_target_812
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_158_start		; r0=r_Procedures[158]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_WAIT [0a]
	adr r1, proc_168_continue_813
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_168_continue_813:
	; BC_PROC [07]
	adr r0, proc_168_start		; r0=r_Procedures[168]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_168_target_812:
	; BC_DONE [00]
proc_168_target_811:
	; BC_DONE [00]
proc_168_target_808:
	; BC_DONE [00]
proc_168_target_805:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_168_end:

proc_169_start:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_175_start		; r0=r_Procedures[175]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_814
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_814:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_169_continue_815
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_815:
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_816
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_816:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00018000			; r0=rConstants[23] (1.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_175_start		; r0=r_Procedures[175]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_817
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_817:
	; BC_CONST [e6]
	mov r0, #0x008c0000			; r0=rConstants[102] (140.0000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_169_continue_818
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_818:
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_CONST [fb]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_819
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_819:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [97]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00018000			; r0=rConstants[23] (1.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_175_start		; r0=r_Procedures[175]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_820
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_820:
	; BC_CONST [ed]
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00002000			; r0=rConstants[3] (0.1250)
	; BC_CONST [ed]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_169_continue_821
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_821:
	; BC_CONST [ed]
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [83]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00002000			; r0=rConstants[3] (0.1250)
	; BC_CONST [ed]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_822
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_822:
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [9c]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00028000			; r0=rConstants[28] (2.5000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_175_start		; r0=r_Procedures[175]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_823
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_823:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [e6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x008c0000			; r0=rConstants[102] (140.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [84]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_CONST [ed]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_169_continue_824
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_824:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [ed]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [84]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #4*4]			; r0=rConstants[4]=0x00002666 (0.1500)
	; BC_CONST [ed]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_181_start		; r0=r_Procedures[181]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WAIT [0a]
	adr r1, proc_169_continue_825
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_169_continue_825:
	; BC_PROC [07]
	adr r0, proc_170_start		; r0=r_Procedures[170]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_171_start		; r0=r_Procedures[171]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_169_end:

proc_170_start:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [b8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_826
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_826:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [c5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #153*4]			; r0=rConstants[153]=0x881f1f81 (34847.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #152*4]			; r0=rConstants[152]=0x823f3f20 (33343.2466)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_827
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_827:
	; BC_CONST [b6]
	mov r0, #0x00190000			; r0=rConstants[54] (25.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #137*4]			; r0=rConstants[137]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x9a6e19a6 (39534.1002)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #132*4]			; r0=rConstants[132]=0x147f1c49 (5247.1105)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #137*4]			; r0=rConstants[137]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #149*4]			; r0=rConstants[149]=0x82071fa2 (33287.1236)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_828
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_828:
	; BC_CONST [de]
	mov r0, #0x00730000			; r0=rConstants[94] (115.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #156*4]			; r0=rConstants[156]=0x987f14aa (39039.0807)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_829
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_829:
	; BC_CONST [de]
	mov r0, #0x00730000			; r0=rConstants[94] (115.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_830
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_830:
	; BC_CONST [e5]
	mov r0, #0x00870000			; r0=rConstants[101] (135.0000)
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #132*4]			; r0=rConstants[132]=0x147f1c49 (5247.1105)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #152*4]			; r0=rConstants[152]=0x823f3f20 (33343.2466)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_831
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_831:
	; BC_CONST [bc]
	mov r0, #0x00230000			; r0=rConstants[60] (35.0000)
	; BC_CONST [ac]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x927f0104 (37503.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #158*4]			; r0=rConstants[158]=0x98bc3ba6 (39100.2330)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #152*4]			; r0=rConstants[152]=0x823f3f20 (33343.2466)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_832
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_832:
	; BC_CONST [d4]
	mov r0, #0x00540000			; r0=rConstants[84] (84.0000)
	; BC_CONST [c1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x002a0000			; r0=rConstants[65] (42.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x927f0104 (37503.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #157*4]			; r0=rConstants[157]=0x989c2f46 (39068.1847)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_833
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_833:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x927f0104 (37503.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #137*4]			; r0=rConstants[137]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x9a6e19a6 (39534.1002)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [c5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x9a6e19a6 (39534.1002)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #158*4]			; r0=rConstants[158]=0x98bc3ba6 (39100.2330)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_834
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_834:
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #152*4]			; r0=rConstants[152]=0x823f3f20 (33343.2466)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #135*4]			; r0=rConstants[135]=0x18710f46 (6257.0597)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #156*4]			; r0=rConstants[156]=0x987f14aa (39039.0807)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #156*4]			; r0=rConstants[156]=0x987f14aa (39039.0807)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_835
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_835:
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #144*4]			; r0=rConstants[144]=0x40bf3f08 (16575.2462)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [ba]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_836
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_836:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #144*4]			; r0=rConstants[144]=0x40bf3f08 (16575.2462)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #137*4]			; r0=rConstants[137]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #149*4]			; r0=rConstants[149]=0x82071fa2 (33287.1236)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_837
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_837:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #135*4]			; r0=rConstants[135]=0x18710f46 (6257.0597)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #136*4]			; r0=rConstants[136]=0x187f3c8a (6271.2365)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #125*4]			; r0=rConstants[125]=0x040f0f42 (1039.0596)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_838
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_838:
	; BC_CONST [c5]
	mov r0, #0x00320000			; r0=rConstants[69] (50.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #132*4]			; r0=rConstants[132]=0x147f1c49 (5247.1105)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #149*4]			; r0=rConstants[149]=0x82071fa2 (33287.1236)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_839
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_839:
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #132*4]			; r0=rConstants[132]=0x147f1c49 (5247.1105)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #150*4]			; r0=rConstants[150]=0x82080820 (33288.0317)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #156*4]			; r0=rConstants[156]=0x987f14aa (39039.0807)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_840
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_840:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x927f0104 (37503.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_841
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_841:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x9a6e19a6 (39534.1002)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x927f0104 (37503.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #153*4]			; r0=rConstants[153]=0x881f1f81 (34847.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [c6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00340000			; r0=rConstants[70] (52.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #154*4]			; r0=rConstants[154]=0x927f0104 (37503.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_842
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_842:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x9a6e19a6 (39534.1002)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #132*4]			; r0=rConstants[132]=0x147f1c49 (5247.1105)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #137*4]			; r0=rConstants[137]=0x189c2186 (6300.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #156*4]			; r0=rConstants[156]=0x987f14aa (39039.0807)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #133*4]			; r0=rConstants[133]=0x14bc3c49 (5308.2355)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x9a6e19a6 (39534.1002)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_843
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_843:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #159*4]			; r0=rConstants[159]=0x9a6e19a6 (39534.1002)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_844
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_844:
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #167*4]			; r0=rConstants[167]=0xf0410107 (61505.0040)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #156*4]			; r0=rConstants[156]=0x987f14aa (39039.0807)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #127*4]			; r0=rConstants[127]=0x083f3082 (2111.1895)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_845
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_845:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #130*4]			; r0=rConstants[130]=0x107e3c08 (4222.2345)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #168*4]			; r0=rConstants[168]=0xf8602087 (63584.1271)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #157*4]			; r0=rConstants[157]=0x989c2f46 (39068.1847)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #161*4]			; r0=rConstants[161]=0x9a7f2186 (39551.1310)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_170_continue_846
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_170_continue_846:
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [bf]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #132*4]			; r0=rConstants[132]=0x147f1c49 (5247.1105)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #131*4]			; r0=rConstants[131]=0x107f2c49 (4223.1730)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #134*4]			; r0=rConstants[134]=0x185e1e86 (6238.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #126*4]			; r0=rConstants[126]=0x081f1f82 (2079.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #158*4]			; r0=rConstants[158]=0x98bc3ba6 (39100.2330)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #152*4]			; r0=rConstants[152]=0x823f3f20 (33343.2466)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_172_start		; r0=r_Procedures[172]
	; BC_FORK [2a]
	mov r1, #10
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_170_end:

proc_171_start:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [f5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00f00000			; r0=rConstants[117] (240.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_CONST [b6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00190000			; r0=rConstants[54] (25.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_847
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_847:
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [82]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #2*4]			; r0=rConstants[2]=0x00001999 (0.1000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [b6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00190000			; r0=rConstants[54] (25.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_848
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_848:
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ce]
	mov r0, #0x00460000			; r0=rConstants[78] (70.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [d8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00630000			; r0=rConstants[88] (99.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_849
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_849:
	; BC_CONST [e6]
	mov r0, #0x008c0000			; r0=rConstants[102] (140.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e7]
	mov r0, #0x00960000			; r0=rConstants[103] (150.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_850
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_850:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [e5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00870000			; r0=rConstants[101] (135.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_851
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_851:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [f7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00fa0000			; r0=rConstants[119] (250.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_852
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_852:
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_853
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_853:
	; BC_CONST [e6]
	mov r0, #0x008c0000			; r0=rConstants[102] (140.0000)
	; BC_CONST [d9]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [e7]
	mov r0, #0x00960000			; r0=rConstants[103] (150.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_854
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_854:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_855
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_855:
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [ad]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_856
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_856:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_CONST [df]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [c7]
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00190000			; r0=rConstants[54] (25.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_857
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_857:
	; BC_CONST [b8]
	mov r0, #0x001e0000			; r0=rConstants[56] (30.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_858
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_858:
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00190000			; r0=rConstants[54] (25.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_859
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_859:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [f1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00c80000			; r0=rConstants[113] (200.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [a1]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_860
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_860:
	; BC_CONST [f1]
	mov r0, #0x00c80000			; r0=rConstants[113] (200.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [81]
	ldr r0, [r4, #1*4]			; r0=rConstants[1]=0x00000bef (0.0466)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_171_continue_861
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_171_continue_861:
	; BC_CONST [d9]
	mov r0, #0x00640000			; r0=rConstants[89] (100.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [90]
	ldr r0, [r4, #16*4]			; r0=rConstants[16]=0x0000fff0 (0.9998)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [db]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[91] (110.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_171_end:

proc_172_start:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_862
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_862:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_863
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_863:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_864
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_864:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_865
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_865:
	; BC_RLOCAL [64]
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_866
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_866:
	; BC_RLOCAL [65]
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_867
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_867:
	; BC_RLOCAL [66]
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_868
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_868:
	; BC_RLOCAL [67]
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_869
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_869:
	; BC_RLOCAL [68]
	ldr r0, [r5, #-9*4]			; r0=StateStack[-9]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ba]
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WAIT [0a]
	adr r1, proc_172_continue_870
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_172_continue_870:
	; BC_PROC [07]
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_RLOCAL [69]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-10*4]			; r0=StateStack[-10]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_173_start		; r0=r_Procedures[173]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WLOCAL [43]
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_WLOCAL [42]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_172_end:

proc_173_start:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_180_start		; r0=r_Procedures[180]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_173_continue_871
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_173_continue_871:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WAIT [0a]
	adr r1, proc_173_continue_872
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_173_continue_872:
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [bf]
	mov r0, #0x00280000			; r0=rConstants[63] (40.0000)
	; BC_WAIT [0a]
	adr r1, proc_173_continue_873
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_173_continue_873:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_173_end:

proc_174_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_174_target_874
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_WHEN [17]
	beq proc_174_target_875
	; BC_RLOCAL [65]
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_183_start		; r0=r_Procedures[183]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_DONE [00]
proc_174_target_875:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WAIT [0a]
	adr r1, proc_174_continue_876
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_174_continue_876:
	; BC_PROC [07]
	adr r0, proc_174_start		; r0=r_Procedures[174]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [34]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, asl r1			; r0=r0 asl r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_174_target_874:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_174_end:

proc_175_start:
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_PROC [07]
	adr r0, proc_176_start		; r0=r_Procedures[176]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_175_end:

proc_176_start:
	; BC_CONST [ed]
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_176_target_877
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_177_start		; r0=r_Procedures[177]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [52]
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_176_start		; r0=r_Procedures[176]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_176_target_877:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_176_end:

proc_177_start:
	; BC_CONST [fb]
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_177_target_878
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_178_start		; r0=r_Procedures[178]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PROC [07]
	adr r0, proc_177_start		; r0=r_Procedures[177]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_177_target_878:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_177_end:

proc_178_start:
	; BC_RSTATE [7a]
	ldr r0, [r5, #ST_WIRE2*4]		; r0=State[ST_WIRE2]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [30]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, asr r1			; r0=r0 asr r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [30]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, lsr #16			; swap.w r1
	and r1, r1, #63				; only bottom 6 bits are valid.
	movs r0, r0, asr r1			; r0=r0 asr r1
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_179_start		; r0=r_Procedures[179]
	; BC_CONST [9f]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WLOCAL [42]
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_178_end:

proc_179_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_179_target_879
	; BC_PROC [07]
	adr r0, proc_179_start		; r0=r_Procedures[179]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_179_target_880
proc_179_target_879:
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_179_continue_881
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_179_continue_881:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_180_start		; r0=r_Procedures[180]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WAIT [0a]
	adr r1, proc_179_continue_882
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_179_continue_882:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_180_start		; r0=r_Procedures[180]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WLOCAL [41]
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_179_target_880:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_179_end:

proc_180_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_180_target_883
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_180_continue_884
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_180_continue_884:
	; BC_PROC [07]
	adr r0, proc_180_start		; r0=r_Procedures[180]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_180_target_883:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_180_end:

proc_181_start:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [a5]
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_182_start		; r0=r_Procedures[182]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WAIT [0a]
	adr r1, proc_181_continue_885
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_181_continue_885:
	; BC_CONST [a3]
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_182_start		; r0=r_Procedures[182]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_181_continue_886
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_181_continue_886:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_182_start		; r0=r_Procedures[182]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ae]
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_WAIT [0a]
	adr r1, proc_181_continue_887
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_181_continue_887:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PROC [07]
	adr r0, proc_182_start		; r0=r_Procedures[182]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_181_end:

proc_182_start:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_182_target_888
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WAIT [0a]
	adr r1, proc_182_continue_889
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_182_continue_889:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_PROC [07]
	adr r0, proc_182_start		; r0=r_Procedures[182]
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [43]
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_182_target_888:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_182_end:

proc_183_start:
	; BC_CONST [fb]
	mov r0, #0x01400000			; r0=rConstants[123] (320.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #147*4]			; r0=rConstants[147]=0x7fffffff (32768.0000)
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_183_target_890
	; BC_CONST [ed]
	mov r0, #0x00b40000			; r0=rConstants[109] (180.0000)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #147*4]			; r0=rConstants[147]=0x7fffffff (32768.0000)
	; BC_RSTATE [72]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_Y*4]		; r0=State[ST_Y]
	; BC_OP [3c]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	ands r0, r0, r1				; r0=r0 ands r1
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_183_target_891
	; BC_PROC [07]
	adr r0, proc_184_start		; r0=r_Procedures[184]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_183_continue_892
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_183_continue_892:
	; BC_PROC [07]
	adr r0, proc_183_start		; r0=r_Procedures[183]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_183_target_891:
	; BC_DONE [00]
proc_183_target_890:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_183_end:

proc_184_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_184_continue_893
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_184_continue_893:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [a6]
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_WAIT [0a]
	adr r1, proc_184_continue_894
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_184_continue_894:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ad]
	mov r0, #0x000f0000			; r0=rConstants[45] (15.0000)
	; BC_WAIT [0a]
	adr r1, proc_184_continue_895
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_184_continue_895:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_184_end:

proc_185_start:
	; BC_PROC [07]
	adr r0, proc_191_start		; r0=r_Procedures[191]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_186_start		; r0=r_Procedures[186]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_185_end:

proc_186_start:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_896
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_896:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_897
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_897:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_898
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_898:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_899
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_899:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_900
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_900:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_901
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_901:
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_902
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_902:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_903
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_903:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_904
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_904:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_905
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_905:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_906
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_906:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_907
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_907:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_908
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_908:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_909
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_909:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_910
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_910:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_911
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_911:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_912
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_912:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_913
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_913:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_914
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_914:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_915
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_915:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_916
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_916:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_917
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_917:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_918
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_918:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_919
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_919:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_920
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_920:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_921
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_921:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_922
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_922:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_923
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_923:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_924
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_924:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_925
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_925:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_926
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_926:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_927
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_927:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_928
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_928:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_929
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_929:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_930
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_930:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_931
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_931:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_932
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_932:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_933
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_933:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_934
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_934:
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_935
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_935:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_936
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_936:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_937
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_937:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_938
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_938:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_939
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_939:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_940
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_940:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_941
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_941:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_942
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_942:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_943
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_943:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_944
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_944:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_945
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_945:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_946
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_946:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_947
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_947:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_948
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_948:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_949
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_949:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_950
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_950:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_951
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_951:
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_952
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_952:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_953
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_953:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_954
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_954:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_955
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_955:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_956
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_956:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_957
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_957:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_958
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_958:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_959
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_959:
	; BC_PROC [07]
	adr r0, proc_189_start		; r0=r_Procedures[189]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_190_start		; r0=r_Procedures[190]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_960
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_960:
	; BC_PROC [07]
	adr r0, proc_187_start		; r0=r_Procedures[187]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_188_start		; r0=r_Procedures[188]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_186_continue_961
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_186_continue_961:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_186_end:

proc_187_start:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_CONST [fa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x012c0000			; r0=rConstants[122] (300.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_187_end:

proc_188_start:
	; BC_CONST [d2]
	mov r0, #0x00500000			; r0=rConstants[82] (80.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [f0]
	mov r0, #0x00c00000			; r0=rConstants[112] (192.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ef]
	mov r0, #0x00be0000			; r0=rConstants[111] (190.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_188_end:

proc_189_start:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_189_end:

proc_190_start:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [e2]
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [ea]
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_CONST [fc]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x014a0000			; r0=rConstants[124] (330.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_109_start		; r0=r_Procedures[109]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_190_end:

proc_191_start:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_87_start		; r0=r_Procedures[87]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_PROC [07]
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_962
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_962:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_963
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_963:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_PROC [07]
	adr r0, proc_100_start		; r0=r_Procedures[100]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_964
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_964:
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_965
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_965:
	; BC_PROC [07]
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_966
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_966:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_967
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_967:
	; BC_PROC [07]
	adr r0, proc_95_start		; r0=r_Procedures[95]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_968
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_968:
	; BC_PROC [07]
	adr r0, proc_106_start		; r0=r_Procedures[106]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_969
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_969:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_970
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_970:
	; BC_PROC [07]
	adr r0, proc_92_start		; r0=r_Procedures[92]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_971
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_971:
	; BC_PROC [07]
	adr r0, proc_81_start		; r0=r_Procedures[81]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_972
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_972:
	; BC_PROC [07]
	adr r0, proc_5_start		; r0=r_Procedures[5]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_973
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_973:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_88_start		; r0=r_Procedures[88]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_974
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_974:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_975
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_975:
	; BC_PROC [07]
	adr r0, proc_9_start		; r0=r_Procedures[9]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_976
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_976:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_53_start		; r0=r_Procedures[53]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_977
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_977:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [a7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_87_start		; r0=r_Procedures[87]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_PROC [07]
	adr r0, proc_108_start		; r0=r_Procedures[108]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_978
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_978:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_979
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_979:
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_PROC [07]
	adr r0, proc_100_start		; r0=r_Procedures[100]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_980
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_980:
	; BC_PROC [07]
	adr r0, proc_82_start		; r0=r_Procedures[82]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_981
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_981:
	; BC_PROC [07]
	adr r0, proc_107_start		; r0=r_Procedures[107]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_103_start		; r0=r_Procedures[103]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_982
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_982:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_983
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_983:
	; BC_PROC [07]
	adr r0, proc_11_start		; r0=r_Procedures[11]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_984
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_984:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_2_start		; r0=r_Procedures[2]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_985
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_985:
	; BC_PROC [07]
	adr r0, proc_134_start		; r0=r_Procedures[134]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_986
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_986:
	; BC_PROC [07]
	adr r0, proc_82_start		; r0=r_Procedures[82]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_987
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_987:
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_87_start		; r0=r_Procedures[87]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_WSTATE [5a]
	str r0, [r5, #ST_WIRE2*4]		; State[ST_WIRE2]=r0
	; BC_PROC [07]
	adr r0, proc_105_start		; r0=r_Procedures[105]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_104_start		; r0=r_Procedures[104]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_988
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_988:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_989
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_989:
	; BC_PROC [07]
	adr r0, proc_92_start		; r0=r_Procedures[92]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_990
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_990:
	; BC_PROC [07]
	adr r0, proc_8_start		; r0=r_Procedures[8]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_991
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_991:
	; BC_PROC [07]
	adr r0, proc_6_start		; r0=r_Procedures[6]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_992
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_992:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [c4]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00300000			; r0=rConstants[68] (48.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_88_start		; r0=r_Procedures[88]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_993
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_993:
	; BC_PROC [07]
	adr r0, proc_78_start		; r0=r_Procedures[78]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_191_continue_994
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_994:
	; BC_PROC [07]
	adr r0, proc_10_start		; r0=r_Procedures[10]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_995
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_995:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_53_start		; r0=r_Procedures[53]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_191_continue_996
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_191_continue_996:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_191_end:

proc_192_start:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_203_start		; r0=r_Procedures[203]
	; BC_FORK [20]
	mov r1, #0
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_199_start		; r0=r_Procedures[199]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_192_continue_997
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_192_continue_997:
	; BC_CONST [d6]
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_CONST [ea]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00a00000			; r0=rConstants[106] (160.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [b0]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_CONST [9d]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_201_start		; r0=r_Procedures[201]
	; BC_FORK [26]
	mov r1, #6
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_192_continue_998
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_192_continue_998:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [aa]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_199_start		; r0=r_Procedures[199]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_192_continue_999
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_192_continue_999:
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_CONST [a6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00080000			; r0=rConstants[38] (8.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_192_continue_1000
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_192_continue_1000:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [af]
	mov r0, #0x00110000			; r0=rConstants[47] (17.0000)
	; BC_CONST [b2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_193_start		; r0=r_Procedures[193]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_192_end:

proc_193_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_193_target_1001
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_194_start		; r0=r_Procedures[194]
	; BC_FORK [22]
	mov r1, #2
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_193_continue_1002
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_193_continue_1002:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RSTATE [71]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_X*4]		; r0=State[ST_X]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_PROC [07]
	adr r0, proc_193_start		; r0=r_Procedures[193]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_193_target_1001:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_193_end:

proc_194_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_194_target_1003
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_194_continue_1004
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_194_continue_1004:
	; BC_PROC [07]
	adr r0, proc_194_start		; r0=r_Procedures[194]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_194_target_1003:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_194_end:

proc_195_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_195_target_1005
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_CONST [ba]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [67]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_196_start		; r0=r_Procedures[196]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [64]
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_WAIT [0a]
	adr r1, proc_195_continue_1006
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_195_continue_1006:
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [66]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_DIV [09]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement divs.w overflow behaviour!
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl divide					; r0=r0/r1
	ldr lr, [sp], #4			; Pop lr off program stack.
	mov r0, r0, asl #8
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [a3]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00060000			; r0=rConstants[35] (6.0000)
	; BC_CONST [ba]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00200000			; r0=rConstants[58] (32.0000)
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [9b]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [67]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_196_start		; r0=r_Procedures[196]
	; BC_FORK [28]
	mov r1, #8
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WAIT [0a]
	adr r1, proc_195_continue_1007
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_195_continue_1007:
	; BC_PROC [07]
	adr r0, proc_195_start		; r0=r_Procedures[195]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [43]
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_195_target_1005:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_195_end:

proc_196_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_196_target_1008
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [bd]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00260000			; r0=rConstants[61] (38.0000)
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RLOCAL [67]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [66]
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_WAIT [0a]
	adr r1, proc_196_continue_1009
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_196_continue_1009:
	; BC_PROC [07]
	adr r0, proc_196_start		; r0=r_Procedures[196]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_WLOCAL [45]
	str r0, [r5, #-6*4]			; StateStack[-6]=r0
	; BC_WLOCAL [44]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-5*4]			; StateStack[-5]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_196_target_1008:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_196_end:

proc_197_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_197_target_1010
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_197_continue_1011
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_197_continue_1011:
	; BC_PROC [07]
	adr r0, proc_197_start		; r0=r_Procedures[197]
	; BC_CONST [a5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_197_target_1010:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_197_end:

proc_198_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_198_target_1012
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9b]
	mov r0, #0x00020000			; r0=rConstants[27] (2.0000)
	; BC_WAIT [0a]
	adr r1, proc_198_continue_1013
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_198_continue_1013:
	; BC_PROC [07]
	adr r0, proc_198_start		; r0=r_Procedures[198]
	; BC_CONST [a5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00070000			; r0=rConstants[37] (7.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_198_target_1012:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_198_end:

proc_199_start:
	; BC_CONST [b0]
	mov r0, #0x00120000			; r0=rConstants[48] (18.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [ca]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_199_target_1014
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [e2]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00800000			; r0=rConstants[98] (128.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_200_start		; r0=r_Procedures[200]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_PROC [07]
	adr r0, proc_199_start		; r0=r_Procedures[199]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WLOCAL [43]
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_WLOCAL [42]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-3*4]			; StateStack[-3]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_199_target_1014:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_199_end:

proc_200_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_200_target_1015
	; BC_CONST [a7]
	mov r0, #0x00090000			; r0=rConstants[39] (9.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_200_continue_1016
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_200_continue_1016:
	; BC_PROC [07]
	adr r0, proc_200_start		; r0=r_Procedures[200]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_200_target_1015:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_200_end:

proc_201_start:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_201_target_1017
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_201_target_1018
	; BC_CONST [80]
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [ae]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00100000			; r0=rConstants[46] (16.0000)
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_202_start		; r0=r_Procedures[202]
	; BC_FORK [23]
	mov r1, #3
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b7]
	mov r0, #0x001c0000			; r0=rConstants[55] (28.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_201_continue_1019
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_201_continue_1019:
	; BC_PROC [07]
	adr r0, proc_201_start		; r0=r_Procedures[201]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_ELSE [01]
	b proc_201_target_1020
proc_201_target_1018:
	; BC_CONST [cb]
	ldr r0, [r4, #75*4]			; r0=rConstants[75]=0x00403333 (64.2000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_PROC [07]
	adr r0, proc_201_start		; r0=r_Procedures[201]
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [87]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_WLOCAL [45]
	str r0, [r5, #-6*4]			; StateStack[-6]=r0
	; BC_WLOCAL [44]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-5*4]			; StateStack[-5]=r0
	; BC_WLOCAL [43]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-4*4]			; StateStack[-4]=r0
	; BC_WLOCAL [41]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-2*4]			; StateStack[-2]=r0
	; BC_WLOCAL [40]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_201_target_1020:
	; BC_DONE [00]
proc_201_target_1017:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_201_end:

proc_202_start:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3b]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	cmp r0, r1					; r0 cmp r1
	; BC_WHEN [1c]
	bge proc_202_target_1021
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [91]
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_WAIT [0a]
	adr r1, proc_202_continue_1022
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_202_continue_1022:
	; BC_PROC [07]
	adr r0, proc_202_start		; r0=r_Procedures[202]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_202_target_1021:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_202_end:

proc_203_start:
	; BC_CONST [a1]
	mov r0, #0x00050000			; r0=rConstants[33] (5.0000)
	; BC_WSTATE [59]
	str r0, [r5, #ST_WIRE1*4]		; State[ST_WIRE1]=r0
	; BC_CONST [a4]
	mov r0, #0x00068000			; r0=rConstants[36] (6.5000)
	; BC_WSTATE [58]
	str r0, [r5, #ST_WIRE0*4]		; State[ST_WIRE0]=r0
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [db]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[91] (110.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #165*4]			; r0=rConstants[165]=0xdfff0114 (57343.0042)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #145*4]			; r0=rConstants[145]=0x42303ff8 (16944.2499)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #163*4]			; r0=rConstants[163]=0x9fff3624 (40959.2115)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #165*4]			; r0=rConstants[165]=0xdfff0114 (57343.0042)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #145*4]			; r0=rConstants[145]=0x42303ff8 (16944.2499)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #163*4]			; r0=rConstants[163]=0x9fff3624 (40959.2115)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_207_start		; r0=r_Procedures[207]
	; BC_FORK [29]
	mov r1, #9
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_203_continue_1023
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_203_continue_1023:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_203_continue_1024
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_203_continue_1024:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #139*4]			; r0=rConstants[139]=0x1fff34aa (8191.2057)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #129*4]			; r0=rConstants[129]=0x0fff3082 (4095.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #128*4]			; r0=rConstants[128]=0x0fdf1f82 (4063.1231)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #166*4]			; r0=rConstants[166]=0xdfff2196 (57343.1312)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #139*4]			; r0=rConstants[139]=0x1fff34aa (8191.2057)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #166*4]			; r0=rConstants[166]=0xdfff2196 (57343.1312)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #163*4]			; r0=rConstants[163]=0x9fff3624 (40959.2115)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #163*4]			; r0=rConstants[163]=0x9fff3624 (40959.2115)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #148*4]			; r0=rConstants[148]=0x81c30313 (33219.0120)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_207_start		; r0=r_Procedures[207]
	; BC_FORK [29]
	mov r1, #9
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_203_continue_1025
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_203_continue_1025:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_203_continue_1026
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_203_continue_1026:
	; BC_CONST [df]
	mov r0, #0x00780000			; r0=rConstants[95] (120.0000)
	; BC_CONST [c7]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x003c0000			; r0=rConstants[71] (60.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #164*4]			; r0=rConstants[164]=0xcfff3f10 (53247.2463)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #138*4]			; r0=rConstants[138]=0x1fde1e86 (8158.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #165*4]			; r0=rConstants[165]=0xdfff0114 (57343.0042)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #165*4]			; r0=rConstants[165]=0xdfff0114 (57343.0042)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #146*4]			; r0=rConstants[146]=0x4cbf3f0c (19647.2463)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #145*4]			; r0=rConstants[145]=0x42303ff8 (16944.2499)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #141*4]			; r0=rConstants[141]=0x2fff3f10 (12287.2463)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_207_start		; r0=r_Procedures[207]
	; BC_FORK [29]
	mov r1, #9
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_203_continue_1027
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_203_continue_1027:
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_203_continue_1028
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_203_continue_1028:
	; BC_CONST [b2]
	mov r0, #0x00140000			; r0=rConstants[50] (20.0000)
	; BC_CONST [a8]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #129*4]			; r0=rConstants[129]=0x0fff3082 (4095.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #138*4]			; r0=rConstants[138]=0x1fde1e86 (8158.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #143*4]			; r0=rConstants[143]=0x3f9c19a6 (16284.1002)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #170*4]			; r0=rConstants[170]=0xffe10087 (65505.0021)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #142*4]			; r0=rConstants[142]=0x3f9c1186 (16284.0685)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #138*4]			; r0=rConstants[138]=0x1fde1e86 (8158.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #146*4]			; r0=rConstants[146]=0x4cbf3f0c (19647.2463)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #145*4]			; r0=rConstants[145]=0x42303ff8 (16944.2499)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_207_start		; r0=r_Procedures[207]
	; BC_FORK [29]
	mov r1, #9
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [d0]
	mov r0, #0x004b0000			; r0=rConstants[80] (75.0000)
	; BC_CONST [db]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x006e0000			; r0=rConstants[91] (110.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #145*4]			; r0=rConstants[145]=0x42303ff8 (16944.2499)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #141*4]			; r0=rConstants[141]=0x2fff3f10 (12287.2463)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #140*4]			; r0=rConstants[140]=0x2fff3892 (12287.2210)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_207_start		; r0=r_Procedures[207]
	; BC_FORK [29]
	mov r1, #9
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [e3]
	mov r0, #0x00820000			; r0=rConstants[99] (130.0000)
	; BC_CONST [d6]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x005a0000			; r0=rConstants[86] (90.0000)
	; BC_WSTATE [51]
	str r0, [r5, #ST_X*4]		; State[ST_X]=r0
	; BC_WSTATE [52]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_Y*4]		; State[ST_Y]=r0
	; BC_CONST [fe]
	ldr r0, [r4, #129*4]			; r0=rConstants[129]=0x0fff3082 (4095.1895)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #138*4]			; r0=rConstants[138]=0x1fde1e86 (8158.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #138*4]			; r0=rConstants[138]=0x1fde1e86 (8158.1192)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #141*4]			; r0=rConstants[141]=0x2fff3f10 (12287.2463)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #170*4]			; r0=rConstants[170]=0xffe10087 (65505.0021)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #166*4]			; r0=rConstants[166]=0xdfff2196 (57343.1312)
	; BC_CONST [fe]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r4, #162*4]			; r0=rConstants[162]=0x9be631e6 (39910.1949)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_207_start		; r0=r_Procedures[207]
	; BC_FORK [29]
	mov r1, #9
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_203_end:

proc_204_start:
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [a8]
	mov r0, #0x000a0000			; r0=rConstants[40] (10.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ca]
	mov r0, #0x00400000			; r0=rConstants[74] (64.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_RSTATE [76]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_DIR*4]		; r0=State[ST_DIR]
	; BC_OP [3d]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	adds r0, r0, r1				; r0=r0 adds r1
	; BC_WSTATE [56]
	str r0, [r5, #ST_DIR*4]		; State[ST_DIR]=r0
	; BC_CONST [b6]
	mov r0, #0x00190000			; r0=rConstants[54] (25.0000)
	; BC_NEG [0d]
	rsb r0, r0, #0				; r0=0-r0
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_WSTATE [53]
	str r0, [r5, #ST_SIZE*4]		; State[ST_SIZE]=r0
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_WSTATE [54]
	str r0, [r5, #ST_TINT*4]		; State[ST_TINT]=r0
	; BC_CONST [b5]
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_205_start		; r0=r_Procedures[205]
	; BC_FORK [21]
	mov r1, #1
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_204_end:

proc_205_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_WHEN [17]
	movs r0, r0					; update Status flags
	beq proc_205_target_1029
	; BC_DRAW [04]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-12]			; (plot_circle_instruction)
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [ac]
	mov r0, #0x000e0000			; r0=rConstants[44] (14.0000)
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [87]
	mov r0, #0x00008000			; r0=rConstants[7] (0.5000)
	; BC_WAIT [0a]
	adr r1, proc_205_continue_1030
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_205_continue_1030:
	; BC_PROC [07]
	adr r0, proc_205_start		; r0=r_Procedures[205]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_RLOCAL [60]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_OP [39]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	subs r0, r0, r1				; r0=r0 subs r1
	; BC_WLOCAL [40]
	str r0, [r5, #-1*4]			; StateStack[-1]=r0
	; BC_WSTATE [50]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_DONE [00]
proc_205_target_1029:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_205_end:

proc_206_start:
	; BC_PLOT [06]
	add r2, r5, #4
	ldmia r2, {r8-r11}			; r8=st_x, r9=st_y, r10=st_size, r11=st_tint
	mov r0, r8, asr #16			; X
	mov r1, r9, asr #16			; Y
	mov r2, r10, asr #16		; RADIUS
	mov r9, r11, lsr #16		; TINT
	ldr r10, [r6, #-8]			; (plot_square_instruction)
	orr r10, r10, r2			; mov r1, #st_size
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl link_circle
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_206_end:

proc_207_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_RLOCAL [61]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_RLOCAL [62]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_RLOCAL [63]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_RLOCAL [64]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_RLOCAL [65]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_RLOCAL [66]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_RLOCAL [67]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_RLOCAL [68]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #-9*4]			; r0=StateStack[-9]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_208_start		; r0=r_Procedures[208]
	; BC_FORK [29]
	mov r1, #9
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_CONST [9f]
	mov r0, #0x00040000			; r0=rConstants[31] (4.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_207_continue_1031
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_207_continue_1031:
	; BC_CONST [9d]
	mov r0, #0x00030000			; r0=rConstants[29] (3.0000)
	; BC_CONST [b5]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00180000			; r0=rConstants[53] (24.0000)
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_WAIT [0a]
	adr r1, proc_207_continue_1032
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_207_continue_1032:
	; BC_CONST [aa]
	mov r0, #0x000c0000			; r0=rConstants[42] (12.0000)
	; BC_WAIT [0a]
	adr r1, proc_207_continue_1033
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_207_continue_1033:
	; BC_PROC [07]
	adr r0, proc_204_start		; r0=r_Procedures[204]
	; BC_WSTATE [50]
	str r0, [r5, #ST_PROC*4]		; State[ST_PROC]=r0
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_POP [08]
	ldr r0, [r3], #4			; Pop r0 off StateStack.
	; BC_TAIL [05]
	ldr r2, [r5, #ST_PROC*4]	; Jump to State.st_proc
	mov pc, r2
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_207_end:

proc_208_start:
	; BC_RLOCAL [60]
	ldr r0, [r5, #-1*4]			; r0=StateStack[-1]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1034
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1034:
	; BC_RLOCAL [61]
	ldr r0, [r5, #-2*4]			; r0=StateStack[-2]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1035
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1035:
	; BC_RLOCAL [62]
	ldr r0, [r5, #-3*4]			; r0=StateStack[-3]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1036
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1036:
	; BC_RLOCAL [63]
	ldr r0, [r5, #-4*4]			; r0=StateStack[-4]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1037
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1037:
	; BC_RLOCAL [64]
	ldr r0, [r5, #-5*4]			; r0=StateStack[-5]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1038
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1038:
	; BC_RLOCAL [65]
	ldr r0, [r5, #-6*4]			; r0=StateStack[-6]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1039
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1039:
	; BC_RLOCAL [66]
	ldr r0, [r5, #-7*4]			; r0=StateStack[-7]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1040
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1040:
	; BC_RLOCAL [67]
	ldr r0, [r5, #-8*4]			; r0=StateStack[-8]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1041
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1041:
	; BC_RLOCAL [68]
	ldr r0, [r5, #-9*4]			; r0=StateStack[-9]
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_64_start		; r0=r_Procedures[64]
	; BC_CONST [91]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00010000			; r0=rConstants[17] (1.0000)
	; BC_CONST [80]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	mov r0, #0x00000000			; r0=rConstants[0] (0.0000)
	; BC_PROC [07]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	adr r0, proc_66_start		; r0=r_Procedures[66]
	; BC_FORK [24]
	mov r1, #4
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl ForkState				; r0=proc address, r1=num_args
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [78]
	ldr r0, [r5, #ST_WIRE0*4]		; r0=State[ST_WIRE0]
	; BC_RSTATE [79]
	str r0, [r3, #-4]!			; Push r0 on StateStack.
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_MUL [0f]
	ldr r1, [r3], #4			; Pop r1 off StateStack.
	mov r0, r0, asl #8
	mov r0, r0, asr #16			; Implement muls.w (signed)
	mov r1, r1, asl #8
	mov r1, r1, asr #16			; Implement muls.w (signed)
	mul r0, r1, r0				; r0=r0*r1
	; BC_MOVE [0e]
	str lr, [sp, #-4]!			; Push lr on program stack.
	bl DoMove
	ldr lr, [sp], #4			; Pop lr off program stack.
	; BC_RSTATE [79]
	ldr r0, [r5, #ST_WIRE1*4]		; r0=State[ST_WIRE1]
	; BC_WAIT [0a]
	adr r1, proc_208_continue_1042
	str r1, [r5, #ST_PROC*4]	; *pState.st_proc = &continue
	str r5, [r3, #-4]!			; push p_State on StateStack.
	ldr r2, [r5, #ST_TIME*4]
	add r2, r2, r0
	str r2, [r5, #ST_TIME*4]	; *pState.st_time += wait_frames
	bic r2, r2, #0xc000			; remove time fractional part.
	ldr r1, [r6, r2, lsr #14]	; r_StateList[time >> 16 << 2]
	str r1, [r3, #-4]!			; push previous entry from StateList at that frame.
	str r3, [r6, r2, lsr #14]	; store new p_StateStack for this frame.
	mov pc, lr					; Return.
proc_208_continue_1042:
	; BC_END [02]
	ldr r2, [r6, #-4]			; (r_FreeState)
	str r2, [r5]				; first word of state block points to prev free state.
	str r5, [r6, #-4]			; (r_FreeState) this state becomes the next free state.
	mov pc, lr					; Return.
proc_208_end:


; ============================================================================
; Constants.
; ============================================================================

r_Constants:
.long 0x00000000				; [0] = 0.0000
.long 0x00000bef				; [1] = 0.0466
.long 0x00001999				; [2] = 0.1000
.long 0x00002000				; [3] = 0.1250
.long 0x00002666				; [4] = 0.1500
.long 0x00004000				; [5] = 0.2500
.long 0x00004ccc				; [6] = 0.3000
.long 0x00008000				; [7] = 0.5000
.long 0x00009999				; [8] = 0.6000
.long 0x0000b0a3				; [9] = 0.6900
.long 0x0000b333				; [10] = 0.7000
.long 0x0000c51e				; [11] = 0.7700
.long 0x0000cccc				; [12] = 0.8000
.long 0x0000deb8				; [13] = 0.8700
.long 0x0000e666				; [14] = 0.9000
.long 0x0000fd70				; [15] = 0.9900
.long 0x0000fff0				; [16] = 0.9998
.long 0x00010000				; [17] = 1.0000
.long 0x000107ae				; [18] = 1.0300
.long 0x000128f5				; [19] = 1.1600
.long 0x00012b85				; [20] = 1.1700
.long 0x00016666				; [21] = 1.4000
.long 0x00016a00				; [22] = 1.4141
.long 0x00018000				; [23] = 1.5000
.long 0x0001b333				; [24] = 1.7000
.long 0x0001c7ae				; [25] = 1.7800
.long 0x0001d999				; [26] = 1.8500
.long 0x00020000				; [27] = 2.0000
.long 0x00028000				; [28] = 2.5000
.long 0x00030000				; [29] = 3.0000
.long 0x00039999				; [30] = 3.6000
.long 0x00040000				; [31] = 4.0000
.long 0x00048000				; [32] = 4.5000
.long 0x00050000				; [33] = 5.0000
.long 0x00054ccc				; [34] = 5.3000
.long 0x00060000				; [35] = 6.0000
.long 0x00068000				; [36] = 6.5000
.long 0x00070000				; [37] = 7.0000
.long 0x00080000				; [38] = 8.0000
.long 0x00090000				; [39] = 9.0000
.long 0x000a0000				; [40] = 10.0000
.long 0x000b0000				; [41] = 11.0000
.long 0x000c0000				; [42] = 12.0000
.long 0x000d5553				; [43] = 13.3333
.long 0x000e0000				; [44] = 14.0000
.long 0x000f0000				; [45] = 15.0000
.long 0x00100000				; [46] = 16.0000
.long 0x00110000				; [47] = 17.0000
.long 0x00120000				; [48] = 18.0000
.long 0x00130000				; [49] = 19.0000
.long 0x00140000				; [50] = 20.0000
.long 0x00150000				; [51] = 21.0000
.long 0x00170000				; [52] = 23.0000
.long 0x00180000				; [53] = 24.0000
.long 0x00190000				; [54] = 25.0000
.long 0x001c0000				; [55] = 28.0000
.long 0x001e0000				; [56] = 30.0000
.long 0x001f0000				; [57] = 31.0000
.long 0x00200000				; [58] = 32.0000
.long 0x00210000				; [59] = 33.0000
.long 0x00230000				; [60] = 35.0000
.long 0x00260000				; [61] = 38.0000
.long 0x00270000				; [62] = 39.0000
.long 0x00280000				; [63] = 40.0000
.long 0x00290000				; [64] = 41.0000
.long 0x002a0000				; [65] = 42.0000
.long 0x002c0000				; [66] = 44.0000
.long 0x002d0000				; [67] = 45.0000
.long 0x00300000				; [68] = 48.0000
.long 0x00320000				; [69] = 50.0000
.long 0x00340000				; [70] = 52.0000
.long 0x003c0000				; [71] = 60.0000
.long 0x003e0000				; [72] = 62.0000
.long 0x003f0000				; [73] = 63.0000
.long 0x00400000				; [74] = 64.0000
.long 0x00403333				; [75] = 64.2000
.long 0x00410000				; [76] = 65.0000
.long 0x00440000				; [77] = 68.0000
.long 0x00460000				; [78] = 70.0000
.long 0x004a0000				; [79] = 74.0000
.long 0x004b0000				; [80] = 75.0000
.long 0x004e0000				; [81] = 78.0000
.long 0x00500000				; [82] = 80.0000
.long 0x00520000				; [83] = 82.0000
.long 0x00540000				; [84] = 84.0000
.long 0x00580000				; [85] = 88.0000
.long 0x005a0000				; [86] = 90.0000
.long 0x00600000				; [87] = 96.0000
.long 0x00630000				; [88] = 99.0000
.long 0x00640000				; [89] = 100.0000
.long 0x00670000				; [90] = 103.0000
.long 0x006e0000				; [91] = 110.0000
.long 0x00700000				; [92] = 112.0000
.long 0x00720000				; [93] = 114.0000
.long 0x00730000				; [94] = 115.0000
.long 0x00780000				; [95] = 120.0000
.long 0x007d0000				; [96] = 125.0000
.long 0x007f0000				; [97] = 127.0000
.long 0x00800000				; [98] = 128.0000
.long 0x00820000				; [99] = 130.0000
.long 0x00860000				; [100] = 134.0000
.long 0x00870000				; [101] = 135.0000
.long 0x008c0000				; [102] = 140.0000
.long 0x00960000				; [103] = 150.0000
.long 0x009a0000				; [104] = 154.0000
.long 0x009c0000				; [105] = 156.0000
.long 0x00a00000				; [106] = 160.0000
.long 0x00a20000				; [107] = 162.0000
.long 0x00b00000				; [108] = 176.0000
.long 0x00b40000				; [109] = 180.0000
.long 0x00b60000				; [110] = 182.0000
.long 0x00be0000				; [111] = 190.0000
.long 0x00c00000				; [112] = 192.0000
.long 0x00c80000				; [113] = 200.0000
.long 0x00cc0000				; [114] = 204.0000
.long 0x00d20000				; [115] = 210.0000
.long 0x00e00000				; [116] = 224.0000
.long 0x00f00000				; [117] = 240.0000
.long 0x00f40000				; [118] = 244.0000
.long 0x00fa0000				; [119] = 250.0000
.long 0x01000000				; [120] = 256.0000
.long 0x01180000				; [121] = 280.0000
.long 0x012c0000				; [122] = 300.0000
.long 0x01400000				; [123] = 320.0000
.long 0x014a0000				; [124] = 330.0000
.long 0x040f0f42				; [125] = 1039.0596
.long 0x081f1f82				; [126] = 2079.1231
.long 0x083f3082				; [127] = 2111.1895
.long 0x0fdf1f82				; [128] = 4063.1231
.long 0x0fff3082				; [129] = 4095.1895
.long 0x107e3c08				; [130] = 4222.2345
.long 0x107f2c49				; [131] = 4223.1730
.long 0x147f1c49				; [132] = 5247.1105
.long 0x14bc3c49				; [133] = 5308.2355
.long 0x185e1e86				; [134] = 6238.1192
.long 0x18710f46				; [135] = 6257.0597
.long 0x187f3c8a				; [136] = 6271.2365
.long 0x189c2186				; [137] = 6300.1310
.long 0x1fde1e86				; [138] = 8158.1192
.long 0x1fff34aa				; [139] = 8191.2057
.long 0x2fff3892				; [140] = 12287.2210
.long 0x2fff3f10				; [141] = 12287.2463
.long 0x3f9c1186				; [142] = 16284.0685
.long 0x3f9c19a6				; [143] = 16284.1002
.long 0x40bf3f08				; [144] = 16575.2462
.long 0x42303ff8				; [145] = 16944.2499
.long 0x4cbf3f0c				; [146] = 19647.2463
.long 0x7fffffff				; [147] = 32768.0000
.long 0x81c30313				; [148] = 33219.0120
.long 0x82071fa2				; [149] = 33287.1236
.long 0x82080820				; [150] = 33288.0317
.long 0x820f08f0				; [151] = 33295.0349
.long 0x823f3f20				; [152] = 33343.2466
.long 0x881f1f81				; [153] = 34847.1231
.long 0x927f0104				; [154] = 37503.0040
.long 0x98611bb6				; [155] = 39009.1082
.long 0x987f14aa				; [156] = 39039.0807
.long 0x989c2f46				; [157] = 39068.1847
.long 0x98bc3ba6				; [158] = 39100.2330
.long 0x9a6e19a6				; [159] = 39534.1002
.long 0x9a7226a6				; [160] = 39538.1510
.long 0x9a7f2186				; [161] = 39551.1310
.long 0x9be631e6				; [162] = 39910.1949
.long 0x9fff3624				; [163] = 40959.2115
.long 0xcfff3f10				; [164] = 53247.2463
.long 0xdfff0114				; [165] = 57343.0042
.long 0xdfff2196				; [166] = 57343.1312
.long 0xf0410107				; [167] = 61505.0040
.long 0xf8602087				; [168] = 63584.1271
.long 0xf8800083				; [169] = 63616.0020
.long 0xffe10087				; [170] = 65505.0021
.long 0x00240000				; [171] = 36.0000

; ============================================================================
; Color Script.
; ============================================================================

r_ColorScript:
.long -1, 0x00000000, 0x0166aaff, 0x026633aa, 0x03221188, 0x04000000, 0x05000000, 0x06000000, 0x07cceeff, 0x00000000, 0x0166aaff, 0x02330099, 0x03ffffff			; delta_frames=1 [0]
.long -420, 0x0366ddff			; delta_frames=420 [420]
.long -1, 0x0355aadd			; delta_frames=1 [421]
.long -1, 0x035577bb			; delta_frames=1 [422]
.long -1, 0x03443388			; delta_frames=1 [423]
.long -1, 0x03330066			; delta_frames=1 [424]
.long -8, 0x0366ddff			; delta_frames=8 [432]
.long -1, 0x0355aadd			; delta_frames=1 [433]
.long -1, 0x035577bb			; delta_frames=1 [434]
.long -1, 0x03443388			; delta_frames=1 [435]
.long -1, 0x03330066			; delta_frames=1 [436]
.long -16, 0x0366ddff			; delta_frames=16 [452]
.long -1, 0x0355aadd			; delta_frames=1 [453]
.long -1, 0x035577bb			; delta_frames=1 [454]
.long -1, 0x03443388			; delta_frames=1 [455]
.long -1, 0x03330066			; delta_frames=1 [456]
.long -60, 0x0366ddff			; delta_frames=60 [516]
.long -1, 0x0355aadd			; delta_frames=1 [517]
.long -1, 0x035577bb			; delta_frames=1 [518]
.long -1, 0x03443388			; delta_frames=1 [519]
.long -1, 0x03330066			; delta_frames=1 [520]
.long -8, 0x0366ddff			; delta_frames=8 [528]
.long -1, 0x0355aadd			; delta_frames=1 [529]
.long -1, 0x035577bb			; delta_frames=1 [530]
.long -1, 0x03443388			; delta_frames=1 [531]
.long -1, 0x03330066			; delta_frames=1 [532]
.long -16, 0x0366ddff			; delta_frames=16 [548]
.long -1, 0x0355aadd			; delta_frames=1 [549]
.long -1, 0x035577bb			; delta_frames=1 [550]
.long -1, 0x03443388			; delta_frames=1 [551]
.long -1, 0x03330066			; delta_frames=1 [552]
.long -60, 0x0366ddff			; delta_frames=60 [612]
.long -1, 0x0355aadd			; delta_frames=1 [613]
.long -1, 0x035577bb			; delta_frames=1 [614]
.long -1, 0x03443388			; delta_frames=1 [615]
.long -1, 0x03330066			; delta_frames=1 [616]
.long -8, 0x0366ddff			; delta_frames=8 [624]
.long -1, 0x0355aadd			; delta_frames=1 [625]
.long -1, 0x035577bb			; delta_frames=1 [626]
.long -1, 0x03443388			; delta_frames=1 [627]
.long -1, 0x03330066			; delta_frames=1 [628]
.long -16, 0x0366ddff			; delta_frames=16 [644]
.long -1, 0x0355aadd			; delta_frames=1 [645]
.long -1, 0x035577bb			; delta_frames=1 [646]
.long -1, 0x03443388			; delta_frames=1 [647]
.long -1, 0x03330066			; delta_frames=1 [648]
.long -60, 0x0366ddff			; delta_frames=60 [708]
.long -1, 0x0355aadd			; delta_frames=1 [709]
.long -1, 0x035577bb			; delta_frames=1 [710]
.long -1, 0x03443388			; delta_frames=1 [711]
.long -1, 0x03330066			; delta_frames=1 [712]
.long -8, 0x0366ddff			; delta_frames=8 [720]
.long -1, 0x0355aadd			; delta_frames=1 [721]
.long -1, 0x035577bb			; delta_frames=1 [722]
.long -1, 0x03443388			; delta_frames=1 [723]
.long -1, 0x03330066			; delta_frames=1 [724]
.long -16, 0x0366ddff			; delta_frames=16 [740]
.long -1, 0x0355aadd			; delta_frames=1 [741]
.long -1, 0x035577bb			; delta_frames=1 [742]
.long -1, 0x03443388			; delta_frames=1 [743]
.long -1, 0x03330066			; delta_frames=1 [744]
.long -1, 0x03331166			; delta_frames=1 [745]
.long -1, 0x016699ff, 0x02331199, 0x03331177			; delta_frames=1 [746]
.long -1, 0x016699ee, 0x023311aa, 0x03442277			; delta_frames=1 [747]
.long -1, 0x023322aa			; delta_frames=1 [748]
.long -1, 0x016688ee, 0x03443388			; delta_frames=1 [749]
.long -1, 0x00110000, 0x023333bb, 0x03553388			; delta_frames=1 [750]
.long -1, 0x015577dd, 0x03554499			; delta_frames=1 [751]
.long -2, 0x023344bb, 0x03555599			; delta_frames=2 [753]
.long -1, 0x015566dd, 0x035555aa			; delta_frames=1 [754]
.long -1, 0x015566cc, 0x023355cc, 0x036666aa			; delta_frames=1 [755]
.long -1, 0x00111111, 0x024455cc, 0x036677bb			; delta_frames=1 [756]
.long -1, 0x015555cc			; delta_frames=1 [757]
.long -1, 0x024466cc, 0x036688bb			; delta_frames=1 [758]
.long -1, 0x015544bb, 0x024466dd, 0x037788cc			; delta_frames=1 [759]
.long -1, 0x024477dd, 0x037799cc			; delta_frames=1 [760]
.long -2, 0x00221111, 0x015533bb, 0x024488ee, 0x0388aadd			; delta_frames=2 [762]
.long -1, 0x014433aa			; delta_frames=1 [763]
.long -1, 0x0388bbdd			; delta_frames=1 [764]
.long -1, 0x014422aa, 0x024499ee, 0x0388bbee			; delta_frames=1 [765]
.long -1, 0x0388ccee			; delta_frames=1 [766]
.long -1, 0x01441199, 0x0244aaff, 0x0399ccff			; delta_frames=1 [767]
.long -1, 0x0399ddff, 0x00554477			; delta_frames=1 [768]
.long -3, 0x00554466			; delta_frames=3 [771]
.long -2, 0x00443366			; delta_frames=2 [773]
.long -2, 0x00443355			; delta_frames=2 [775]
.long -4, 0x00443344			; delta_frames=4 [779]
.long -2, 0x00332244			; delta_frames=2 [781]
.long -2, 0x00332233			; delta_frames=2 [783]
.long -4, 0x00332222			; delta_frames=4 [787]
.long -2, 0x00221122			; delta_frames=2 [789]
.long -2, 0x00221111			; delta_frames=2 [791]
.long -361, 0x00554477			; delta_frames=361 [1152]
.long -3, 0x00554466			; delta_frames=3 [1155]
.long -2, 0x00443366			; delta_frames=2 [1157]
.long -2, 0x00443355			; delta_frames=2 [1159]
.long -4, 0x00443344			; delta_frames=4 [1163]
.long -2, 0x00332244			; delta_frames=2 [1165]
.long -2, 0x00332233			; delta_frames=2 [1167]
.long -4, 0x00332222			; delta_frames=4 [1171]
.long -2, 0x00221122			; delta_frames=2 [1173]
.long -2, 0x00221111			; delta_frames=2 [1175]
.long -361, 0x00554477			; delta_frames=361 [1536]
.long -3, 0x00554466			; delta_frames=3 [1539]
.long -2, 0x00443366			; delta_frames=2 [1541]
.long -2, 0x00443355			; delta_frames=2 [1543]
.long -4, 0x00443344			; delta_frames=4 [1547]
.long -2, 0x00332244			; delta_frames=2 [1549]
.long -2, 0x00332233			; delta_frames=2 [1551]
.long -4, 0x00332222			; delta_frames=4 [1555]
.long -2, 0x00221122			; delta_frames=2 [1557]
.long -2, 0x00221111			; delta_frames=2 [1559]
.long -67, 0x00000011, 0x015522bb, 0x0255aaff, 0x03ccffff			; delta_frames=67 [1626]
.long -6, 0x00221111, 0x01441199, 0x0244aaff, 0x0399ddff			; delta_frames=6 [1632]
.long -186, 0x00000011, 0x015522bb, 0x0255aaff, 0x03ccffff			; delta_frames=186 [1818]
.long -6, 0x00221111, 0x01441199, 0x0244aaff, 0x0399ddff			; delta_frames=6 [1824]
.long -96, 0x00554477			; delta_frames=96 [1920]
.long -3, 0x00554466			; delta_frames=3 [1923]
.long -2, 0x00443366			; delta_frames=2 [1925]
.long -2, 0x00443355			; delta_frames=2 [1927]
.long -4, 0x00443344			; delta_frames=4 [1931]
.long -2, 0x00332244			; delta_frames=2 [1933]
.long -2, 0x00332233			; delta_frames=2 [1935]
.long -4, 0x00332222			; delta_frames=4 [1939]
.long -2, 0x00221122			; delta_frames=2 [1941]
.long -2, 0x00221111			; delta_frames=2 [1943]
.long -67, 0x00000011, 0x015522bb, 0x0255aaff, 0x03ccffff			; delta_frames=67 [2010]
.long -6, 0x00221111, 0x01441199, 0x0244aaff, 0x0399ddff			; delta_frames=6 [2016]
.long -138, 0x00000011, 0x015522bb, 0x0255aaff, 0x03ccffff			; delta_frames=138 [2154]
.long -6, 0x00221111, 0x01441199, 0x0244aaff, 0x0399ddff			; delta_frames=6 [2160]
.long -144, 0x00554477			; delta_frames=144 [2304]
.long -3, 0x00554466			; delta_frames=3 [2307]
.long -2, 0x00443366			; delta_frames=2 [2309]
.long -2, 0x00443355			; delta_frames=2 [2311]
.long -4, 0x00443344			; delta_frames=4 [2315]
.long -2, 0x00332244			; delta_frames=2 [2317]
.long -2, 0x00332233			; delta_frames=2 [2319]
.long -4, 0x00332222			; delta_frames=4 [2323]
.long -2, 0x00221122			; delta_frames=2 [2325]
.long -2, 0x00221111			; delta_frames=2 [2327]
.long -13, 0x0366ddff			; delta_frames=13 [2340]
.long -1, 0x0355aadd			; delta_frames=1 [2341]
.long -1, 0x035577bb			; delta_frames=1 [2342]
.long -1, 0x03443388			; delta_frames=1 [2343]
.long -1, 0x03330066			; delta_frames=1 [2344]
.long -8, 0x0366ddff			; delta_frames=8 [2352]
.long -1, 0x0355aadd			; delta_frames=1 [2353]
.long -1, 0x035577bb			; delta_frames=1 [2354]
.long -1, 0x03443388			; delta_frames=1 [2355]
.long -1, 0x03330066			; delta_frames=1 [2356]
.long -16, 0x0366ddff			; delta_frames=16 [2372]
.long -1, 0x0355aadd			; delta_frames=1 [2373]
.long -1, 0x035577bb			; delta_frames=1 [2374]
.long -1, 0x03443388			; delta_frames=1 [2375]
.long -1, 0x03330066			; delta_frames=1 [2376]
.long -60, 0x0366ddff			; delta_frames=60 [2436]
.long -1, 0x0355aadd			; delta_frames=1 [2437]
.long -1, 0x035577bb			; delta_frames=1 [2438]
.long -1, 0x03443388			; delta_frames=1 [2439]
.long -1, 0x03330066			; delta_frames=1 [2440]
.long -8, 0x0366ddff			; delta_frames=8 [2448]
.long -1, 0x0355aadd			; delta_frames=1 [2449]
.long -1, 0x035577bb			; delta_frames=1 [2450]
.long -1, 0x03443388			; delta_frames=1 [2451]
.long -1, 0x03330066			; delta_frames=1 [2452]
.long -16, 0x0366ddff			; delta_frames=16 [2468]
.long -1, 0x0355aadd			; delta_frames=1 [2469]
.long -1, 0x035577bb			; delta_frames=1 [2470]
.long -1, 0x03443388			; delta_frames=1 [2471]
.long -1, 0x03330066			; delta_frames=1 [2472]
.long -60, 0x0366ddff			; delta_frames=60 [2532]
.long -1, 0x0355aadd			; delta_frames=1 [2533]
.long -1, 0x035577bb			; delta_frames=1 [2534]
.long -1, 0x03443388			; delta_frames=1 [2535]
.long -1, 0x03330066			; delta_frames=1 [2536]
.long -8, 0x0366ddff			; delta_frames=8 [2544]
.long -1, 0x0355aadd			; delta_frames=1 [2545]
.long -1, 0x035577bb			; delta_frames=1 [2546]
.long -1, 0x03443388			; delta_frames=1 [2547]
.long -1, 0x03330066			; delta_frames=1 [2548]
.long -16, 0x0366ddff			; delta_frames=16 [2564]
.long -1, 0x0355aadd			; delta_frames=1 [2565]
.long -1, 0x035577bb			; delta_frames=1 [2566]
.long -1, 0x03443388			; delta_frames=1 [2567]
.long -1, 0x03330066			; delta_frames=1 [2568]
.long -60, 0x0366ddff			; delta_frames=60 [2628]
.long -1, 0x0355aadd			; delta_frames=1 [2629]
.long -1, 0x035577bb			; delta_frames=1 [2630]
.long -1, 0x03443388			; delta_frames=1 [2631]
.long -1, 0x03330066			; delta_frames=1 [2632]
.long -8, 0x0366ddff			; delta_frames=8 [2640]
.long -1, 0x0355aadd			; delta_frames=1 [2641]
.long -1, 0x035577bb			; delta_frames=1 [2642]
.long -1, 0x03443388			; delta_frames=1 [2643]
.long -1, 0x03330066			; delta_frames=1 [2644]
.long -16, 0x0366ddff			; delta_frames=16 [2660]
.long -1, 0x0355aadd			; delta_frames=1 [2661]
.long -1, 0x035577bb			; delta_frames=1 [2662]
.long -1, 0x03443388			; delta_frames=1 [2663]
.long -1, 0x03330066			; delta_frames=1 [2664]
.long -60, 0x0366ddff			; delta_frames=60 [2724]
.long -1, 0x0355aadd			; delta_frames=1 [2725]
.long -1, 0x035577bb			; delta_frames=1 [2726]
.long -1, 0x03443388			; delta_frames=1 [2727]
.long -1, 0x03330066			; delta_frames=1 [2728]
.long -8, 0x0366ddff			; delta_frames=8 [2736]
.long -1, 0x0355aadd			; delta_frames=1 [2737]
.long -1, 0x035577bb			; delta_frames=1 [2738]
.long -1, 0x03443388			; delta_frames=1 [2739]
.long -1, 0x03330066			; delta_frames=1 [2740]
.long -16, 0x0366ddff			; delta_frames=16 [2756]
.long -1, 0x0355aadd			; delta_frames=1 [2757]
.long -1, 0x035577bb			; delta_frames=1 [2758]
.long -1, 0x03443388			; delta_frames=1 [2759]
.long -1, 0x03330066			; delta_frames=1 [2760]
.long -60, 0x0366ddff			; delta_frames=60 [2820]
.long -1, 0x0355aadd			; delta_frames=1 [2821]
.long -1, 0x035577bb			; delta_frames=1 [2822]
.long -1, 0x03443388			; delta_frames=1 [2823]
.long -1, 0x03330066			; delta_frames=1 [2824]
.long -8, 0x0366ddff			; delta_frames=8 [2832]
.long -1, 0x0355aadd			; delta_frames=1 [2833]
.long -1, 0x035577bb			; delta_frames=1 [2834]
.long -1, 0x03443388			; delta_frames=1 [2835]
.long -1, 0x03330066			; delta_frames=1 [2836]
.long -16, 0x0366ddff			; delta_frames=16 [2852]
.long -1, 0x0355aadd			; delta_frames=1 [2853]
.long -1, 0x035577bb			; delta_frames=1 [2854]
.long -1, 0x03443388			; delta_frames=1 [2855]
.long -1, 0x03330066			; delta_frames=1 [2856]
.long -60, 0x0366ddff			; delta_frames=60 [2916]
.long -1, 0x0355aadd			; delta_frames=1 [2917]
.long -1, 0x035577bb			; delta_frames=1 [2918]
.long -1, 0x03443388			; delta_frames=1 [2919]
.long -1, 0x03330066			; delta_frames=1 [2920]
.long -8, 0x0366ddff			; delta_frames=8 [2928]
.long -1, 0x0355aadd			; delta_frames=1 [2929]
.long -1, 0x035577bb			; delta_frames=1 [2930]
.long -1, 0x03443388			; delta_frames=1 [2931]
.long -1, 0x03330066			; delta_frames=1 [2932]
.long -16, 0x0366ddff			; delta_frames=16 [2948]
.long -1, 0x0355aadd			; delta_frames=1 [2949]
.long -1, 0x035577bb			; delta_frames=1 [2950]
.long -1, 0x03443388			; delta_frames=1 [2951]
.long -1, 0x03330066			; delta_frames=1 [2952]
.long -24, 0x01774433, 0x02998855, 0x00000000			; delta_frames=24 [2976]
.long -3, 0x00110000			; delta_frames=3 [2979]
.long -3, 0x00111111			; delta_frames=3 [2982]
.long -3, 0x00221111			; delta_frames=3 [2985]
.long -7, 0x00111111			; delta_frames=7 [2992]
.long -3, 0x00110000			; delta_frames=3 [2995]
.long -3, 0x00000000			; delta_frames=3 [2998]
.long -2, 0x00000000			; delta_frames=2 [3000]
.long -3, 0x00110000			; delta_frames=3 [3003]
.long -3, 0x00111111			; delta_frames=3 [3006]
.long -3, 0x00221111			; delta_frames=3 [3009]
.long -7, 0x00111111			; delta_frames=7 [3016]
.long -3, 0x00110000			; delta_frames=3 [3019]
.long -3, 0x00000000			; delta_frames=3 [3022]
.long -2, 0x00000000			; delta_frames=2 [3024]
.long -3, 0x00110000			; delta_frames=3 [3027]
.long -3, 0x00111111			; delta_frames=3 [3030]
.long -3, 0x00221111			; delta_frames=3 [3033]
.long -7, 0x00111111			; delta_frames=7 [3040]
.long -3, 0x00110000			; delta_frames=3 [3043]
.long -3, 0x00000000			; delta_frames=3 [3046]
.long -26, 0x00110022, 0x015555ff, 0x02111188, 0x03110066, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff, 0x00444444			; delta_frames=26 [3072]
.long -1, 0x00000000			; delta_frames=1 [3073]
.long -25, 0x053355ee, 0x0666ccee, 0x07eeeeee			; delta_frames=25 [3098]
.long -3, 0x053344dd, 0x0655ccdd, 0x07dddddd			; delta_frames=3 [3101]
.long -1, 0x0655bbdd			; delta_frames=1 [3102]
.long -3, 0x052244cc, 0x0655bbcc, 0x07cccccc			; delta_frames=3 [3105]
.long -1, 0x0655aacc			; delta_frames=1 [3106]
.long -2, 0x052244bb, 0x0655aabb, 0x07bbbbbb			; delta_frames=2 [3108]
.long -1, 0x064499bb			; delta_frames=1 [3109]
.long -2, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=2 [3111]
.long -2, 0x064488aa			; delta_frames=2 [3113]
.long -1, 0x05223399, 0x06448899, 0x07999999			; delta_frames=1 [3114]
.long -3, 0x05223388, 0x06337788, 0x07888888			; delta_frames=3 [3117]
.long -4, 0x05112277, 0x06336677, 0x07777777			; delta_frames=4 [3121]
.long -3, 0x05112266, 0x06335566, 0x07666666			; delta_frames=3 [3124]
.long -1, 0x06225566			; delta_frames=1 [3125]
.long -2, 0x05112255, 0x06225555, 0x07555555			; delta_frames=2 [3127]
.long -1, 0x06224455			; delta_frames=1 [3128]
.long -2, 0x05111144, 0x06224444, 0x07444444			; delta_frames=2 [3130]
.long -2, 0x06223344			; delta_frames=2 [3132]
.long -1, 0x05111133, 0x06113333, 0x07333333			; delta_frames=1 [3133]
.long -2, 0x06112233			; delta_frames=2 [3135]
.long -2, 0x05001122, 0x06112222, 0x07222222			; delta_frames=2 [3137]
.long -2, 0x06111122			; delta_frames=2 [3139]
.long -1, 0x05000011, 0x06111111, 0x07111111			; delta_frames=1 [3140]
.long -1, 0x06001111			; delta_frames=1 [3141]
.long -2, 0x05000000, 0x06000000, 0x07000000			; delta_frames=2 [3143]
.long -1, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=1 [3144]
.long -528, 0x00444444			; delta_frames=528 [3672]
.long -1, 0x00000000			; delta_frames=1 [3673]
.long -24, 0x053355ee, 0x0666ccee, 0x07eeeeee			; delta_frames=24 [3697]
.long -2, 0x053344dd, 0x0655bbdd, 0x07dddddd			; delta_frames=2 [3699]
.long -2, 0x052244cc, 0x0655aacc, 0x07cccccc			; delta_frames=2 [3701]
.long -1, 0x052244bb, 0x0655aabb, 0x07bbbbbb			; delta_frames=1 [3702]
.long -1, 0x064499bb			; delta_frames=1 [3703]
.long -1, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=1 [3704]
.long -1, 0x05223399, 0x06448899, 0x07999999			; delta_frames=1 [3705]
.long -2, 0x05223388, 0x06337788, 0x07888888			; delta_frames=2 [3707]
.long -2, 0x05112277, 0x06336677, 0x07777777			; delta_frames=2 [3709]
.long -1, 0x05112266, 0x06335566, 0x07666666			; delta_frames=1 [3710]
.long -1, 0x06225566			; delta_frames=1 [3711]
.long -1, 0x05112255, 0x06224455, 0x07555555			; delta_frames=1 [3712]
.long -1, 0x05111144, 0x06224444, 0x07444444			; delta_frames=1 [3713]
.long -1, 0x06223344			; delta_frames=1 [3714]
.long -1, 0x05111133, 0x06113333, 0x07333333			; delta_frames=1 [3715]
.long -1, 0x06112233			; delta_frames=1 [3716]
.long -1, 0x05001122, 0x06112222, 0x07222222			; delta_frames=1 [3717]
.long -1, 0x05000011, 0x06111111, 0x07111111			; delta_frames=1 [3718]
.long -1, 0x06001111			; delta_frames=1 [3719]
.long -1, 0x05000000, 0x06000000, 0x07000000, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=1 [3720]
.long -720, 0x00444444			; delta_frames=720 [4440]
.long -1, 0x00000000			; delta_frames=1 [4441]
.long -24, 0x053355ee, 0x0666ccee, 0x07eeeeee			; delta_frames=24 [4465]
.long -2, 0x053344dd, 0x0655bbdd, 0x07dddddd			; delta_frames=2 [4467]
.long -2, 0x052244cc, 0x0655aacc, 0x07cccccc			; delta_frames=2 [4469]
.long -1, 0x052244bb, 0x0655aabb, 0x07bbbbbb			; delta_frames=1 [4470]
.long -1, 0x064499bb			; delta_frames=1 [4471]
.long -1, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=1 [4472]
.long -1, 0x05223399, 0x06448899, 0x07999999			; delta_frames=1 [4473]
.long -2, 0x05223388, 0x06337788, 0x07888888			; delta_frames=2 [4475]
.long -2, 0x05112277, 0x06336677, 0x07777777			; delta_frames=2 [4477]
.long -1, 0x05112266, 0x06335566, 0x07666666			; delta_frames=1 [4478]
.long -1, 0x06225566			; delta_frames=1 [4479]
.long -1, 0x05112255, 0x06224455, 0x07555555			; delta_frames=1 [4480]
.long -1, 0x05111144, 0x06224444, 0x07444444			; delta_frames=1 [4481]
.long -1, 0x06223344			; delta_frames=1 [4482]
.long -1, 0x05111133, 0x06113333, 0x07333333			; delta_frames=1 [4483]
.long -1, 0x06112233			; delta_frames=1 [4484]
.long -1, 0x05001122, 0x06112222, 0x07222222			; delta_frames=1 [4485]
.long -1, 0x05000011, 0x06111111, 0x07111111			; delta_frames=1 [4486]
.long -1, 0x06001111			; delta_frames=1 [4487]
.long -1, 0x05000000, 0x06000000, 0x07000000, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=1 [4488]
.long -120, 0x00000000, 0x01333333, 0x02777777, 0x03ffffff, 0x04000000, 0x05330033, 0x063300aa, 0x063300dd, 0x063300aa			; delta_frames=120 [4608]
.long -2, 0x06330099			; delta_frames=2 [4610]
.long -1, 0x06440099			; delta_frames=1 [4611]
.long -2, 0x06440088			; delta_frames=2 [4613]
.long -1, 0x06550088			; delta_frames=1 [4614]
.long -2, 0x06550077			; delta_frames=2 [4616]
.long -3, 0x06660066			; delta_frames=3 [4619]
.long -13, 0x063300aa			; delta_frames=13 [4632]
.long -2, 0x06330099			; delta_frames=2 [4634]
.long -1, 0x06440099			; delta_frames=1 [4635]
.long -2, 0x06440088			; delta_frames=2 [4637]
.long -1, 0x06550088			; delta_frames=1 [4638]
.long -2, 0x06550077			; delta_frames=2 [4640]
.long -3, 0x06660066			; delta_frames=3 [4643]
.long -13, 0x063300aa			; delta_frames=13 [4656]
.long -2, 0x06330099			; delta_frames=2 [4658]
.long -1, 0x06440099			; delta_frames=1 [4659]
.long -2, 0x06440088			; delta_frames=2 [4661]
.long -1, 0x06550088			; delta_frames=1 [4662]
.long -2, 0x06550077			; delta_frames=2 [4664]
.long -3, 0x06660066			; delta_frames=3 [4667]
.long -13, 0x063300aa			; delta_frames=13 [4680]
.long -2, 0x06330099			; delta_frames=2 [4682]
.long -1, 0x06440099			; delta_frames=1 [4683]
.long -2, 0x06440088			; delta_frames=2 [4685]
.long -1, 0x06550088			; delta_frames=1 [4686]
.long -2, 0x06550077			; delta_frames=2 [4688]
.long -3, 0x06660066			; delta_frames=3 [4691]
.long -13, 0x063300aa			; delta_frames=13 [4704]
.long -2, 0x06330099			; delta_frames=2 [4706]
.long -1, 0x06440099			; delta_frames=1 [4707]
.long -2, 0x06440088			; delta_frames=2 [4709]
.long -1, 0x06550088			; delta_frames=1 [4710]
.long -2, 0x06550077			; delta_frames=2 [4712]
.long -3, 0x06660066			; delta_frames=3 [4715]
.long -13, 0x063300aa			; delta_frames=13 [4728]
.long -2, 0x06330099			; delta_frames=2 [4730]
.long -1, 0x06440099			; delta_frames=1 [4731]
.long -2, 0x06440088			; delta_frames=2 [4733]
.long -1, 0x06550088			; delta_frames=1 [4734]
.long -2, 0x06550077			; delta_frames=2 [4736]
.long -3, 0x06660066			; delta_frames=3 [4739]
.long -13, 0x063300aa			; delta_frames=13 [4752]
.long -2, 0x06330099			; delta_frames=2 [4754]
.long -1, 0x06440099			; delta_frames=1 [4755]
.long -2, 0x06440088			; delta_frames=2 [4757]
.long -1, 0x06550088			; delta_frames=1 [4758]
.long -2, 0x06550077			; delta_frames=2 [4760]
.long -3, 0x06660066			; delta_frames=3 [4763]
.long -13, 0x063300aa			; delta_frames=13 [4776]
.long -2, 0x06330099			; delta_frames=2 [4778]
.long -1, 0x06440099			; delta_frames=1 [4779]
.long -2, 0x06440088			; delta_frames=2 [4781]
.long -1, 0x06550088			; delta_frames=1 [4782]
.long -2, 0x06550077			; delta_frames=2 [4784]
.long -3, 0x06660066			; delta_frames=3 [4787]
.long -13, 0x063300aa			; delta_frames=13 [4800]
.long -2, 0x06330099			; delta_frames=2 [4802]
.long -1, 0x06440099			; delta_frames=1 [4803]
.long -2, 0x06440088			; delta_frames=2 [4805]
.long -1, 0x06550088			; delta_frames=1 [4806]
.long -2, 0x06550077			; delta_frames=2 [4808]
.long -3, 0x06660066			; delta_frames=3 [4811]
.long -13, 0x063300aa			; delta_frames=13 [4824]
.long -2, 0x06330099			; delta_frames=2 [4826]
.long -1, 0x06440099			; delta_frames=1 [4827]
.long -2, 0x06440088			; delta_frames=2 [4829]
.long -1, 0x06550088			; delta_frames=1 [4830]
.long -2, 0x06550077			; delta_frames=2 [4832]
.long -3, 0x06660066			; delta_frames=3 [4835]
.long -13, 0x063300aa			; delta_frames=13 [4848]
.long -2, 0x06330099			; delta_frames=2 [4850]
.long -1, 0x06440099			; delta_frames=1 [4851]
.long -2, 0x06440088			; delta_frames=2 [4853]
.long -1, 0x06550088			; delta_frames=1 [4854]
.long -2, 0x06550077			; delta_frames=2 [4856]
.long -3, 0x06660066			; delta_frames=3 [4859]
.long -13, 0x063300aa			; delta_frames=13 [4872]
.long -2, 0x06330099			; delta_frames=2 [4874]
.long -1, 0x06440099			; delta_frames=1 [4875]
.long -2, 0x06440088			; delta_frames=2 [4877]
.long -1, 0x06550088			; delta_frames=1 [4878]
.long -2, 0x06550077			; delta_frames=2 [4880]
.long -3, 0x06660066			; delta_frames=3 [4883]
.long -13, 0x063300aa			; delta_frames=13 [4896]
.long -2, 0x06330099			; delta_frames=2 [4898]
.long -1, 0x06440099			; delta_frames=1 [4899]
.long -2, 0x06440088			; delta_frames=2 [4901]
.long -1, 0x06550088			; delta_frames=1 [4902]
.long -2, 0x06550077			; delta_frames=2 [4904]
.long -3, 0x06660066			; delta_frames=3 [4907]
.long -13, 0x063300aa			; delta_frames=13 [4920]
.long -2, 0x06330099			; delta_frames=2 [4922]
.long -1, 0x06440099			; delta_frames=1 [4923]
.long -2, 0x06440088			; delta_frames=2 [4925]
.long -1, 0x06550088			; delta_frames=1 [4926]
.long -2, 0x06550077			; delta_frames=2 [4928]
.long -3, 0x06660066			; delta_frames=3 [4931]
.long -13, 0x063300aa			; delta_frames=13 [4944]
.long -2, 0x06330099			; delta_frames=2 [4946]
.long -1, 0x06440099			; delta_frames=1 [4947]
.long -2, 0x06440088			; delta_frames=2 [4949]
.long -1, 0x06550088			; delta_frames=1 [4950]
.long -2, 0x06550077			; delta_frames=2 [4952]
.long -3, 0x06660066			; delta_frames=3 [4955]
.long -13, 0x063300aa			; delta_frames=13 [4968]
.long -2, 0x06330099			; delta_frames=2 [4970]
.long -1, 0x06440099			; delta_frames=1 [4971]
.long -2, 0x06440088			; delta_frames=2 [4973]
.long -1, 0x06550088			; delta_frames=1 [4974]
.long -2, 0x06550077			; delta_frames=2 [4976]
.long -3, 0x06660066			; delta_frames=3 [4979]
.long -13, 0x063300aa			; delta_frames=13 [4992]
.long -2, 0x06330099			; delta_frames=2 [4994]
.long -1, 0x06440099			; delta_frames=1 [4995]
.long -2, 0x06440088			; delta_frames=2 [4997]
.long -1, 0x06550088			; delta_frames=1 [4998]
.long -2, 0x06550077			; delta_frames=2 [5000]
.long -3, 0x06660066			; delta_frames=3 [5003]
.long -13, 0x063300aa			; delta_frames=13 [5016]
.long -2, 0x06330099			; delta_frames=2 [5018]
.long -1, 0x06440099			; delta_frames=1 [5019]
.long -2, 0x06440088			; delta_frames=2 [5021]
.long -1, 0x06550088			; delta_frames=1 [5022]
.long -2, 0x06550077			; delta_frames=2 [5024]
.long -3, 0x06660066			; delta_frames=3 [5027]
.long -13, 0x063300aa			; delta_frames=13 [5040]
.long -2, 0x06330099			; delta_frames=2 [5042]
.long -1, 0x06440099			; delta_frames=1 [5043]
.long -2, 0x06440088			; delta_frames=2 [5045]
.long -1, 0x06550088			; delta_frames=1 [5046]
.long -2, 0x06550077			; delta_frames=2 [5048]
.long -3, 0x06660066			; delta_frames=3 [5051]
.long -13, 0x063300aa			; delta_frames=13 [5064]
.long -2, 0x06330099			; delta_frames=2 [5066]
.long -1, 0x06440099			; delta_frames=1 [5067]
.long -2, 0x06440088			; delta_frames=2 [5069]
.long -1, 0x06550088			; delta_frames=1 [5070]
.long -2, 0x06550077			; delta_frames=2 [5072]
.long -3, 0x06660066			; delta_frames=3 [5075]
.long -13, 0x063300aa			; delta_frames=13 [5088]
.long -2, 0x06330099			; delta_frames=2 [5090]
.long -1, 0x06440099			; delta_frames=1 [5091]
.long -2, 0x06440088			; delta_frames=2 [5093]
.long -1, 0x06550088			; delta_frames=1 [5094]
.long -2, 0x06550077			; delta_frames=2 [5096]
.long -3, 0x06660066			; delta_frames=3 [5099]
.long -13, 0x063300aa			; delta_frames=13 [5112]
.long -2, 0x06330099			; delta_frames=2 [5114]
.long -1, 0x06440099			; delta_frames=1 [5115]
.long -2, 0x06440088			; delta_frames=2 [5117]
.long -1, 0x06550088			; delta_frames=1 [5118]
.long -2, 0x06550077			; delta_frames=2 [5120]
.long -3, 0x06660066			; delta_frames=3 [5123]
.long -13, 0x063300aa			; delta_frames=13 [5136]
.long -2, 0x06330099			; delta_frames=2 [5138]
.long -1, 0x06440099			; delta_frames=1 [5139]
.long -2, 0x06440088			; delta_frames=2 [5141]
.long -1, 0x06550088			; delta_frames=1 [5142]
.long -2, 0x06550077			; delta_frames=2 [5144]
.long -3, 0x06660066			; delta_frames=3 [5147]
.long -13, 0x063300aa			; delta_frames=13 [5160]
.long -4, 0x06220022			; delta_frames=4 [5164]
.long -4, 0x063300aa			; delta_frames=4 [5168]
.long -8, 0x06220022			; delta_frames=8 [5176]
.long -4, 0x063300aa			; delta_frames=4 [5180]
.long -2, 0x06220022			; delta_frames=2 [5182]
.long -2, 0x063300aa			; delta_frames=2 [5184]
.long -2, 0x06330099			; delta_frames=2 [5186]
.long -1, 0x06440099			; delta_frames=1 [5187]
.long -2, 0x06440088			; delta_frames=2 [5189]
.long -1, 0x06550088			; delta_frames=1 [5190]
.long -2, 0x06550077			; delta_frames=2 [5192]
.long -3, 0x06660066			; delta_frames=3 [5195]
.long -13, 0x063300aa			; delta_frames=13 [5208]
.long -2, 0x06330099			; delta_frames=2 [5210]
.long -1, 0x06440099			; delta_frames=1 [5211]
.long -2, 0x06440088			; delta_frames=2 [5213]
.long -1, 0x06550088			; delta_frames=1 [5214]
.long -2, 0x06550077			; delta_frames=2 [5216]
.long -3, 0x06660066			; delta_frames=3 [5219]
.long -13, 0x063300aa			; delta_frames=13 [5232]
.long -2, 0x06330099			; delta_frames=2 [5234]
.long -1, 0x06440099			; delta_frames=1 [5235]
.long -2, 0x06440088			; delta_frames=2 [5237]
.long -1, 0x06550088			; delta_frames=1 [5238]
.long -2, 0x06550077			; delta_frames=2 [5240]
.long -3, 0x06660066			; delta_frames=3 [5243]
.long -13, 0x063300aa			; delta_frames=13 [5256]
.long -2, 0x06330099			; delta_frames=2 [5258]
.long -1, 0x06440099			; delta_frames=1 [5259]
.long -2, 0x06440088			; delta_frames=2 [5261]
.long -1, 0x06550088			; delta_frames=1 [5262]
.long -2, 0x06550077			; delta_frames=2 [5264]
.long -3, 0x06660066			; delta_frames=3 [5267]
.long -13, 0x063300aa			; delta_frames=13 [5280]
.long -2, 0x06330099			; delta_frames=2 [5282]
.long -1, 0x06440099			; delta_frames=1 [5283]
.long -2, 0x06440088			; delta_frames=2 [5285]
.long -1, 0x06550088			; delta_frames=1 [5286]
.long -2, 0x06550077			; delta_frames=2 [5288]
.long -3, 0x06660066			; delta_frames=3 [5291]
.long -13, 0x063300aa			; delta_frames=13 [5304]
.long -2, 0x06330099			; delta_frames=2 [5306]
.long -1, 0x06440099			; delta_frames=1 [5307]
.long -2, 0x06440088			; delta_frames=2 [5309]
.long -1, 0x06550088			; delta_frames=1 [5310]
.long -2, 0x06550077			; delta_frames=2 [5312]
.long -3, 0x06660066			; delta_frames=3 [5315]
.long -13, 0x063300aa			; delta_frames=13 [5328]
.long -2, 0x06330099			; delta_frames=2 [5330]
.long -1, 0x06440099			; delta_frames=1 [5331]
.long -2, 0x06440088			; delta_frames=2 [5333]
.long -1, 0x06550088			; delta_frames=1 [5334]
.long -2, 0x06550077			; delta_frames=2 [5336]
.long -3, 0x06660066			; delta_frames=3 [5339]
.long -13, 0x063300aa			; delta_frames=13 [5352]
.long -1, 0x06330099			; delta_frames=1 [5353]
.long -1, 0x06440099			; delta_frames=1 [5354]
.long -1, 0x06550088			; delta_frames=1 [5355]
.long -1, 0x06550077			; delta_frames=1 [5356]
.long -2, 0x06660066			; delta_frames=2 [5358]
.long -6, 0x063300aa			; delta_frames=6 [5364]
.long -1, 0x06330099			; delta_frames=1 [5365]
.long -1, 0x06440099			; delta_frames=1 [5366]
.long -1, 0x06550088			; delta_frames=1 [5367]
.long -1, 0x06550077			; delta_frames=1 [5368]
.long -2, 0x06660066			; delta_frames=2 [5370]
.long -6, 0x063300aa			; delta_frames=6 [5376]
.long -2, 0x06330099			; delta_frames=2 [5378]
.long -1, 0x06440099			; delta_frames=1 [5379]
.long -2, 0x06440088			; delta_frames=2 [5381]
.long -1, 0x06550088			; delta_frames=1 [5382]
.long -2, 0x06550077			; delta_frames=2 [5384]
.long -3, 0x06660066			; delta_frames=3 [5387]
.long -13, 0x063300aa			; delta_frames=13 [5400]
.long -2, 0x06330099			; delta_frames=2 [5402]
.long -1, 0x06440099			; delta_frames=1 [5403]
.long -2, 0x06440088			; delta_frames=2 [5405]
.long -1, 0x06550088			; delta_frames=1 [5406]
.long -2, 0x06550077			; delta_frames=2 [5408]
.long -3, 0x06660066			; delta_frames=3 [5411]
.long -13, 0x063300aa			; delta_frames=13 [5424]
.long -2, 0x06330099			; delta_frames=2 [5426]
.long -1, 0x06440099			; delta_frames=1 [5427]
.long -2, 0x06440088			; delta_frames=2 [5429]
.long -1, 0x06550088			; delta_frames=1 [5430]
.long -2, 0x06550077			; delta_frames=2 [5432]
.long -3, 0x06660066			; delta_frames=3 [5435]
.long -13, 0x063300aa			; delta_frames=13 [5448]
.long -2, 0x06330099			; delta_frames=2 [5450]
.long -1, 0x06440099			; delta_frames=1 [5451]
.long -2, 0x06440088			; delta_frames=2 [5453]
.long -1, 0x06550088			; delta_frames=1 [5454]
.long -2, 0x06550077			; delta_frames=2 [5456]
.long -3, 0x06660066			; delta_frames=3 [5459]
.long -13, 0x063300aa			; delta_frames=13 [5472]
.long -2, 0x06330099			; delta_frames=2 [5474]
.long -1, 0x06440099			; delta_frames=1 [5475]
.long -2, 0x06440088			; delta_frames=2 [5477]
.long -1, 0x06550088			; delta_frames=1 [5478]
.long -2, 0x06550077			; delta_frames=2 [5480]
.long -3, 0x06660066			; delta_frames=3 [5483]
.long -13, 0x063300aa			; delta_frames=13 [5496]
.long -2, 0x06330099			; delta_frames=2 [5498]
.long -1, 0x06440099			; delta_frames=1 [5499]
.long -2, 0x06440088			; delta_frames=2 [5501]
.long -1, 0x06550088			; delta_frames=1 [5502]
.long -2, 0x06550077			; delta_frames=2 [5504]
.long -3, 0x06660066			; delta_frames=3 [5507]
.long -13, 0x063300aa			; delta_frames=13 [5520]
.long -2, 0x06330099			; delta_frames=2 [5522]
.long -1, 0x06440099			; delta_frames=1 [5523]
.long -2, 0x06440088			; delta_frames=2 [5525]
.long -1, 0x06550088			; delta_frames=1 [5526]
.long -2, 0x06550077			; delta_frames=2 [5528]
.long -3, 0x06660066			; delta_frames=3 [5531]
.long -13, 0x063300aa			; delta_frames=13 [5544]
.long -2, 0x06330099			; delta_frames=2 [5546]
.long -1, 0x06440099			; delta_frames=1 [5547]
.long -2, 0x06440088			; delta_frames=2 [5549]
.long -1, 0x06550088			; delta_frames=1 [5550]
.long -2, 0x06550077			; delta_frames=2 [5552]
.long -3, 0x06660066			; delta_frames=3 [5555]
.long -13, 0x063300aa			; delta_frames=13 [5568]
.long -2, 0x06330099			; delta_frames=2 [5570]
.long -1, 0x06440099			; delta_frames=1 [5571]
.long -2, 0x06440088			; delta_frames=2 [5573]
.long -1, 0x06550088			; delta_frames=1 [5574]
.long -2, 0x06550077			; delta_frames=2 [5576]
.long -3, 0x06660066			; delta_frames=3 [5579]
.long -13, 0x063300aa			; delta_frames=13 [5592]
.long -2, 0x06330099			; delta_frames=2 [5594]
.long -1, 0x06440099			; delta_frames=1 [5595]
.long -2, 0x06440088			; delta_frames=2 [5597]
.long -1, 0x06550088			; delta_frames=1 [5598]
.long -2, 0x06550077			; delta_frames=2 [5600]
.long -3, 0x06660066			; delta_frames=3 [5603]
.long -13, 0x063300aa			; delta_frames=13 [5616]
.long -2, 0x06330099			; delta_frames=2 [5618]
.long -1, 0x06440099			; delta_frames=1 [5619]
.long -2, 0x06440088			; delta_frames=2 [5621]
.long -1, 0x06550088			; delta_frames=1 [5622]
.long -2, 0x06550077			; delta_frames=2 [5624]
.long -3, 0x06660066			; delta_frames=3 [5627]
.long -13, 0x063300aa			; delta_frames=13 [5640]
.long -2, 0x06330099			; delta_frames=2 [5642]
.long -1, 0x06440099			; delta_frames=1 [5643]
.long -2, 0x06440088			; delta_frames=2 [5645]
.long -1, 0x06550088			; delta_frames=1 [5646]
.long -2, 0x06550077			; delta_frames=2 [5648]
.long -3, 0x06660066			; delta_frames=3 [5651]
.long -13, 0x063300aa			; delta_frames=13 [5664]
.long -2, 0x06330099			; delta_frames=2 [5666]
.long -1, 0x06440099			; delta_frames=1 [5667]
.long -2, 0x06440088			; delta_frames=2 [5669]
.long -1, 0x06550088			; delta_frames=1 [5670]
.long -2, 0x06550077			; delta_frames=2 [5672]
.long -3, 0x06660066			; delta_frames=3 [5675]
.long -13, 0x063300aa			; delta_frames=13 [5688]
.long -2, 0x06330099			; delta_frames=2 [5690]
.long -1, 0x06440099			; delta_frames=1 [5691]
.long -2, 0x06440088			; delta_frames=2 [5693]
.long -1, 0x06550088			; delta_frames=1 [5694]
.long -2, 0x06550077			; delta_frames=2 [5696]
.long -3, 0x06660066			; delta_frames=3 [5699]
.long -13, 0x063300aa			; delta_frames=13 [5712]
.long -2, 0x06440099			; delta_frames=2 [5714]
.long -2, 0x06550088			; delta_frames=2 [5716]
.long -2, 0x06550077			; delta_frames=2 [5718]
.long -1, 0x06660077			; delta_frames=1 [5719]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [5720]
.long -2, 0x06440099			; delta_frames=2 [5722]
.long -2, 0x06550088			; delta_frames=2 [5724]
.long -2, 0x06550077			; delta_frames=2 [5726]
.long -1, 0x06660077			; delta_frames=1 [5727]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [5728]
.long -2, 0x06440099			; delta_frames=2 [5730]
.long -2, 0x06550088			; delta_frames=2 [5732]
.long -2, 0x06550077			; delta_frames=2 [5734]
.long -1, 0x06660077			; delta_frames=1 [5735]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [5736]
.long -2, 0x06440099			; delta_frames=2 [5738]
.long -2, 0x06550088			; delta_frames=2 [5740]
.long -2, 0x06550077			; delta_frames=2 [5742]
.long -1, 0x06660077			; delta_frames=1 [5743]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [5744]
.long -2, 0x06440099			; delta_frames=2 [5746]
.long -2, 0x06550088			; delta_frames=2 [5748]
.long -2, 0x06550077			; delta_frames=2 [5750]
.long -1, 0x06660077			; delta_frames=1 [5751]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [5752]
.long -2, 0x06440099			; delta_frames=2 [5754]
.long -2, 0x06550088			; delta_frames=2 [5756]
.long -2, 0x06550077			; delta_frames=2 [5758]
.long -1, 0x06660077			; delta_frames=1 [5759]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [5760]
.long -2, 0x06330099			; delta_frames=2 [5762]
.long -1, 0x06440099			; delta_frames=1 [5763]
.long -2, 0x06440088			; delta_frames=2 [5765]
.long -1, 0x06550088			; delta_frames=1 [5766]
.long -2, 0x06550077			; delta_frames=2 [5768]
.long -3, 0x06660066			; delta_frames=3 [5771]
.long -13, 0x063300aa			; delta_frames=13 [5784]
.long -2, 0x06330099			; delta_frames=2 [5786]
.long -1, 0x06440099			; delta_frames=1 [5787]
.long -2, 0x06440088			; delta_frames=2 [5789]
.long -1, 0x06550088			; delta_frames=1 [5790]
.long -2, 0x06550077			; delta_frames=2 [5792]
.long -3, 0x06660066			; delta_frames=3 [5795]
.long -13, 0x063300aa			; delta_frames=13 [5808]
.long -2, 0x06330099			; delta_frames=2 [5810]
.long -1, 0x06440099			; delta_frames=1 [5811]
.long -2, 0x06440088			; delta_frames=2 [5813]
.long -1, 0x06550088			; delta_frames=1 [5814]
.long -2, 0x06550077			; delta_frames=2 [5816]
.long -3, 0x06660066			; delta_frames=3 [5819]
.long -13, 0x063300aa			; delta_frames=13 [5832]
.long -2, 0x06330099			; delta_frames=2 [5834]
.long -1, 0x06440099			; delta_frames=1 [5835]
.long -2, 0x06440088			; delta_frames=2 [5837]
.long -1, 0x06550088			; delta_frames=1 [5838]
.long -2, 0x06550077			; delta_frames=2 [5840]
.long -3, 0x06660066			; delta_frames=3 [5843]
.long -13, 0x063300aa			; delta_frames=13 [5856]
.long -2, 0x06330099			; delta_frames=2 [5858]
.long -1, 0x06440099			; delta_frames=1 [5859]
.long -2, 0x06440088			; delta_frames=2 [5861]
.long -1, 0x06550088			; delta_frames=1 [5862]
.long -2, 0x06550077			; delta_frames=2 [5864]
.long -3, 0x06660066			; delta_frames=3 [5867]
.long -13, 0x063300aa			; delta_frames=13 [5880]
.long -2, 0x06330099			; delta_frames=2 [5882]
.long -1, 0x06440099			; delta_frames=1 [5883]
.long -2, 0x06440088			; delta_frames=2 [5885]
.long -1, 0x06550088			; delta_frames=1 [5886]
.long -2, 0x06550077			; delta_frames=2 [5888]
.long -3, 0x06660066			; delta_frames=3 [5891]
.long -13, 0x063300aa			; delta_frames=13 [5904]
.long -2, 0x06330099			; delta_frames=2 [5906]
.long -1, 0x06440099			; delta_frames=1 [5907]
.long -2, 0x06440088			; delta_frames=2 [5909]
.long -1, 0x06550088			; delta_frames=1 [5910]
.long -2, 0x06550077			; delta_frames=2 [5912]
.long -3, 0x06660066			; delta_frames=3 [5915]
.long -13, 0x063300aa			; delta_frames=13 [5928]
.long -4, 0x06220022			; delta_frames=4 [5932]
.long -4, 0x063300aa			; delta_frames=4 [5936]
.long -8, 0x06220022			; delta_frames=8 [5944]
.long -4, 0x063300aa			; delta_frames=4 [5948]
.long -2, 0x06220022			; delta_frames=2 [5950]
.long -2, 0x063300aa			; delta_frames=2 [5952]
.long -2, 0x06330099			; delta_frames=2 [5954]
.long -1, 0x06440099			; delta_frames=1 [5955]
.long -2, 0x06440088			; delta_frames=2 [5957]
.long -1, 0x06550088			; delta_frames=1 [5958]
.long -2, 0x06550077			; delta_frames=2 [5960]
.long -3, 0x06660066			; delta_frames=3 [5963]
.long -13, 0x063300aa			; delta_frames=13 [5976]
.long -2, 0x06330099			; delta_frames=2 [5978]
.long -1, 0x06440099			; delta_frames=1 [5979]
.long -2, 0x06440088			; delta_frames=2 [5981]
.long -1, 0x06550088			; delta_frames=1 [5982]
.long -2, 0x06550077			; delta_frames=2 [5984]
.long -3, 0x06660066			; delta_frames=3 [5987]
.long -13, 0x063300aa			; delta_frames=13 [6000]
.long -2, 0x06330099			; delta_frames=2 [6002]
.long -1, 0x06440099			; delta_frames=1 [6003]
.long -2, 0x06440088			; delta_frames=2 [6005]
.long -1, 0x06550088			; delta_frames=1 [6006]
.long -2, 0x06550077			; delta_frames=2 [6008]
.long -3, 0x06660066			; delta_frames=3 [6011]
.long -13, 0x063300aa			; delta_frames=13 [6024]
.long -2, 0x06330099			; delta_frames=2 [6026]
.long -1, 0x06440099			; delta_frames=1 [6027]
.long -2, 0x06440088			; delta_frames=2 [6029]
.long -1, 0x06550088			; delta_frames=1 [6030]
.long -2, 0x06550077			; delta_frames=2 [6032]
.long -3, 0x06660066			; delta_frames=3 [6035]
.long -13, 0x063300aa			; delta_frames=13 [6048]
.long -2, 0x06330099			; delta_frames=2 [6050]
.long -1, 0x06440099			; delta_frames=1 [6051]
.long -2, 0x06440088			; delta_frames=2 [6053]
.long -1, 0x06550088			; delta_frames=1 [6054]
.long -2, 0x06550077			; delta_frames=2 [6056]
.long -3, 0x06660066			; delta_frames=3 [6059]
.long -13, 0x063300aa			; delta_frames=13 [6072]
.long -2, 0x06330099			; delta_frames=2 [6074]
.long -1, 0x06440099			; delta_frames=1 [6075]
.long -2, 0x06440088			; delta_frames=2 [6077]
.long -1, 0x06550088			; delta_frames=1 [6078]
.long -2, 0x06550077			; delta_frames=2 [6080]
.long -3, 0x06660066			; delta_frames=3 [6083]
.long -13, 0x063300aa			; delta_frames=13 [6096]
.long -2, 0x06440099			; delta_frames=2 [6098]
.long -2, 0x06550088			; delta_frames=2 [6100]
.long -2, 0x06550077			; delta_frames=2 [6102]
.long -1, 0x06660077			; delta_frames=1 [6103]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [6104]
.long -2, 0x06440099			; delta_frames=2 [6106]
.long -2, 0x06550088			; delta_frames=2 [6108]
.long -2, 0x06550077			; delta_frames=2 [6110]
.long -1, 0x06660077			; delta_frames=1 [6111]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [6112]
.long -2, 0x06440099			; delta_frames=2 [6114]
.long -2, 0x06550088			; delta_frames=2 [6116]
.long -2, 0x06550077			; delta_frames=2 [6118]
.long -1, 0x06660077			; delta_frames=1 [6119]
.long -1, 0x06660066, 0x063300aa			; delta_frames=1 [6120]
.long -1, 0x03eeeeee, 0x07ffffee			; delta_frames=1 [6121]
.long -1, 0x01444444, 0x02888888, 0x06330099, 0x07eeeeee			; delta_frames=1 [6122]
.long -1, 0x01555555, 0x03dddddd, 0x07eeeedd			; delta_frames=1 [6123]
.long -1, 0x07dddddd			; delta_frames=1 [6124]
.long -1, 0x02999999, 0x03cccccc, 0x06330088, 0x07ddddcc			; delta_frames=1 [6125]
.long -1, 0x00110000, 0x01666666, 0x03bbbbbb, 0x07ddddbb			; delta_frames=1 [6126]
.long -1, 0x05330022, 0x06330077, 0x07ccccbb			; delta_frames=1 [6127]
.long -1, 0x01777777, 0x02aaaaaa, 0x03aaaaaa, 0x07ccccaa			; delta_frames=1 [6128]
.long -1, 0x01888888, 0x03999999, 0x07bbbb99			; delta_frames=1 [6129]
.long -1, 0x06330066			; delta_frames=1 [6130]
.long -1, 0x02bbbbbb, 0x03888888, 0x07aaaa88			; delta_frames=1 [6131]
.long -1, 0x00111111, 0x01999999, 0x05331122, 0x06331166			; delta_frames=1 [6132]
.long -1, 0x03777777, 0x05221122, 0x06221155, 0x07aaaa77			; delta_frames=1 [6133]
.long -1, 0x01aaaaaa, 0x02cccccc, 0x03666666, 0x07999966			; delta_frames=1 [6134]
.long -1, 0x01bbbbbb, 0x06221144			; delta_frames=1 [6135]
.long -1, 0x03555555, 0x07888855			; delta_frames=1 [6136]
.long -1, 0x02dddddd, 0x03444444, 0x07888844			; delta_frames=1 [6137]
.long -1, 0x00221111, 0x01cccccc, 0x06221133			; delta_frames=1 [6138]
.long -1, 0x03333333, 0x05221111, 0x07777733			; delta_frames=1 [6139]
.long -1, 0x01dddddd, 0x02eeeeee			; delta_frames=1 [6140]
.long -1, 0x01eeeeee, 0x03222222, 0x06221122, 0x07666622			; delta_frames=1 [6141]
.long -1, 0x03111111, 0x07666611			; delta_frames=1 [6142]
.long -1, 0x02ffffff, 0x06221111, 0x07555511			; delta_frames=1 [6143]
.long -1, 0x01ffffff, 0x03000000, 0x07555500			; delta_frames=1 [6144]
.long -1537, 0x01eeeeee, 0x02ffeeee, 0x03111111, 0x06222222, 0x07666611			; delta_frames=1537 [7681]
.long -1, 0x01dddddd, 0x02eeeedd, 0x03222222, 0x05222222, 0x06332233, 0x07667722			; delta_frames=1 [7682]
.long -1, 0x01ddcccc, 0x02eeddcc, 0x03444433, 0x05332222, 0x06333344, 0x07778844			; delta_frames=1 [7683]
.long -1, 0x01ccbbaa, 0x02ddccbb, 0x03555544, 0x05332233, 0x06444455, 0x07778855			; delta_frames=1 [7684]
.long -1, 0x01bbaa99, 0x02ddccaa, 0x03666655, 0x05333333, 0x06445566, 0x07889966			; delta_frames=1 [7685]
.long -1, 0x01aa9988, 0x02ccbbaa, 0x03887777, 0x05443344, 0x06556677, 0x0799aa88			; delta_frames=1 [7686]
.long -1, 0x01998877, 0x02ccaa99, 0x03998888, 0x0799bb99			; delta_frames=1 [7687]
.long -1, 0x01887766, 0x02bbaa88, 0x03aa9999, 0x05444444, 0x06557788, 0x07aaccaa			; delta_frames=1 [7688]
.long -1, 0x01886655, 0x02bb9977, 0x03bbbbaa, 0x05444455, 0x06668899, 0x07aaddbb			; delta_frames=1 [7689]
.long -1, 0x01775533, 0x02aa8866, 0x03ccccbb, 0x066688aa, 0x07bbddcc			; delta_frames=1 [7690]
.long -1, 0x01664422, 0x02aa8855, 0x03eeddcc, 0x05555566, 0x067799bb, 0x07bbeeee			; delta_frames=1 [7691]
.long -1, 0x01553311, 0x02997744, 0x03ffeedd, 0x0677aacc, 0x07ccffff			; delta_frames=1 [7692]
.long -745, 0x02997755, 0x0677aabb			; delta_frames=745 [8437]
.long -1, 0x01553322, 0x02887766, 0x05555555			; delta_frames=1 [8438]
.long -1, 0x01442222, 0x02888877, 0x03ffeeee, 0x068899aa, 0x07ddffff			; delta_frames=1 [8439]
.long -1, 0x01442233, 0x02888888, 0x03eeeeee, 0x05554444, 0x06889999, 0x07ddffee			; delta_frames=1 [8440]
.long -1, 0x02778899			; delta_frames=1 [8441]
.long -1, 0x00221122, 0x01442244, 0x027799aa, 0x06889988, 0x07eeffee			; delta_frames=1 [8442]
.long -1, 0x00110022, 0x01331144, 0x05554433, 0x06888877, 0x07eeeeee			; delta_frames=1 [8443]
.long -1, 0x026699bb			; delta_frames=1 [8444]
.long -1, 0x01331155, 0x026699cc, 0x03eeeeff, 0x05554422, 0x06998866			; delta_frames=1 [8445]
.long -1, 0x026699dd, 0x03ddeeff, 0x05553322, 0x06998855, 0x07eeeedd			; delta_frames=1 [8446]
.long -1, 0x01220066, 0x0255aaee, 0x05553311, 0x06997755, 0x07ffeedd			; delta_frames=1 [8447]
.long -1, 0x0255aaff, 0x06997744			; delta_frames=1 [8448]
.long -1536, 0x00000000, 0x013355ff, 0x0266ddff, 0x03ffffff, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff, 0x00444444			; delta_frames=1536 [9984]
.long -1, 0x00000000			; delta_frames=1 [9985]
.long -24, 0x053355ee, 0x0666ccee, 0x07eeeeee			; delta_frames=24 [10009]
.long -2, 0x053344dd, 0x0655bbdd, 0x07dddddd			; delta_frames=2 [10011]
.long -2, 0x052244cc, 0x0655aacc, 0x07cccccc			; delta_frames=2 [10013]
.long -1, 0x052244bb, 0x0655aabb, 0x07bbbbbb			; delta_frames=1 [10014]
.long -1, 0x064499bb			; delta_frames=1 [10015]
.long -1, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=1 [10016]
.long -1, 0x05223399, 0x06448899, 0x07999999			; delta_frames=1 [10017]
.long -2, 0x05223388, 0x06337788, 0x07888888			; delta_frames=2 [10019]
.long -2, 0x05112277, 0x06336677, 0x07777777			; delta_frames=2 [10021]
.long -1, 0x05112266, 0x06335566, 0x07666666			; delta_frames=1 [10022]
.long -1, 0x06225566			; delta_frames=1 [10023]
.long -1, 0x05112255, 0x06224455, 0x07555555			; delta_frames=1 [10024]
.long -1, 0x05111144, 0x06224444, 0x07444444			; delta_frames=1 [10025]
.long -1, 0x06223344			; delta_frames=1 [10026]
.long -1, 0x05111133, 0x06113333, 0x07333333			; delta_frames=1 [10027]
.long -1, 0x06112233			; delta_frames=1 [10028]
.long -1, 0x05001122, 0x06112222, 0x07222222			; delta_frames=1 [10029]
.long -1, 0x05000011, 0x06111111, 0x07111111			; delta_frames=1 [10030]
.long -1, 0x06001111			; delta_frames=1 [10031]
.long -1, 0x05000000, 0x06000000, 0x07000000, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=1 [10032]
.long -552, 0x00444444			; delta_frames=552 [10584]
.long -1, 0x00000000			; delta_frames=1 [10585]
.long -24, 0x053355ee, 0x0666ccee, 0x07eeeeee			; delta_frames=24 [10609]
.long -2, 0x053344dd, 0x0655bbdd, 0x07dddddd			; delta_frames=2 [10611]
.long -2, 0x052244cc, 0x0655aacc, 0x07cccccc			; delta_frames=2 [10613]
.long -1, 0x052244bb, 0x0655aabb, 0x07bbbbbb			; delta_frames=1 [10614]
.long -1, 0x064499bb			; delta_frames=1 [10615]
.long -1, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=1 [10616]
.long -1, 0x05223399, 0x06448899, 0x07999999			; delta_frames=1 [10617]
.long -2, 0x05223388, 0x06337788, 0x07888888			; delta_frames=2 [10619]
.long -2, 0x05112277, 0x06336677, 0x07777777			; delta_frames=2 [10621]
.long -1, 0x05112266, 0x06335566, 0x07666666			; delta_frames=1 [10622]
.long -1, 0x06225566			; delta_frames=1 [10623]
.long -1, 0x05112255, 0x06224455, 0x07555555			; delta_frames=1 [10624]
.long -1, 0x05111144, 0x06224444, 0x07444444			; delta_frames=1 [10625]
.long -1, 0x06223344			; delta_frames=1 [10626]
.long -1, 0x05111133, 0x06113333, 0x07333333			; delta_frames=1 [10627]
.long -1, 0x06112233			; delta_frames=1 [10628]
.long -1, 0x05001122, 0x06112222, 0x07222222			; delta_frames=1 [10629]
.long -1, 0x05000011, 0x06111111, 0x07111111			; delta_frames=1 [10630]
.long -1, 0x06001111			; delta_frames=1 [10631]
.long -1, 0x05000000, 0x06000000, 0x07000000, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=1 [10632]
.long -120, 0x00444444			; delta_frames=120 [10752]
.long -1, 0x00000000			; delta_frames=1 [10753]
.long -18, 0x053344dd, 0x0655bbdd, 0x07dddddd			; delta_frames=18 [10771]
.long -1, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=1 [10772]
.long -1, 0x05223388, 0x06337788, 0x07888888			; delta_frames=1 [10773]
.long -1, 0x05112255, 0x06224455, 0x07555555			; delta_frames=1 [10774]
.long -1, 0x05111133, 0x06112233, 0x07333333			; delta_frames=1 [10775]
.long -1, 0x05000000, 0x06000000, 0x07000000			; delta_frames=1 [10776]
.long -48, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=48 [10824]
.long -288, 0x013355ff			; delta_frames=288 [11112]
.long -4, 0x0166ddff			; delta_frames=4 [11116]
.long -4, 0x013355ff			; delta_frames=4 [11120]
.long -8, 0x0166ddff			; delta_frames=8 [11128]
.long -4, 0x013355ff			; delta_frames=4 [11132]
.long -2, 0x0166ddff			; delta_frames=2 [11134]
.long -2, 0x013355ff			; delta_frames=2 [11136]
.long -24, 0x00444444			; delta_frames=24 [11160]
.long -1, 0x00000000			; delta_frames=1 [11161]
.long -18, 0x053344dd, 0x0655bbdd, 0x07dddddd			; delta_frames=18 [11179]
.long -1, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=1 [11180]
.long -1, 0x05223388, 0x06337788, 0x07888888			; delta_frames=1 [11181]
.long -1, 0x05112255, 0x06224455, 0x07555555			; delta_frames=1 [11182]
.long -1, 0x05111133, 0x06112233, 0x07333333			; delta_frames=1 [11183]
.long -1, 0x05000000, 0x06000000, 0x07000000, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=1 [11184]
.long -168, 0x00444444			; delta_frames=168 [11352]
.long -1, 0x00000000			; delta_frames=1 [11353]
.long -24, 0x053355ee, 0x0666ccee, 0x07eeeeee			; delta_frames=24 [11377]
.long -2, 0x053344dd, 0x0655bbdd, 0x07dddddd			; delta_frames=2 [11379]
.long -2, 0x052244cc, 0x0655aacc, 0x07cccccc			; delta_frames=2 [11381]
.long -1, 0x052244bb, 0x0655aabb, 0x07bbbbbb			; delta_frames=1 [11382]
.long -1, 0x064499bb			; delta_frames=1 [11383]
.long -1, 0x052233aa, 0x064499aa, 0x07aaaaaa			; delta_frames=1 [11384]
.long -1, 0x05223399, 0x06448899, 0x07999999			; delta_frames=1 [11385]
.long -2, 0x05223388, 0x06337788, 0x07888888			; delta_frames=2 [11387]
.long -2, 0x05112277, 0x06336677, 0x07777777			; delta_frames=2 [11389]
.long -1, 0x05112266, 0x06335566, 0x07666666			; delta_frames=1 [11390]
.long -1, 0x06225566			; delta_frames=1 [11391]
.long -1, 0x05112255, 0x06224455, 0x07555555			; delta_frames=1 [11392]
.long -1, 0x05111144, 0x06224444, 0x07444444			; delta_frames=1 [11393]
.long -1, 0x06223344			; delta_frames=1 [11394]
.long -1, 0x05111133, 0x06113333, 0x07333333			; delta_frames=1 [11395]
.long -1, 0x06112233			; delta_frames=1 [11396]
.long -1, 0x05001122, 0x06112222, 0x07222222			; delta_frames=1 [11397]
.long -1, 0x05000011, 0x06111111, 0x07111111			; delta_frames=1 [11398]
.long -1, 0x06001111			; delta_frames=1 [11399]
.long -1, 0x05000000, 0x06000000, 0x07000000, 0x04000000, 0x053355ff, 0x0666ddff, 0x07ffffff			; delta_frames=1 [11400]
.long -120, 0x04000000, 0x05223333, 0x0633aaaa, 0x07aaffff, 0x00ffffff, 0x01eeeedd, 0x02dddd77, 0x03996633, 0x06ffffff, 0x07bbddff			; delta_frames=120 [11520]
.long -1, 0x07aaccee			; delta_frames=1 [11521]
.long -1, 0x07aabbdd			; delta_frames=1 [11522]
.long -1, 0x0799bbcc			; delta_frames=1 [11523]
.long -1, 0x0788aabb			; delta_frames=1 [11524]
.long -1, 0x077799aa			; delta_frames=1 [11525]
.long -1, 0x07778899			; delta_frames=1 [11526]
.long -1, 0x07667788			; delta_frames=1 [11527]
.long -1, 0x07556677			; delta_frames=1 [11528]
.long -1, 0x07446666			; delta_frames=1 [11529]
.long -1, 0x07445555			; delta_frames=1 [11530]
.long -1, 0x07334444			; delta_frames=1 [11531]
.long -1, 0x07223333			; delta_frames=1 [11532]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11544]
.long -1, 0x07aaccee			; delta_frames=1 [11545]
.long -1, 0x07aabbdd			; delta_frames=1 [11546]
.long -1, 0x0799bbcc			; delta_frames=1 [11547]
.long -1, 0x0788aabb			; delta_frames=1 [11548]
.long -1, 0x077799aa			; delta_frames=1 [11549]
.long -1, 0x07778899			; delta_frames=1 [11550]
.long -1, 0x07667788			; delta_frames=1 [11551]
.long -1, 0x07556677			; delta_frames=1 [11552]
.long -1, 0x07446666			; delta_frames=1 [11553]
.long -1, 0x07445555			; delta_frames=1 [11554]
.long -1, 0x07334444			; delta_frames=1 [11555]
.long -1, 0x07223333			; delta_frames=1 [11556]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11568]
.long -1, 0x07aaccee			; delta_frames=1 [11569]
.long -1, 0x07aabbdd			; delta_frames=1 [11570]
.long -1, 0x0799bbcc			; delta_frames=1 [11571]
.long -1, 0x0788aabb			; delta_frames=1 [11572]
.long -1, 0x077799aa			; delta_frames=1 [11573]
.long -1, 0x07778899			; delta_frames=1 [11574]
.long -1, 0x07667788			; delta_frames=1 [11575]
.long -1, 0x07556677			; delta_frames=1 [11576]
.long -1, 0x07446666			; delta_frames=1 [11577]
.long -1, 0x07445555			; delta_frames=1 [11578]
.long -1, 0x07334444			; delta_frames=1 [11579]
.long -1, 0x07223333			; delta_frames=1 [11580]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11592]
.long -1, 0x07aaccee			; delta_frames=1 [11593]
.long -1, 0x07aabbdd			; delta_frames=1 [11594]
.long -1, 0x0799bbcc			; delta_frames=1 [11595]
.long -1, 0x0788aabb			; delta_frames=1 [11596]
.long -1, 0x077799aa			; delta_frames=1 [11597]
.long -1, 0x07778899			; delta_frames=1 [11598]
.long -1, 0x07667788			; delta_frames=1 [11599]
.long -1, 0x07556677			; delta_frames=1 [11600]
.long -1, 0x07446666			; delta_frames=1 [11601]
.long -1, 0x07445555			; delta_frames=1 [11602]
.long -1, 0x07334444			; delta_frames=1 [11603]
.long -1, 0x07223333			; delta_frames=1 [11604]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11616]
.long -1, 0x07aaccee			; delta_frames=1 [11617]
.long -1, 0x07aabbdd			; delta_frames=1 [11618]
.long -1, 0x0799bbcc			; delta_frames=1 [11619]
.long -1, 0x0788aabb			; delta_frames=1 [11620]
.long -1, 0x077799aa			; delta_frames=1 [11621]
.long -1, 0x07778899			; delta_frames=1 [11622]
.long -1, 0x07667788			; delta_frames=1 [11623]
.long -1, 0x07556677			; delta_frames=1 [11624]
.long -1, 0x07446666			; delta_frames=1 [11625]
.long -1, 0x07445555			; delta_frames=1 [11626]
.long -1, 0x07334444			; delta_frames=1 [11627]
.long -1, 0x07223333			; delta_frames=1 [11628]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11640]
.long -1, 0x07aaccee			; delta_frames=1 [11641]
.long -1, 0x07aabbdd			; delta_frames=1 [11642]
.long -1, 0x0799bbcc			; delta_frames=1 [11643]
.long -1, 0x0788aabb			; delta_frames=1 [11644]
.long -1, 0x077799aa			; delta_frames=1 [11645]
.long -1, 0x07778899			; delta_frames=1 [11646]
.long -1, 0x07667788			; delta_frames=1 [11647]
.long -1, 0x07556677			; delta_frames=1 [11648]
.long -1, 0x07446666			; delta_frames=1 [11649]
.long -1, 0x07445555			; delta_frames=1 [11650]
.long -1, 0x07334444			; delta_frames=1 [11651]
.long -1, 0x07223333			; delta_frames=1 [11652]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11664]
.long -1, 0x07aaccee			; delta_frames=1 [11665]
.long -1, 0x07aabbdd			; delta_frames=1 [11666]
.long -1, 0x0799bbcc			; delta_frames=1 [11667]
.long -1, 0x0788aabb			; delta_frames=1 [11668]
.long -1, 0x077799aa			; delta_frames=1 [11669]
.long -1, 0x07778899			; delta_frames=1 [11670]
.long -1, 0x07667788			; delta_frames=1 [11671]
.long -1, 0x07556677			; delta_frames=1 [11672]
.long -1, 0x07446666			; delta_frames=1 [11673]
.long -1, 0x07445555			; delta_frames=1 [11674]
.long -1, 0x07334444			; delta_frames=1 [11675]
.long -1, 0x07223333			; delta_frames=1 [11676]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11688]
.long -1, 0x07aaccee			; delta_frames=1 [11689]
.long -1, 0x07aabbdd			; delta_frames=1 [11690]
.long -1, 0x0799bbcc			; delta_frames=1 [11691]
.long -1, 0x0788aabb			; delta_frames=1 [11692]
.long -1, 0x077799aa			; delta_frames=1 [11693]
.long -1, 0x07778899			; delta_frames=1 [11694]
.long -1, 0x07667788			; delta_frames=1 [11695]
.long -1, 0x07556677			; delta_frames=1 [11696]
.long -1, 0x07446666			; delta_frames=1 [11697]
.long -1, 0x07445555			; delta_frames=1 [11698]
.long -1, 0x07334444			; delta_frames=1 [11699]
.long -1, 0x07223333			; delta_frames=1 [11700]
.long -12, 0x00ffffff, 0x01eeeedd, 0x02dddd77, 0x03996633, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11712]
.long -1, 0x07aaccee			; delta_frames=1 [11713]
.long -1, 0x07aabbdd			; delta_frames=1 [11714]
.long -1, 0x0799bbcc			; delta_frames=1 [11715]
.long -1, 0x0788aabb			; delta_frames=1 [11716]
.long -1, 0x077799aa			; delta_frames=1 [11717]
.long -1, 0x07778899			; delta_frames=1 [11718]
.long -1, 0x07667788			; delta_frames=1 [11719]
.long -1, 0x07556677			; delta_frames=1 [11720]
.long -1, 0x07446666			; delta_frames=1 [11721]
.long -1, 0x07445555			; delta_frames=1 [11722]
.long -1, 0x07334444			; delta_frames=1 [11723]
.long -1, 0x07223333			; delta_frames=1 [11724]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11736]
.long -1, 0x07aaccee			; delta_frames=1 [11737]
.long -1, 0x07aabbdd			; delta_frames=1 [11738]
.long -1, 0x0799bbcc			; delta_frames=1 [11739]
.long -1, 0x0788aabb			; delta_frames=1 [11740]
.long -1, 0x077799aa			; delta_frames=1 [11741]
.long -1, 0x07778899			; delta_frames=1 [11742]
.long -1, 0x07667788			; delta_frames=1 [11743]
.long -1, 0x07556677			; delta_frames=1 [11744]
.long -1, 0x07446666			; delta_frames=1 [11745]
.long -1, 0x07445555			; delta_frames=1 [11746]
.long -1, 0x07334444			; delta_frames=1 [11747]
.long -1, 0x07223333			; delta_frames=1 [11748]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11760]
.long -1, 0x07aaccee			; delta_frames=1 [11761]
.long -1, 0x07aabbdd			; delta_frames=1 [11762]
.long -1, 0x0799bbcc			; delta_frames=1 [11763]
.long -1, 0x0788aabb			; delta_frames=1 [11764]
.long -1, 0x077799aa			; delta_frames=1 [11765]
.long -1, 0x07778899			; delta_frames=1 [11766]
.long -1, 0x07667788			; delta_frames=1 [11767]
.long -1, 0x07556677			; delta_frames=1 [11768]
.long -1, 0x07446666			; delta_frames=1 [11769]
.long -1, 0x07445555			; delta_frames=1 [11770]
.long -1, 0x07334444			; delta_frames=1 [11771]
.long -1, 0x07223333			; delta_frames=1 [11772]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11784]
.long -1, 0x07aaccee			; delta_frames=1 [11785]
.long -1, 0x07aabbdd			; delta_frames=1 [11786]
.long -1, 0x0799bbcc			; delta_frames=1 [11787]
.long -1, 0x0788aabb			; delta_frames=1 [11788]
.long -1, 0x077799aa			; delta_frames=1 [11789]
.long -1, 0x07778899			; delta_frames=1 [11790]
.long -1, 0x07667788			; delta_frames=1 [11791]
.long -1, 0x07556677			; delta_frames=1 [11792]
.long -1, 0x07446666			; delta_frames=1 [11793]
.long -1, 0x07445555			; delta_frames=1 [11794]
.long -1, 0x07334444			; delta_frames=1 [11795]
.long -1, 0x07223333			; delta_frames=1 [11796]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11808]
.long -1, 0x07aaccee			; delta_frames=1 [11809]
.long -1, 0x07aabbdd			; delta_frames=1 [11810]
.long -1, 0x0799bbcc			; delta_frames=1 [11811]
.long -1, 0x0788aabb			; delta_frames=1 [11812]
.long -1, 0x077799aa			; delta_frames=1 [11813]
.long -1, 0x07778899			; delta_frames=1 [11814]
.long -1, 0x07667788			; delta_frames=1 [11815]
.long -1, 0x07556677			; delta_frames=1 [11816]
.long -1, 0x07446666			; delta_frames=1 [11817]
.long -1, 0x07445555			; delta_frames=1 [11818]
.long -1, 0x07334444			; delta_frames=1 [11819]
.long -1, 0x07223333			; delta_frames=1 [11820]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11832]
.long -1, 0x07aaccee			; delta_frames=1 [11833]
.long -1, 0x07aabbdd			; delta_frames=1 [11834]
.long -1, 0x0799bbcc			; delta_frames=1 [11835]
.long -1, 0x0788aabb			; delta_frames=1 [11836]
.long -1, 0x077799aa			; delta_frames=1 [11837]
.long -1, 0x07778899			; delta_frames=1 [11838]
.long -1, 0x07667788			; delta_frames=1 [11839]
.long -1, 0x07556677			; delta_frames=1 [11840]
.long -1, 0x07446666			; delta_frames=1 [11841]
.long -1, 0x07445555			; delta_frames=1 [11842]
.long -1, 0x07334444			; delta_frames=1 [11843]
.long -1, 0x07223333			; delta_frames=1 [11844]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11856]
.long -1, 0x07aaccee			; delta_frames=1 [11857]
.long -1, 0x07aabbdd			; delta_frames=1 [11858]
.long -1, 0x0799bbcc			; delta_frames=1 [11859]
.long -1, 0x0788aabb			; delta_frames=1 [11860]
.long -1, 0x077799aa			; delta_frames=1 [11861]
.long -1, 0x07778899			; delta_frames=1 [11862]
.long -1, 0x07667788			; delta_frames=1 [11863]
.long -1, 0x07556677			; delta_frames=1 [11864]
.long -1, 0x07446666			; delta_frames=1 [11865]
.long -1, 0x07445555			; delta_frames=1 [11866]
.long -1, 0x07334444			; delta_frames=1 [11867]
.long -1, 0x07223333			; delta_frames=1 [11868]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11880]
.long -1, 0x07aaccee			; delta_frames=1 [11881]
.long -1, 0x07aabbdd			; delta_frames=1 [11882]
.long -1, 0x0799bbcc			; delta_frames=1 [11883]
.long -1, 0x0788aabb			; delta_frames=1 [11884]
.long -1, 0x077799aa			; delta_frames=1 [11885]
.long -1, 0x07778899			; delta_frames=1 [11886]
.long -1, 0x07667788			; delta_frames=1 [11887]
.long -1, 0x07556677			; delta_frames=1 [11888]
.long -1, 0x07446666			; delta_frames=1 [11889]
.long -1, 0x07445555			; delta_frames=1 [11890]
.long -1, 0x07334444			; delta_frames=1 [11891]
.long -1, 0x07223333			; delta_frames=1 [11892]
.long -12, 0x00ffffff, 0x01eeeedd, 0x02dddd77, 0x03996633, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11904]
.long -1, 0x07aaccee			; delta_frames=1 [11905]
.long -1, 0x07aabbdd			; delta_frames=1 [11906]
.long -1, 0x0799bbcc			; delta_frames=1 [11907]
.long -1, 0x0788aabb			; delta_frames=1 [11908]
.long -1, 0x077799aa			; delta_frames=1 [11909]
.long -1, 0x07778899			; delta_frames=1 [11910]
.long -1, 0x07667788			; delta_frames=1 [11911]
.long -1, 0x07556677			; delta_frames=1 [11912]
.long -1, 0x07446666			; delta_frames=1 [11913]
.long -1, 0x07445555			; delta_frames=1 [11914]
.long -1, 0x07334444			; delta_frames=1 [11915]
.long -1, 0x07223333			; delta_frames=1 [11916]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11928]
.long -1, 0x07aaccee			; delta_frames=1 [11929]
.long -1, 0x07aabbdd			; delta_frames=1 [11930]
.long -1, 0x0799bbcc			; delta_frames=1 [11931]
.long -1, 0x0788aabb			; delta_frames=1 [11932]
.long -1, 0x077799aa			; delta_frames=1 [11933]
.long -1, 0x07778899			; delta_frames=1 [11934]
.long -1, 0x07667788			; delta_frames=1 [11935]
.long -1, 0x07556677			; delta_frames=1 [11936]
.long -1, 0x07446666			; delta_frames=1 [11937]
.long -1, 0x07445555			; delta_frames=1 [11938]
.long -1, 0x07334444			; delta_frames=1 [11939]
.long -1, 0x07223333			; delta_frames=1 [11940]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11952]
.long -1, 0x07aaccee			; delta_frames=1 [11953]
.long -1, 0x07aabbdd			; delta_frames=1 [11954]
.long -1, 0x0799bbcc			; delta_frames=1 [11955]
.long -1, 0x0788aabb			; delta_frames=1 [11956]
.long -1, 0x077799aa			; delta_frames=1 [11957]
.long -1, 0x07778899			; delta_frames=1 [11958]
.long -1, 0x07667788			; delta_frames=1 [11959]
.long -1, 0x07556677			; delta_frames=1 [11960]
.long -1, 0x07446666			; delta_frames=1 [11961]
.long -1, 0x07445555			; delta_frames=1 [11962]
.long -1, 0x07334444			; delta_frames=1 [11963]
.long -1, 0x07223333			; delta_frames=1 [11964]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [11976]
.long -1, 0x07aaccee			; delta_frames=1 [11977]
.long -1, 0x07aabbdd			; delta_frames=1 [11978]
.long -1, 0x0799bbcc			; delta_frames=1 [11979]
.long -1, 0x0788aabb			; delta_frames=1 [11980]
.long -1, 0x077799aa			; delta_frames=1 [11981]
.long -1, 0x07778899			; delta_frames=1 [11982]
.long -1, 0x07667788			; delta_frames=1 [11983]
.long -1, 0x07556677			; delta_frames=1 [11984]
.long -1, 0x07446666			; delta_frames=1 [11985]
.long -1, 0x07445555			; delta_frames=1 [11986]
.long -1, 0x07334444			; delta_frames=1 [11987]
.long -1, 0x07223333			; delta_frames=1 [11988]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12000]
.long -1, 0x07aaccee			; delta_frames=1 [12001]
.long -1, 0x07aabbdd			; delta_frames=1 [12002]
.long -1, 0x0799bbcc			; delta_frames=1 [12003]
.long -1, 0x0788aabb			; delta_frames=1 [12004]
.long -1, 0x077799aa			; delta_frames=1 [12005]
.long -1, 0x07778899			; delta_frames=1 [12006]
.long -1, 0x07667788			; delta_frames=1 [12007]
.long -1, 0x07556677			; delta_frames=1 [12008]
.long -1, 0x07446666			; delta_frames=1 [12009]
.long -1, 0x07445555			; delta_frames=1 [12010]
.long -1, 0x07334444			; delta_frames=1 [12011]
.long -1, 0x07223333			; delta_frames=1 [12012]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12024]
.long -1, 0x07aaccee			; delta_frames=1 [12025]
.long -1, 0x07aabbdd			; delta_frames=1 [12026]
.long -1, 0x0799bbcc			; delta_frames=1 [12027]
.long -1, 0x0788aabb			; delta_frames=1 [12028]
.long -1, 0x077799aa			; delta_frames=1 [12029]
.long -1, 0x07778899			; delta_frames=1 [12030]
.long -1, 0x07667788			; delta_frames=1 [12031]
.long -1, 0x07556677			; delta_frames=1 [12032]
.long -1, 0x07446666			; delta_frames=1 [12033]
.long -1, 0x07445555			; delta_frames=1 [12034]
.long -1, 0x07334444			; delta_frames=1 [12035]
.long -1, 0x07223333			; delta_frames=1 [12036]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12048]
.long -1, 0x07aaccee			; delta_frames=1 [12049]
.long -1, 0x07aabbdd			; delta_frames=1 [12050]
.long -1, 0x0799bbcc			; delta_frames=1 [12051]
.long -1, 0x0788aabb			; delta_frames=1 [12052]
.long -1, 0x077799aa			; delta_frames=1 [12053]
.long -1, 0x07778899			; delta_frames=1 [12054]
.long -1, 0x07667788			; delta_frames=1 [12055]
.long -1, 0x07556677			; delta_frames=1 [12056]
.long -1, 0x07446666			; delta_frames=1 [12057]
.long -1, 0x07445555			; delta_frames=1 [12058]
.long -1, 0x07334444			; delta_frames=1 [12059]
.long -1, 0x07223333			; delta_frames=1 [12060]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12072]
.long -1, 0x07aaccee			; delta_frames=1 [12073]
.long -1, 0x07aabbdd			; delta_frames=1 [12074]
.long -1, 0x0799bbcc			; delta_frames=1 [12075]
.long -1, 0x0788aabb			; delta_frames=1 [12076]
.long -1, 0x077799aa			; delta_frames=1 [12077]
.long -1, 0x07778899			; delta_frames=1 [12078]
.long -1, 0x07667788			; delta_frames=1 [12079]
.long -1, 0x07556677			; delta_frames=1 [12080]
.long -1, 0x07446666			; delta_frames=1 [12081]
.long -1, 0x07445555			; delta_frames=1 [12082]
.long -1, 0x07334444			; delta_frames=1 [12083]
.long -1, 0x07223333			; delta_frames=1 [12084]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12096]
.long -1, 0x07aaccee			; delta_frames=1 [12097]
.long -1, 0x07aabbdd			; delta_frames=1 [12098]
.long -1, 0x0799bbcc			; delta_frames=1 [12099]
.long -1, 0x0788aabb			; delta_frames=1 [12100]
.long -1, 0x077799aa			; delta_frames=1 [12101]
.long -1, 0x07778899			; delta_frames=1 [12102]
.long -1, 0x07667788			; delta_frames=1 [12103]
.long -1, 0x07556677			; delta_frames=1 [12104]
.long -1, 0x07446666			; delta_frames=1 [12105]
.long -1, 0x07445555			; delta_frames=1 [12106]
.long -1, 0x07334444			; delta_frames=1 [12107]
.long -1, 0x07223333			; delta_frames=1 [12108]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12120]
.long -1, 0x07aaccee			; delta_frames=1 [12121]
.long -1, 0x07aabbdd			; delta_frames=1 [12122]
.long -1, 0x0799bbcc			; delta_frames=1 [12123]
.long -1, 0x0788aabb			; delta_frames=1 [12124]
.long -1, 0x077799aa			; delta_frames=1 [12125]
.long -1, 0x07778899			; delta_frames=1 [12126]
.long -1, 0x07667788			; delta_frames=1 [12127]
.long -1, 0x07556677			; delta_frames=1 [12128]
.long -1, 0x07446666			; delta_frames=1 [12129]
.long -1, 0x07445555			; delta_frames=1 [12130]
.long -1, 0x07334444			; delta_frames=1 [12131]
.long -1, 0x07223333			; delta_frames=1 [12132]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12144]
.long -1, 0x07aaccee			; delta_frames=1 [12145]
.long -1, 0x07aabbdd			; delta_frames=1 [12146]
.long -1, 0x0799bbcc			; delta_frames=1 [12147]
.long -1, 0x0788aabb			; delta_frames=1 [12148]
.long -1, 0x077799aa			; delta_frames=1 [12149]
.long -1, 0x07778899			; delta_frames=1 [12150]
.long -1, 0x07667788			; delta_frames=1 [12151]
.long -1, 0x07556677			; delta_frames=1 [12152]
.long -1, 0x07446666			; delta_frames=1 [12153]
.long -1, 0x07445555			; delta_frames=1 [12154]
.long -1, 0x07334444			; delta_frames=1 [12155]
.long -1, 0x07223333			; delta_frames=1 [12156]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12168]
.long -1, 0x07aaccee			; delta_frames=1 [12169]
.long -1, 0x07aabbdd			; delta_frames=1 [12170]
.long -1, 0x0799bbcc			; delta_frames=1 [12171]
.long -1, 0x0788aabb			; delta_frames=1 [12172]
.long -1, 0x077799aa			; delta_frames=1 [12173]
.long -1, 0x07778899			; delta_frames=1 [12174]
.long -1, 0x07667788			; delta_frames=1 [12175]
.long -1, 0x07556677			; delta_frames=1 [12176]
.long -1, 0x07446666			; delta_frames=1 [12177]
.long -1, 0x07445555			; delta_frames=1 [12178]
.long -1, 0x07334444			; delta_frames=1 [12179]
.long -1, 0x07223333			; delta_frames=1 [12180]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12192]
.long -1, 0x07aaccee			; delta_frames=1 [12193]
.long -1, 0x07aabbdd			; delta_frames=1 [12194]
.long -1, 0x0799bbcc			; delta_frames=1 [12195]
.long -1, 0x0788aabb			; delta_frames=1 [12196]
.long -1, 0x077799aa			; delta_frames=1 [12197]
.long -1, 0x07778899			; delta_frames=1 [12198]
.long -1, 0x07667788			; delta_frames=1 [12199]
.long -1, 0x07556677			; delta_frames=1 [12200]
.long -1, 0x07446666			; delta_frames=1 [12201]
.long -1, 0x07445555			; delta_frames=1 [12202]
.long -1, 0x07334444			; delta_frames=1 [12203]
.long -1, 0x07223333			; delta_frames=1 [12204]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12216]
.long -1, 0x07aaccee			; delta_frames=1 [12217]
.long -1, 0x07aabbdd			; delta_frames=1 [12218]
.long -1, 0x0799bbcc			; delta_frames=1 [12219]
.long -1, 0x0788aabb			; delta_frames=1 [12220]
.long -1, 0x077799aa			; delta_frames=1 [12221]
.long -1, 0x07778899			; delta_frames=1 [12222]
.long -1, 0x07667788			; delta_frames=1 [12223]
.long -1, 0x07556677			; delta_frames=1 [12224]
.long -1, 0x07446666			; delta_frames=1 [12225]
.long -1, 0x07445555			; delta_frames=1 [12226]
.long -1, 0x07334444			; delta_frames=1 [12227]
.long -1, 0x07223333			; delta_frames=1 [12228]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12240]
.long -1, 0x07aaccee			; delta_frames=1 [12241]
.long -1, 0x07aabbdd			; delta_frames=1 [12242]
.long -1, 0x0799bbcc			; delta_frames=1 [12243]
.long -1, 0x0788aabb			; delta_frames=1 [12244]
.long -1, 0x077799aa			; delta_frames=1 [12245]
.long -1, 0x07778899			; delta_frames=1 [12246]
.long -1, 0x07667788			; delta_frames=1 [12247]
.long -1, 0x07556677			; delta_frames=1 [12248]
.long -1, 0x07446666			; delta_frames=1 [12249]
.long -1, 0x07445555			; delta_frames=1 [12250]
.long -1, 0x07334444			; delta_frames=1 [12251]
.long -1, 0x07223333			; delta_frames=1 [12252]
.long -12, 0x06ffffff, 0x07bbddff			; delta_frames=12 [12264]
.long -1, 0x07aaccee			; delta_frames=1 [12265]
.long -1, 0x07aabbdd			; delta_frames=1 [12266]
.long -1, 0x0799bbcc			; delta_frames=1 [12267]
.long -1, 0x0788aabb			; delta_frames=1 [12268]
.long -1, 0x077799aa			; delta_frames=1 [12269]
.long -1, 0x07778899			; delta_frames=1 [12270]
.long -1, 0x07667788			; delta_frames=1 [12271]
.long -1, 0x07556677			; delta_frames=1 [12272]
.long -1, 0x07446666			; delta_frames=1 [12273]
.long -1, 0x07445555			; delta_frames=1 [12274]
.long -1, 0x07334444			; delta_frames=1 [12275]
.long -1, 0x07223333			; delta_frames=1 [12276]
.long -13, 0x00eeeeee, 0x01ddddcc, 0x02cccc77, 0x06eeeeee			; delta_frames=13 [12289]
.long -1, 0x02cccc66, 0x03886633			; delta_frames=1 [12290]
.long -1, 0x00dddddd, 0x01ccccbb, 0x02bbbb66, 0x03885533, 0x06dddddd			; delta_frames=1 [12291]
.long -2, 0x00cccccc, 0x01bbbbaa, 0x02aaaa66, 0x03775522, 0x05222222, 0x06cccccc, 0x07222222			; delta_frames=2 [12293]
.long -1, 0x00bbbbbb, 0x02aaaa55, 0x06bbbbbb			; delta_frames=1 [12294]
.long -1, 0x01aaaa99, 0x02999955, 0x03664422, 0x05112222, 0x07112222			; delta_frames=1 [12295]
.long -1, 0x00aaaaaa, 0x01999999, 0x06aaaaaa			; delta_frames=1 [12296]
.long -1, 0x00999999, 0x01999988, 0x02888844, 0x06999999			; delta_frames=1 [12297]
.long -1, 0x01888888, 0x03554422			; delta_frames=1 [12298]
.long -1, 0x00888888, 0x01888877, 0x02777744, 0x03553322, 0x06888888			; delta_frames=1 [12299]
.long -1, 0x01777777			; delta_frames=1 [12300]
.long -1, 0x00777777, 0x01666666, 0x02666633, 0x03443311, 0x05111111, 0x06777777, 0x07111111			; delta_frames=1 [12301]
.long -1, 0x00666666, 0x01666655, 0x02555533, 0x06666666			; delta_frames=1 [12302]
.long -1, 0x01555555, 0x03332211			; delta_frames=1 [12303]
.long -1, 0x00555555, 0x01555544, 0x02444422, 0x06555555			; delta_frames=1 [12304]
.long -1, 0x00444444, 0x01444444, 0x06444444			; delta_frames=1 [12305]
.long -1, 0x01444433, 0x02333322, 0x03222211			; delta_frames=1 [12306]
.long -1, 0x00333333, 0x01333333, 0x02333311, 0x03221111, 0x05001111, 0x06333333, 0x07001111			; delta_frames=1 [12307]
.long -1, 0x01222222, 0x02222211			; delta_frames=1 [12308]
.long -1, 0x00222222, 0x03111100, 0x05000000, 0x06222222, 0x07000000			; delta_frames=1 [12309]
.long -1, 0x00111111, 0x01111111, 0x02111111, 0x06111111			; delta_frames=1 [12310]
.long -1, 0x02111100, 0x03000000			; delta_frames=1 [12311]
.long -1, 0x00000000, 0x01000000, 0x02000000, 0x06000000			; delta_frames=1 [12312]
.long 0x80000000	; END_SCRIPT.
